#ifdef LUACONSOLE
#ifdef _MSC_VER
#include "common/Platform.h"
#include "resource.h"
#endif
#include "luaconsole.h"

void luaopen_multiplayer(lua_State *l)
{
#ifndef _MSC_VER
	int multiplayer_luac_sz = 202035;
	const char* multiplayer_luac = "local env__ = setmetatable({}, { __index = function(_, key)\n\011return rawget(_G, key) or error(\"__index on env: \" .. tostring(key), 2)\nend, __newindex = function(_, key)\n\011error(\"__newindex on env: \" .. tostring(key), 2)\nend})\nlocal _ENV = env__\nif rawget(_G, \"setfenv\") then\n\011setfenv(1, env__)\nend\n\nmath.randomseed(os.time())\n\nlocal require_preload__ = {}\nlocal require_loaded__ = {}\nlocal function require(modname)\n\011local mod = require_loaded__[modname]\n\011if not mod then\n\011\011mod = assert(assert(require_preload__[modname], \"missing module \" .. modname)())\n\011\011require_loaded__[modname] = mod\n\011end\n\011return mod\nend\nrawset(env__, \"require\", require)\n\nrequire_preload__[\"tptmp.client\"] = function()\n\n\011local loadtime_error\n\011local http = rawget(_G, \"http\")\n\011local socket = rawget(_G, \"socket\")\n\011if sim.CELL ~= 4 then -- * Required by cursor snapping functions.\n\011\011loadtime_error = \"CELL size is not 4\"\n\011elseif sim.PMAPBITS >= 13 then -- * Required by how non-element tools are encoded (extended tool IDs, XIDs).\n\011\011loadtime_error = \"PMAPBITS is too large\"\n\011elseif not (tpt.version and tpt.version.major >= 96 and tpt.version.minor >= 1) then\n\011\011loadtime_error = \"version not supported\"\n\011elseif not rawget(_G, \"bit\") then\n\011\011loadtime_error = \"no bit API\"\n\011elseif not http then\n\011\011loadtime_error = \"no http API\"\n\011elseif not socket then\n\011\011loadtime_error = \"no socket API\"\n\011elseif socket.bind then\n\011\011loadtime_error = \"outdated socket API\"\n\011elseif tpt.version.jacob1s_mod and not tpt.tab_menu then\n\011\011loadtime_error = \"mod version not supported\"\n\011elseif tpt.version.mobilemajor then\n\011\011loadtime_error = \"platform not supported\"\n\011end\n\011\n\011local config      =                        require(\"tptmp.client.config\")\n\011local colours     = not loadtime_error and require(\"tptmp.client.colours\")\n\011local window      = not loadtime_error and require(\"tptmp.client.window\")\n\011local side_button = not loadtime_error and require(\"tptmp.client.side_button\")\n\011local localcmd    = not loadtime_error and require(\"tptmp.client.localcmd\")\n\011local client      = not loadtime_error and require(\"tptmp.client.client\")\n\011local util        = not loadtime_error and require(\"tptmp.client.util\")\n\011local profile     = not loadtime_error and require(\"tptmp.client.profile\")\n\011local format      = not loadtime_error and require(\"tptmp.client.format\")\n\011local manager     = not loadtime_error and require(\"tptmp.client.manager\")\n\011\n\011local function run()\n\011\011if rawget(_G, \"TPTMP\") then\n\011\011\011if TPTMP.version <= config.version then\n\011\011\011\011TPTMP.disableMultiplayer()\n\011\011\011else\n\011\011\011\011loadtime_error = \"newer version already running\"\n\011\011\011end\n\011\011end\n\011\011if loadtime_error then\n\011\011\011print(\"TPTMP \" .. config.versionstr .. \": Cannot load: \" .. loadtime_error)\n\011\011\011return\n\011\011end\n\011\n\011\011local hooks_enabled = false\n\011\011local window_status = \"hidden\"\n\011\011local window_hide_mode = \"hidden\"\n\011\011local function set_floating(floating)\n\011\011\011window_hide_mode = floating and \"floating\" or \"hidden\"\n\011\011end\n\011\011local function get_window_status()\n\011\011\011return window_status\n\011\011end\n\011\011local TPTMP = {\n\011\011\011version = config.version,\n\011\011\011versionStr = config.versionstr,\n\011\011}\n\011\011local hide_window, show_window, begin_chat\n\011\011setmetatable(TPTMP, { __newindex = function(tbl, key, value)\n\011\011\011if key == \"chatHidden\" then\n\011\011\011\011if value then\n\011\011\011\011\011hide_window()\n\011\011\011\011else\n\011\011\011\011\011show_window()\n\011\011\011\011end\n\011\011\011\011return\n\011\011\011end\n\011\011\011rawset(tbl, key, value)\n\011\011end, __index = function(tbl, key)\n\011\011\011if key == \"chatHidden\" then\n\011\011\011\011return window_status ~= \"shown\"\n\011\011\011end\n\011\011\011return rawset(tbl, key)\n\011\011end })\n\011\011rawset(_G, \"TPTMP\", TPTMP)\n\011\n\011\011local current_id, current_hist = util.get_save_id()\n\011\011local function set_id(id, hist)\n\011\011\011current_id, current_hist = id, hist\n\011\011end\n\011\011local function get_id()\n\011\011\011return current_id, current_hist\n\011\011end\n\011\n\011\011local quickauth = manager.get(\"quickauthToken\", \"\")\n\011\011local function set_qa(qa)\n\011\011\011quickauth = qa\n\011\011\011manager.set(\"quickauthToken\", quickauth)\n\011\011end\n\011\011local function get_qa()\n\011\011\011return quickauth\n\011\011end\n\011\n\011\011local function log_event(text)\n\011\011\011print(text)\n\011\011end\n\011\n\011\011local should_reconnect_at\n\011\011local cli\n\011\011local prof = profile.new({\n\011\011\011set_id_func = set_id,\n\011\011\011get_id_func = get_id,\n\011\011\011log_event_func = log_event,\n\011\011\011registered_func = function()\n\011\011\011\011return cli and cli:registered()\n\011\011\011end\n\011\011})\n\011\011local win\n\011\011local should_reconnect = false\n\011\011local function kill_client()\n\011\011\011win:set_subtitle(\"status\", \"Not connected\")\n\011\011\011cli:fps_sync(false)\n\011\011\011cli:stop()\n\011\011\011if should_reconnect then\n\011\011\011\011should_reconnect = false\n\011\011\011\011should_reconnect_at = socket.gettime() + config.reconnect_later_timeout\n\011\011\011\011win:backlog_push_neutral(\"* Will attempt to reconnect in \" .. config.reconnect_later_timeout .. \" seconds\")\n\011\011\011end\n\011\011\011cli = nil\n\011\011end\n\011\011function begin_chat()\n\011\011\011show_window()\n\011\011\011win.hide_when_chat_done = true\n\011\011end\n\011\011function hide_window()\n\011\011\011window_status = window_hide_mode\n\011\011\011win.in_focus = false\n\011\011end\n\011\011function show_window()\n\011\011\011if not hooks_enabled then\n\011\011\011\011TPTMP.enableMultiplayer()\n\011\011\011end\n\011\011\011window_status = \"shown\"\n\011\011\011win:backlog_bump_marker()\n\011\011\011win.in_focus = true\n\011\011end\n\011\011win = window.new({\n\011\011\011hide_window_func = hide_window,\n\011\011\011window_status_func = get_window_status,\n\011\011\011log_event_func = log_event,\n\011\011\011client_func = function()\n\011\011\011\011return cli and cli:registered() and cli\n\011\011\011end,\n\011\011\011localcmd_parse_func = function(str)\n\011\011\011\011return cmd:parse(str)\n\011\011\011end,\n\011\011\011should_ignore_mouse_func = function(str)\n\011\011\011\011return prof:should_ignore_mouse()\n\011\011\011end,\n\011\011})\n\011\011local cmd = localcmd.new({\n\011\011\011window_status_func = get_window_status,\n\011\011\011window_set_floating_func = set_floating,\n\011\011\011client_func = function()\n\011\011\011\011return cli and cli:registered() and cli\n\011\011\011end,\n\011\011\011new_client_func = function(params)\n\011\011\011\011should_reconnect_at = nil\n\011\011\011\011params.window = win\n\011\011\011\011params.profile = prof\n\011\011\011\011params.set_id_func = set_id\n\011\011\011\011params.get_id_func = get_id\n\011\011\011\011params.set_qa_func = set_qa\n\011\011\011\011params.get_qa_func = get_qa\n\011\011\011\011params.log_event_func = log_event\n\011\011\011\011params.should_reconnect_func = function()\n\011\011\011\011\011should_reconnect = true\n\011\011\011\011end\n\011\011\011\011params.should_not_reconnect_func = function()\n\011\011\011\011\011should_reconnect = false\n\011\011\011\011end\n\011\011\011\011cli = client.new(params)\n\011\011\011\011return cli\n\011\011\011end,\n\011\011\011kill_client_func = function()\n\011\011\011\011should_reconnect = false\n\011\011\011\011kill_client()\n\011\011\011end,\n\011\011\011window = win,\n\011\011})\n\011\011win.localcmd = cmd\n\011\011local sbtn = side_button.new({\n\011\011\011notif_count_func = function()\n\011\011\011\011return win:backlog_notif_count()\n\011\011\011end,\n\011\011\011notif_important_func = function()\n\011\011\011\011return win:backlog_notif_important()\n\011\011\011end,\n\011\011\011show_window_func = show_window,\n\011\011\011hide_window_func = hide_window,\n\011\011\011begin_chat_func = begin_chat,\n\011\011\011window_status_func = get_window_status,\n\011\011\011sync_func = function()\n\011\011\011\011cmd:parse(\"/sync\")\n\011\011\011end,\n\011\011})\n\011\n\011\011local grab_drop_text_input\n\011\011do\n\011\011\011if rawget(_G, \"ui\") and ui.grabTextInput then\n\011\011\011\011local text_input_grabbed = false\n\011\011\011\011function grab_drop_text_input(should_grab)\n\011\011\011\011\011if text_input_grabbed and not should_grab then\n\011\011\011\011\011\011ui.dropTextInput()\n\011\011\011\011\011elseif not text_input_grabbed and should_grab then\n\011\011\011\011\011\011ui.grabTextInput()\n\011\011\011\011\011end\n\011\011\011\011\011text_input_grabbed = should_grab\n\011\011\011\011end\n\011\011\011end\n\011\011end\n\011\n\011\011local pcur_r, pcur_g, pcur_b, pcur_a = unpack(colours.common.player_cursor)\n\011\011local bmode_to_repr = {\n\011\011\011[ 0 ] = \"\",\n\011\011\011[ 1 ] = \" REPL\",\n\011\011\011[ 2 ] = \" SDEL\",\n\011\011}\n\011\011local function decode_rulestring(tool)\n\011\011\011if tool.type == \"cgol\" then\n\011\011\011\011return tool.repr\n\011\011\011end\n\011\011end\n\011\011local function handle_tick()\n\011\011\011local now = socket.gettime()\n\011\011\011if should_reconnect_at and now >= should_reconnect_at then\n\011\011\011\011should_reconnect_at = nil\n\011\011\011\011win:backlog_push_neutral(\"* Attempting to reconnect\")\n\011\011\011\011cmd:parse(\"/reconnect\")\n\011\011\011end\n\011\011\011if grab_drop_text_input then\n\011\011\011\011grab_drop_text_input(window_status == \"shown\")\n\011\011\011end\n\011\011\011if cli then\n\011\011\011\011cli:tick()\n\011\011\011\011if cli:status() ~= \"running\" then\n\011\011\011\011\011kill_client()\n\011\011\011\011end\n\011\011\011end\n\011\011\011if cli then\n\011\011\011\011for _, member in pairs(cli.id_to_member) do\n\011\011\011\011\011if member:can_render() then\n\011\011\011\011\011\011local px, py = member.pos_x, member.pos_y\n\011\011\011\011\011\011local sx, sy = member.size_x, member.size_y\n\011\011\011\011\011\011local rx, ry = member.rect_x, member.rect_y\n\011\011\011\011\011\011local lx, ly = member.line_x, member.line_y\n\011\011\011\011\011\011local zx, zy, zs = member.zoom_x, member.zoom_y, member.zoom_s\n\011\011\011\011\011\011if rx then\n\011\011\011\011\011\011\011sx, sy = 0, 0\n\011\011\011\011\011\011end\n\011\011\011\011\011\011local tool = member.last_tool or member.tool_l\n\011\011\011\011\011\011local tool_name = util.to_tool[tool] or decode_rulestring(tool) or \"UNKNOWN\"\n\011\011\011\011\011\011local tool_class = util.xid_class[tool]\n\011\011\011\011\011\011if elem[tool_name] and tool ~= 0 and tool_name ~= \"UNKNOWN\" then\n\011\011\011\011\011\011\011local real_name = elem.property(elem[tool_name], \"Name\")\n\011\011\011\011\011\011\011if real_name ~= \"\" then\n\011\011\011\011\011\011\011\011tool_name = real_name\n\011\011\011\011\011\011\011end\n\011\011\011\011\011\011end\n\011\011\011\011\011\011local add_argb = false\n\011\011\011\011\011\011if tool_name:find(\"^DEFAULT_DECOR_\") then\n\011\011\011\011\011\011\011add_argb = true\n\011\011\011\011\011\011end\n\011\011\011\011\011\011tool_name = tool_name:match(\"[^_]+$\") or tool_name\n\011\011\011\011\011\011if add_argb then\n\011\011\011\011\011\011\011tool_name = (\"%s %02X%02X%02X%02X\"):format(tool_name, member.deco_a, member.deco_r, member.deco_g, member.deco_b)\n\011\011\011\011\011\011end\n\011\011\011\011\011\011local repl_tool_name\n\011\011\011\011\011\011if member.bmode ~= 0 then\n\011\011\011\011\011\011\011local repl_tool = member.tool_x\n\011\011\011\011\011\011\011repl_tool_name = util.to_tool[repl_tool] or \"UNKNOWN\"\n\011\011\011\011\011\011\011local repl_tool_class = util.xid_class[repl_tool]\n\011\011\011\011\011\011\011if elem[repl_tool_name] and repl_tool ~= 0 and repl_tool_name ~= \"UNKNOWN\" then\n\011\011\011\011\011\011\011\011local real_name = elem.property(elem[repl_tool_name], \"Name\")\n\011\011\011\011\011\011\011\011if real_name ~= \"\" then\n\011\011\011\011\011\011\011\011\011repl_tool_name = real_name\n\011\011\011\011\011\011\011\011end\n\011\011\011\011\011\011\011end\n\011\011\011\011\011\011\011repl_tool_name = repl_tool_name:match(\"[^_]+$\") or repl_tool_name\n\011\011\011\011\011\011end\n\011\011\011\011\011\011if zx and util.inside_rect(zx, zy, zs, zs, px, py) then\n\011\011\011\011\011\011\011gfx.drawRect(zx - 1, zy - 1, zs + 2, zs + 2, pcur_r, pcur_g, pcur_b, pcur_a)\n\011\011\011\011\011\011\011if zs > 8 then\n\011\011\011\011\011\011\011\011gfx.drawText(zx, zy, \"\\238\\129\\165\", pcur_r, pcur_g, pcur_b, pcur_a)\n\011\011\011\011\011\011\011end\n\011\011\011\011\011\011end\n\011\011\011\011\011\011local offx, offy = 6, -9\n\011\011\011\011\011\011local player_info = member.formatted_nick\n\011\011\011\011\011\011if cli.fps_sync_ and member.fps_sync then\n\011\011\011\011\011\011\011player_info = (\"%s %s%+i\"):format(player_info, colours.commonstr.brush, member.fps_sync_count_diff)\n\011\011\011\011\011\011end\n\011\011\011\011\011\011local brush_info\n\011\011\011\011\011\011if member.select or member.place then\n\011\011\011\011\011\011\011local xlo, ylo, xhi, yhi, action\n\011\011\011\011\011\011\011if member.select then\n\011\011\011\011\011\011\011\011xlo = math.min(px, member.select_x)\n\011\011\011\011\011\011\011\011ylo = math.min(py, member.select_y)\n\011\011\011\011\011\011\011\011xhi = math.max(px, member.select_x)\n\011\011\011\011\011\011\011\011yhi = math.max(py, member.select_y)\n\011\011\011\011\011\011\011\011action = member.select\n\011\011\011\011\011\011\011else\n\011\011\011\011\011\011\011\011xlo = math.min(sim.XRES - member.place_w, math.max(0, px - math.floor(member.place_w / 2)))\n\011\011\011\011\011\011\011\011ylo = math.min(sim.YRES - member.place_h, math.max(0, py - math.floor(member.place_h / 2)))\n\011\011\011\011\011\011\011\011xhi = xlo + member.place_w\n\011\011\011\011\011\011\011\011yhi = ylo + member.place_h\n\011\011\011\011\011\011\011\011action = member.place\n\011\011\011\011\011\011\011end\n\011\011\011\011\011\011\011gfx.drawRect(xlo, ylo, xhi - xlo + 1, yhi - ylo + 1, pcur_r, pcur_g, pcur_b, pcur_a)\n\011\011\011\011\011\011\011brush_info = action\n\011\011\011\011\011\011else\n\011\011\011\011\011\011\011local dsx, dsy = sx * 2 + 1, sy * 2 + 1\n\011\011\011\011\011\011\011if tool_class == \"WL\" then\n\011\011\011\011\011\011\011\011px, py = util.wall_snap_coords(px, py)\n\011\011\011\011\011\011\011\011sx, sy = util.wall_snap_coords(sx, sy)\n\011\011\011\011\011\011\011\011offx, offy = offx + 3, offy + 1\n\011\011\011\011\011\011\011\011dsx, dsy = 2 * sx + 4, 2 * sy + 4\n\011\011\011\011\011\011\011end\n\011\011\011\011\011\011\011if sx < 50 then\n\011\011\011\011\011\011\011\011offx = offx + sx\n\011\011\011\011\011\011\011end\n\011\011\011\011\011\011\011brush_info = (\"%s %ix%i%s %s\"):format(tool_name, dsx, dsy, bmode_to_repr[member.bmode], repl_tool_name or \"\")\n\011\011\011\011\011\011\011if not rx then\n\011\011\011\011\011\011\011\011if not lx and member.kmod_s and member.kmod_c then\n\011\011\011\011\011\011\011\011\011gfx.drawLine(px - 5, py, px + 5, py, pcur_r, pcur_g, pcur_b, pcur_a)\n\011\011\011\011\011\011\011\011\011gfx.drawLine(px, py - 5, px, py + 5, pcur_r, pcur_g, pcur_b, pcur_a)\n\011\011\011\011\011\011\011\011elseif tool_class == \"WL\" then\n\011\011\011\011\011\011\011\011\011gfx.drawRect(px - sx, py - sy, dsx, dsy, pcur_r, pcur_g, pcur_b, pcur_a)\n\011\011\011\011\011\011\011\011elseif member.shape == 0 then\n\011\011\011\011\011\011\011\011\011gfx.drawCircle(px, py, sx, sy, pcur_r, pcur_g, pcur_b, pcur_a)\n\011\011\011\011\011\011\011\011elseif member.shape == 1 then\n\011\011\011\011\011\011\011\011\011gfx.drawRect(px - sx, py - sy, sx * 2 + 1, sy * 2 + 1, pcur_r, pcur_g, pcur_b, pcur_a)\n\011\011\011\011\011\011\011\011elseif member.shape == 2 then\n\011\011\011\011\011\011\011\011\011gfx.drawLine(px - sx, py + sy, px     , py - sy, pcur_r, pcur_g, pcur_b, pcur_a)\n\011\011\011\011\011\011\011\011\011gfx.drawLine(px - sx, py + sy, px + sx, py + sy, pcur_r, pcur_g, pcur_b, pcur_a)\n\011\011\011\011\011\011\011\011\011gfx.drawLine(px     , py - sy, px + sx, py + sy, pcur_r, pcur_g, pcur_b, pcur_a)\n\011\011\011\011\011\011\011\011end\n\011\011\011\011\011\011\011end\n\011\011\011\011\011\011\011if lx then\n\011\011\011\011\011\011\011\011if member.kmod_a then\n\011\011\011\011\011\011\011\011\011px, py = util.line_snap_coords(lx, ly, px, py)\n\011\011\011\011\011\011\011\011end\n\011\011\011\011\011\011\011\011gfx.drawLine(lx, ly, px, py, pcur_r, pcur_g, pcur_b, pcur_a)\n\011\011\011\011\011\011\011end\n\011\011\011\011\011\011\011if rx then\n\011\011\011\011\011\011\011\011if member.kmod_a then\n\011\011\011\011\011\011\011\011\011px, py = util.rect_snap_coords(rx, ry, px, py)\n\011\011\011\011\011\011\011\011end\n\011\011\011\011\011\011\011\011local x, y, w, h = util.corners_to_rect(px, py, rx, ry)\n\011\011\011\011\011\011\011\011gfx.drawRect(x, y, w, h, pcur_r, pcur_g, pcur_b, pcur_a)\n\011\011\011\011\011\011\011end\n\011\011\011\011\011\011end\n\011\011\011\011\011\011gfx.drawText(px + offx, py + offy, player_info, pcur_r, pcur_g, pcur_b, pcur_a)\n\011\011\011\011\011\011gfx.drawText(px + offx, py + offy + 12, brush_info, pcur_r, pcur_g, pcur_b, pcur_a)\n\011\011\011\011\011end\n\011\011\011\011end\n\011\011\011end\n\011\011\011if window_status ~= \"hidden\" and win:handle_tick() then\n\011\011\011\011return false\n\011\011\011end\n\011\011\011if sbtn:handle_tick() then\n\011\011\011\011return false\n\011\011\011end\n\011\011\011prof:handle_tick()\n\011\011end\n\011\n\011\011local function handle_mousemove(px, py, dx, dy)\n\011\011\011if prof:handle_mousemove(px, py, dx, dy) then\n\011\011\011\011return false\n\011\011\011end\n\011\011end\n\011\n\011\011local function handle_mousedown(px, py, button)\n\011\011\011if window_status == \"shown\" and win:handle_mousedown(px, py, button) then\n\011\011\011\011return false\n\011\011\011end\n\011\011\011if sbtn:handle_mousedown(px, py, button) then\n\011\011\011\011return false\n\011\011\011end\n\011\011\011if prof:handle_mousedown(px, py, button) then\n\011\011\011\011return false\n\011\011\011end\n\011\011end\n\011\n\011\011local function handle_mouseup(px, py, button, reason)\n\011\011\011if window_status == \"shown\" and win:handle_mouseup(px, py, button, reason) then\n\011\011\011\011return false\n\011\011\011end\n\011\011\011if sbtn:handle_mouseup(px, py, button, reason) then\n\011\011\011\011return false\n\011\011\011end\n\011\011\011if prof:handle_mouseup(px, py, button, reason) then\n\011\011\011\011return false\n\011\011\011end\n\011\011end\n\011\n\011\011local function handle_mousewheel(px, py, dir)\n\011\011\011if window_status == \"shown\" and win:handle_mousewheel(px, py, dir) then\n\011\011\011\011return false\n\011\011\011end\n\011\011\011if sbtn:handle_mousewheel(px, py, dir) then\n\011\011\011\011return false\n\011\011\011end\n\011\011\011if prof:handle_mousewheel(px, py, dir) then\n\011\011\011\011return false\n\011\011\011end\n\011\011end\n\011\n\011\011local function handle_keypress(key, scan, rep, shift, ctrl, alt)\n\011\011\011if window_status == \"shown\" and win:handle_keypress(key, scan, rep, shift, ctrl, alt) then\n\011\011\011\011return false\n\011\011\011end\n\011\011\011if sbtn:handle_keypress(key, scan, rep, shift, ctrl, alt) then\n\011\011\011\011return false\n\011\011\011end\n\011\011\011if prof:handle_keypress(key, scan, rep, shift, ctrl, alt) then\n\011\011\011\011return false\n\011\011\011end\n\011\011end\n\011\n\011\011local function handle_keyrelease(key, scan, rep, shift, ctrl, alt)\n\011\011\011if window_status == \"shown\" and win:handle_keyrelease(key, scan, rep, shift, ctrl, alt) then\n\011\011\011\011return false\n\011\011\011end\n\011\011\011if sbtn:handle_keyrelease(key, scan, rep, shift, ctrl, alt) then\n\011\011\011\011return false\n\011\011\011end\n\011\011\011if prof:handle_keyrelease(key, scan, rep, shift, ctrl, alt) then\n\011\011\011\011return false\n\011\011\011end\n\011\011end\n\011\n\011\011local function handle_textinput(text)\n\011\011\011if window_status == \"shown\" and win:handle_textinput(text) then\n\011\011\011\011return false\n\011\011\011end\n\011\011\011if sbtn:handle_textinput(text) then\n\011\011\011\011return false\n\011\011\011end\n\011\011\011if prof:handle_textinput(text) then\n\011\011\011\011return false\n\011\011\011end\n\011\011end\n\011\n\011\011local function handle_textediting(text)\n\011\011\011if window_status == \"shown\" and win:handle_textediting(text) then\n\011\011\011\011return false\n\011\011\011end\n\011\011\011if sbtn:handle_textediting(text) then\n\011\011\011\011return false\n\011\011\011end\n\011\011\011if prof:handle_textediting(text) then\n\011\011\011\011return false\n\011\011\011end\n\011\011end\n\011\n\011\011local function handle_blur()\n\011\011\011if window_status == \"shown\" and win:handle_blur() then\n\011\011\011\011return false\n\011\011\011end\n\011\011\011if sbtn:handle_blur() then\n\011\011\011\011return false\n\011\011\011end\n\011\011\011if prof:handle_blur() then\n\011\011\011\011return false\n\011\011\011end\n\011\011end\n\011\n\011\011evt.register(evt.tick      , handle_tick      )\n\011\011evt.register(evt.mousemove , handle_mousemove )\n\011\011evt.register(evt.mousedown , handle_mousedown )\n\011\011evt.register(evt.mouseup   , handle_mouseup   )\n\011\011evt.register(evt.mousewheel, handle_mousewheel)\n\011\011evt.register(evt.keypress  , handle_keypress  )\n\011\011evt.register(evt.textinput , handle_textinput )\n\011\011evt.register(evt.keyrelease, handle_keyrelease)\n\011\011evt.register(evt.blur      , handle_blur      )\n\011\011if evt.textediting then\n\011\011\011evt.register(evt.textediting, handle_textediting)\n\011\011end\n\011\n\011\011function TPTMP.disableMultiplayer()\n\011\011\011if cli then\n\011\011\011\011cmd:parse(\"/fpssync off\")\n\011\011\011\011cmd:parse(\"/disconnect\")\n\011\011\011end\n\011\011\011evt.unregister(evt.tick      , handle_tick      )\n\011\011\011evt.unregister(evt.mousemove , handle_mousemove )\n\011\011\011evt.unregister(evt.mousedown , handle_mousedown )\n\011\011\011evt.unregister(evt.mouseup   , handle_mouseup   )\n\011\011\011evt.unregister(evt.mousewheel, handle_mousewheel)\n\011\011\011evt.unregister(evt.keypress  , handle_keypress  )\n\011\011\011evt.unregister(evt.textinput , handle_textinput )\n\011\011\011evt.unregister(evt.keyrelease, handle_keyrelease)\n\011\011\011evt.unregister(evt.blur      , handle_blur      )\n\011\011\011if evt.textediting then\n\011\011\011\011evt.unregister(evt.textediting, handle_textediting)\n\011\011\011end\n\011\011\011_G.TPTMP = nil\n\011\011end\n\011\n\011\011function TPTMP.enableMultiplayer()\n\011\011\011hooks_enabled = true\n\011\011\011TPTMP.enableMultiplayer = nil\n\011\011end\n\011\n\011\011win:set_subtitle(\"status\", \"Not connected\")\n\011\011win:backlog_push_neutral(\"* Type \" .. colours.commonstr.error .. \"/connect\" .. colours.commonstr.neutral .. \" to join a server, \" .. colours.commonstr.error .. \"/list\" .. colours.commonstr.neutral .. \" for a list of commands, or \" .. colours.commonstr.error .. \"/help\" .. colours.commonstr.neutral .. \" for command help\")\n\011\011win:backlog_notif_reset()\n\011end\n\011\n\011return {\n\011\011run = run,\n\011}\n\011\nend\n\nrequire_preload__[\"tptmp.client.client\"] = function()\n\n\011local buffer_list = require(\"tptmp.common.buffer_list\")\n\011local colours     = require(\"tptmp.client.colours\")\n\011local config      = require(\"tptmp.client.config\")\n\011local util        = require(\"tptmp.client.util\")\n\011local format      = require(\"tptmp.client.format\")\n\011\n\011local can_yield_xpcall = coroutine.resume(coroutine.create(function()\n\011\011assert(pcall(coroutine.yield))\n\011end))\n\011\n\011local client_i = {}\n\011local client_m = { __index = client_i }\n\011\n\011local packet_handlers = {}\n\011\n\011local function get_msec()\n\011\011return math.floor(socket.gettime() * 1000)\n\011end\n\011\n\011local index_to_lrax = {\n\011\011[ 0 ] = \"tool_l\",\n\011\011[ 1 ] = \"tool_r\",\n\011\011[ 2 ] = \"tool_a\",\n\011\011[ 3 ] = \"tool_x\",\n\011}\n\011\n\011local function get_auth_token(uid, sess, audience)\n\011\011local req = http.get(config.auth_backend .. \"?Action=Get&Audience=\" .. util.urlencode(audience), {\n\011\011\011[ \"X-Auth-User-Id\" ] = uid,\n\011\011\011[ \"X-Auth-Session-Key\" ] = sess,\n\011\011})\n\011\011local started_at = socket.gettime()\n\011\011while req:status() == \"running\" do\n\011\011\011if socket.gettime() > started_at + config.auth_backend_timeout then\n\011\011\011\011return nil, \"timeout\", \"authentication backend down\"\n\011\011\011end\n\011\011\011coroutine.yield()\n\011\011end\n\011\011local body, code = req:finish()\n\011\011if code ~= 200 then\n\011\011\011return nil, \"non200\", code\n\011\011end\n\011\011local status = body:match([[\"Status\":\"([^\"]+)\"]])\n\011\011if status ~= \"OK\" then\n\011\011\011return nil, \"refused\", status\n\011\011end\n\011\011return body:match([[\"Token\":\"([^\"]+)\"]])\n\011end\n\011\n\011function client_i:proto_error_(...)\n\011\011self:stop(\"protocol error: \" .. string.format(...))\n\011\011coroutine.yield()\n\011end\n\011\n\011function client_i:proto_close_(message)\n\011\011self:stop(message)\n\011\011coroutine.yield()\n\011end\n\011\n\011function client_i:read_(count)\n\011\011while self.rx_:pending() < count do\n\011\011\011coroutine.yield()\n\011\011end\n\011\011return self.rx_:get(count)\n\011end\n\011\n\011function client_i:read_bytes_(count)\n\011\011while self.rx_:pending() < count do\n\011\011\011coroutine.yield()\n\011\011end\n\011\011local data, first, last = self.rx_:next()\n\011\011if last >= first + count - 1 then\n\011\011\011-- * Less memory-intensive path.\n\011\011\011self.rx_:pop(count)\n\011\011\011return data:byte(first, first + count - 1)\n\011\011end\n\011\011return self.rx_:get(count):byte(1, count)\n\011end\n\011\n\011function client_i:read_str24_()\n\011\011return self:read_(self:read_24be_())\n\011end\n\011\n\011function client_i:read_str8_()\n\011\011return self:read_(self:read_bytes_(1))\n\011end\n\011\n\011function client_i:read_nullstr_(max)\n\011\011local collect = {}\n\011\011while true do\n\011\011\011local byte = self:read_bytes_(1)\n\011\011\011if byte == 0 then\n\011\011\011\011break\n\011\011\011end\n\011\011\011if #collect == max then\n\011\011\011\011self:proto_error_(\"overlong nullstr\")\n\011\011\011end\n\011\011\011table.insert(collect, string.char(byte))\n\011\011end\n\011\011return table.concat(collect)\n\011end\n\011\n\011function client_i:read_24be_()\n\011\011local hi, mi, lo = self:read_bytes_(3)\n\011\011return bit.bor(lo, bit.lshift(mi, 8), bit.lshift(hi, 16))\n\011end\n\011\n\011function client_i:read_xy_12_()\n\011\011local d24 = self:read_24be_()\n\011\011return bit.rshift(d24, 12), bit.band(d24, 0xFFF)\n\011end\n\011\n\011function client_i:handle_disconnect_reason_2_()\n\011\011local reason = self:read_str8_()\n\011\011self.should_not_reconnect_func_()\n\011\011self:stop(reason)\n\011end\n\011\n\011function client_i:handle_ping_3_()\n\011\011self.last_ping_received_at_ = socket.gettime()\n\011end\n\011\n\011local member_i = {}\n\011local member_m = { __index = member_i }\n\011\n\011function member_i:can_render()\n\011\011return self.can_render_\n\011end\n\011\n\011function member_i:update_can_render()\n\011\011if not self.can_render_ then\n\011\011\011if self.deco_a ~= nil and\n\011\011\011   self.kmod_c ~= nil and\n\011\011\011   self.shape  ~= nil and\n\011\011\011   self.size_x ~= nil and\n\011\011\011   self.pos_x  ~= nil then\n\011\011\011\011self.can_render_ = true\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function client_i:add_member_(id, nick)\n\011\011if self.id_to_member[id] or id == self.self_id_ then\n\011\011\011self:proto_close_(\"member already exists\")\n\011\011end\n\011\011self.id_to_member[id] = setmetatable({\n\011\011\011nick = nick,\n\011\011\011fps_sync = false,\n\011\011}, member_m)\n\011end\n\011\n\011function client_i:push_names(prefix)\n\011\011self.window_:backlog_push_room(self.room_name_, self.id_to_member, prefix)\n\011end\n\011\n\011function client_i:push_fpssync()\n\011\011local members = {}\n\011\011for _, member in pairs(self.id_to_member) do\n\011\011\011if member.fps_sync then\n\011\011\011\011table.insert(members, member)\n\011\011\011end\n\011\011end\n\011\011self.window_:backlog_push_fpssync(members)\n\011end\n\011\n\011function client_i:handle_room_16_()\n\011\011sim.clearSim()\n\011\011self.room_name_ = self:read_str8_()\n\011\011local item_count\n\011\011self.self_id_, item_count = self:read_bytes_(2)\n\011\011self.id_to_member = {}\n\011\011for i = 1, item_count do\n\011\011\011local id = self:read_bytes_(1)\n\011\011\011local nick = self:read_str8_()\n\011\011\011self:add_member_(id, nick)\n\011\011end\n\011\011self:reformat_nicks_()\n\011\011self:push_names(\"Joined \")\n\011\011self.window_:set_subtitle(\"room\", self.room_name_)\n\011\011self.localcmd_:reconnect_commit({\n\011\011\011room = self.room_name_,\n\011\011\011host = self.host_,\n\011\011\011port = self.port_,\n\011\011\011secure = self.secure_,\n\011\011})\n\011\011self.profile_:user_sync()\n\011end\n\011\n\011function client_i:handle_join_17_()\n\011\011local id = self:read_bytes_(1)\n\011\011local nick = self:read_str8_()\n\011\011self:add_member_(id, nick)\n\011\011self:reformat_nicks_()\n\011\011self.window_:backlog_push_join(self.id_to_member[id].formatted_nick)\n\011\011self.profile_:user_sync()\n\011end\n\011\n\011function client_i:member_prefix_()\n\011\011local id = self:read_bytes_(1)\n\011\011local member = self.id_to_member[id]\n\011\011if not member then\n\011\011\011self:proto_close_(\"no such member\")\n\011\011end\n\011\011return member, id\n\011end\n\011\n\011function client_i:handle_leave_18_()\n\011\011local member, id = self:member_prefix_()\n\011\011local nick = member.nick\n\011\011self.window_:backlog_push_leave(self.id_to_member[id].formatted_nick)\n\011\011self.id_to_member[id] = nil\n\011end\n\011\n\011function client_i:handle_say_19_()\n\011\011local member = self:member_prefix_()\n\011\011local msg = self:read_str8_()\n\011\011self.window_:backlog_push_say_other(member.formatted_nick, msg)\n\011end\n\011\n\011function client_i:handle_say3rd_20_()\n\011\011local member = self:member_prefix_()\n\011\011local msg = self:read_str8_()\n\011\011self.window_:backlog_push_say3rd_other(member.formatted_nick, msg)\n\011end\n\011\n\011function client_i:handle_server_22_()\n\011\011local msg = self:read_str8_()\n\011\011self.window_:backlog_push_server(msg)\n\011end\n\011\n\011function client_i:handle_sync_30_()\n\011\011local member = self:member_prefix_()\n\011\011self:read_(3)\n\011\011local data = self:read_str24_()\n\011\011local ok, err = util.stamp_load(0, 0, data, true)\n\011\011if ok then\n\011\011\011self.log_event_func_(colours.commonstr.event .. \"Sync from \" .. member.formatted_nick)\n\011\011else\n\011\011\011self.log_event_func_(colours.commonstr.error .. \"Failed to sync from \" .. member.formatted_nick .. colours.commonstr.error .. \": \" .. err)\n\011\011end\n\011end\n\011\n\011function client_i:handle_pastestamp_31_()\n\011\011local member = self:member_prefix_()\n\011\011local x, y = self:read_xy_12_()\n\011\011local data = self:read_str24_()\n\011\011local ok, err = util.stamp_load(x, y, data, false)\n\011\011if ok then\n\011\011\011self.log_event_func_(colours.commonstr.event .. \"Stamp from \" .. member.formatted_nick) -- * Not really needed thanks to the stamp intent displays in init.lua.\n\011\011else\n\011\011\011self.log_event_func_(colours.commonstr.error .. \"Failed to paste stamp from \" .. member.formatted_nick .. colours.commonstr.error .. \": \" .. err)\n\011\011end\n\011end\n\011\n\011function client_i:handle_mousepos_32_()\n\011\011local member = self:member_prefix_()\n\011\011member.pos_x, member.pos_y = self:read_xy_12_()\n\011\011member:update_can_render()\n\011end\n\011\n\011function client_i:handle_brushmode_33_()\n\011\011local member = self:member_prefix_()\n\011\011local bmode = self:read_bytes_(1)\n\011\011member.bmode = bmode < 3 and bmode or 0\n\011\011member:update_can_render()\n\011end\n\011\n\011function client_i:handle_brushsize_34_()\n\011\011local member = self:member_prefix_()\n\011\011local x, y = self:read_bytes_(2)\n\011\011member.size_x = x\n\011\011member.size_y = y\n\011\011member:update_can_render()\n\011end\n\011\n\011function client_i:handle_brushshape_35_()\n\011\011local member = self:member_prefix_()\n\011\011member.shape = self:read_bytes_(1)\n\011\011member:update_can_render()\n\011end\n\011\n\011function client_i:handle_keybdmod_36_()\n\011\011local member = self:member_prefix_()\n\011\011local kmod = self:read_bytes_(1)\n\011\011member.kmod_c = bit.band(kmod, 1) ~= 0\n\011\011member.kmod_s = bit.band(kmod, 2) ~= 0\n\011\011member.kmod_a = bit.band(kmod, 4) ~= 0\n\011\011member:update_can_render()\n\011end\n\011\n\011function client_i:handle_selecttool_37_()\n\011\011local member = self:member_prefix_()\n\011\011local hi, lo = self:read_bytes_(2)\n\011\011local tool = bit.bor(lo, bit.lshift(hi, 8))\n\011\011local index = bit.rshift(tool, 14)\n\011\011local xtype = bit.band(tool, 0x3FFF)\n\011\011member[index_to_lrax[index]] = util.to_tool[xtype] and xtype or util.unknown_xid\n\011\011member.last_toolslot = index\n\011end\n\011\n\011local simstates = {\n\011\011{\n\011\011\011format = \"Simulation %s by %s\",\n\011\011\011states = { \"unpaused\", \"paused\" },\n\011\011\011func = tpt.set_pause,\n\011\011\011shift = 0,\n\011\011\011size = 1,\n\011\011},\n\011\011{\n\011\011\011format = \"Heat simulation %s by %s\",\n\011\011\011states = { \"disabled\", \"enabled\" },\n\011\011\011func = tpt.heat,\n\011\011\011shift = 1,\n\011\011\011size = 1,\n\011\011},\n\011\011{\n\011\011\011format = \"Ambient heat simulation %s by %s\",\n\011\011\011states = { \"disabled\", \"enabled\" },\n\011\011\011func = tpt.ambient_heat,\n\011\011\011shift = 2,\n\011\011\011size = 1,\n\011\011},\n\011\011{\n\011\011\011format = \"Newtonian gravity %s by %s\",\n\011\011\011states = { \"disabled\", \"enabled\" },\n\011\011\011func = tpt.newtonian_gravity,\n\011\011\011shift = 3,\n\011\011\011size = 1,\n\011\011},\n\011\011{\n\011\011\011format = \"Sand effect %s by %s\",\n\011\011\011states = { \"disabled\", \"enabled\" },\n\011\011\011func = sim.prettyPowders,\n\011\011\011shift = 5,\n\011\011\011size = 1,\n\011\011},\n\011\011{\n\011\011\011format = \"Water equalisation %s by %s\",\n\011\011\011states = { \"disabled\", \"enabled\" },\n\011\011\011func = sim.waterEqualisation,\n\011\011\011shift = 4,\n\011\011\011size = 1,\n\011\011},\n\011\011{\n\011\011\011format = \"Gravity mode set to %s by %s\",\n\011\011\011states = { \"vertical\", \"off\", \"radial\" },\n\011\011\011func = sim.gravityMode,\n\011\011\011shift = 8,\n\011\011\011size = 2,\n\011\011},\n\011\011{\n\011\011\011format = \"Air mode set to %s by %s\",\n\011\011\011states = { \"on\", \"pressure off\", \"velocity off\", \"off\", \"no update\" },\n\011\011\011func = sim.airMode,\n\011\011\011shift = 10,\n\011\011\011size = 3,\n\011\011},\n\011\011{\n\011\011\011format = \"Edge mode set to %s by %s\",\n\011\011\011states = { \"void\", \"solid\", \"loop\" },\n\011\011\011func = sim.edgeMode,\n\011\011\011shift = 13,\n\011\011\011size = 2,\n\011\011},\n\011}\n\011function client_i:handle_simstate_38_()\n\011\011local member = self:member_prefix_()\n\011\011local lo, hi = self:read_bytes_(2)\n\011\011local temp = self:read_24be_()\n\011\011local bits = bit.bor(lo, bit.lshift(hi, 8))\n\011\011for i = 1, #simstates do\n\011\011\011local desc = simstates[i]\n\011\011\011local value = bit.band(bit.rshift(bits, desc.shift), bit.lshift(1, desc.size) - 1)\n\011\011\011if value + 1 > #desc.states then\n\011\011\011\011value = 0\n\011\011\011end\n\011\011\011if desc.func() ~= value then\n\011\011\011\011desc.func(value)\n\011\011\011\011self.log_event_func_(colours.commonstr.event .. desc.format:format(desc.states[value + 1], member.formatted_nick))\n\011\011\011end\n\011\011end\n\011\011if util.ambient_air_temp() ~= temp then\n\011\011\011local set = util.ambient_air_temp(temp)\n\011\011\011self.log_event_func_(colours.commonstr.event .. (\"Ambient air temperature set to %.2f by %s\"):format(set, member.formatted_nick))\n\011\011end\n\011\011self.profile_:sample_simstate()\n\011end\n\011\n\011function client_i:handle_flood_39_()\n\011\011local member = self:member_prefix_()\n\011\011local index = self:read_bytes_(1)\n\011\011if index > 3 then\n\011\011\011index = 0\n\011\011end\n\011\011member.last_tool = member[index_to_lrax[index]]\n\011\011local x, y = self:read_xy_12_()\n\011\011util.flood_any(x, y, member.last_tool, -1, -1, member)\n\011end\n\011\n\011function client_i:handle_lineend_40_()\n\011\011local member = self:member_prefix_()\n\011\011local x1, y1 = member.line_x, member.line_y\n\011\011local x2, y2 = self:read_xy_12_()\n\011\011if member.kmod_a then\n\011\011\011x2, y2 = util.line_snap_coords(x1, y1, x2, y2)\n\011\011end\n\011\011util.create_line_any(x1, y1, x2, y2, member.size_x, member.size_y, member.last_tool, member.shape, member, false)\n\011\011member.line_x, member.line_y = nil, nil\n\011end\n\011\n\011function client_i:handle_rectend_41_()\n\011\011local member = self:member_prefix_()\n\011\011local x1, y1 = member.rect_x, member.rect_y\n\011\011local x2, y2 = self:read_xy_12_()\n\011\011if member.kmod_a then\n\011\011\011x2, y2 = util.rect_snap_coords(x1, y1, x2, y2)\n\011\011end\n\011\011util.create_box_any(x1, y1, x2, y2, member.last_tool, member)\n\011\011member.rect_x, member.rect_y = nil, nil\n\011end\n\011\n\011function client_i:handle_pointsstart_42_()\n\011\011local member = self:member_prefix_()\n\011\011local index = self:read_bytes_(1)\n\011\011if index > 3 then\n\011\011\011index = 0\n\011\011end\n\011\011member.last_tool = member[index_to_lrax[index]]\n\011\011local x, y = self:read_xy_12_()\n\011\011util.create_parts_any(x, y, member.size_x, member.size_y, member.last_tool, member.shape, member)\n\011\011member.last_x = x\n\011\011member.last_y = y\n\011end\n\011\n\011function client_i:handle_pointscont_43_()\n\011\011local member = self:member_prefix_()\n\011\011local x, y = self:read_xy_12_()\n\011\011util.create_line_any(member.last_x, member.last_y, x, y, member.size_x, member.size_y, member.last_tool, member.shape, member, true)\n\011\011member.last_x = x\n\011\011member.last_y = y\n\011end\n\011\n\011function client_i:handle_linestart_44_()\n\011\011local member = self:member_prefix_()\n\011\011local index = self:read_bytes_(1)\n\011\011if index > 3 then\n\011\011\011index = 0\n\011\011end\n\011\011member.last_tool = member[index_to_lrax[index]]\n\011\011member.line_x, member.line_y = self:read_xy_12_()\n\011end\n\011\n\011function client_i:handle_rectstart_45_()\n\011\011local member = self:member_prefix_()\n\011\011local index = self:read_bytes_(1)\n\011\011if index > 3 then\n\011\011\011index = 0\n\011\011end\n\011\011member.last_tool = member[index_to_lrax[index]]\n\011\011member.rect_x, member.rect_y = self:read_xy_12_()\n\011end\n\011\n\011function client_i:handle_custgolinfo_46_()\n\011\011local member = self:member_prefix_()\n\011\011local ruleset = bit.band(self:read_24be_(), 0x1FFFFF)\n\011\011local primary = self:read_24be_()\n\011\011local secondary = self:read_24be_()\n\011\011local begin = bit.band(bit.rshift(ruleset, 8), 0x1FE)\n\011\011local stay = bit.band(ruleset, 0x1FF)\n\011\011local states = bit.band(bit.rshift(ruleset, 17), 0xF) + 2\n\011\011local repr = {}\n\011\011table.insert(repr, \"B\")\n\011\011for i = 0, 8 do\n\011\011\011if bit.band(bit.lshift(1, i), begin) ~= 0 then\n\011\011\011\011table.insert(repr, i)\n\011\011\011end\n\011\011end\n\011\011table.insert(repr, \"/\")\n\011\011table.insert(repr, \"S\")\n\011\011for i = 0, 8 do\n\011\011\011if bit.band(bit.lshift(1, i), stay) ~= 0 then\n\011\011\011\011table.insert(repr, i)\n\011\011\011end\n\011\011end\n\011\011if states ~= 2 then\n\011\011\011table.insert(repr, \"/\")\n\011\011\011table.insert(repr, states)\n\011\011end\n\011\011member[index_to_lrax[member.last_toolslot]] = {\n\011\011\011type = \"cgol\",\n\011\011\011repr = table.concat(repr),\n\011\011\011ruleset = ruleset,\n\011\011\011primary = primary,\n\011\011\011secondary = secondary,\n\011\011\011elem = bit.bor(elem.DEFAULT_PT_LIFE, bit.lshift(ruleset, sim.PMAPBITS)),\n\011\011}\n\011end\n\011\n\011function client_i:handle_stepsim_50_()\n\011\011local member = self:member_prefix_()\n\011\011tpt.set_pause(1)\n\011\011sim.framerender(1)\n\011\011self.log_event_func_(colours.commonstr.event .. \"Single-frame step from \" .. member.formatted_nick)\n\011end\n\011\n\011function client_i:handle_sparkclear_60_()\n\011\011local member = self:member_prefix_()\n\011\011tpt.reset_spark()\n\011\011self.log_event_func_(colours.commonstr.event .. \"Sparks cleared by \" .. member.formatted_nick)\n\011end\n\011\n\011function client_i:handle_airclear_61_()\n\011\011local member = self:member_prefix_()\n\011\011tpt.reset_velocity()\n\011\011tpt.set_pressure()\n\011\011self.log_event_func_(colours.commonstr.event .. \"Pressure cleared by \" .. member.formatted_nick)\n\011end\n\011\n\011function client_i:handle_airinv_62_()\n\011\011-- * TODO[api]: add an api for this to tpt\n\011\011local member = self:member_prefix_()\n\011\011for x = 0, sim.XRES / sim.CELL - 1 do\n\011\011\011for y = 0, sim.YRES / sim.CELL - 1 do\n\011\011\011\011sim.pressure(x, y, -sim.pressure(x, y))\n\011\011\011end\n\011\011end\n\011\011self.log_event_func_(colours.commonstr.event .. \"Pressure inverted by \" .. member.formatted_nick)\n\011end\n\011\n\011function client_i:handle_clearsim_63_()\n\011\011local member = self:member_prefix_()\n\011\011sim.clearSim()\n\011\011self.set_id_func_(nil, nil)\n\011\011self.log_event_func_(colours.commonstr.event .. \"Simulation cleared by \" .. member.formatted_nick)\n\011end\n\011\n\011function client_i:handle_heatclear_64_()\n\011\011-- * TODO[api]: add an api for this to tpt\n\011\011local member = self:member_prefix_()\n\011\011util.heat_clear()\n\011\011self.log_event_func_(colours.commonstr.event .. \"Ambient heat reset by \" .. member.formatted_nick)\n\011end\n\011\n\011function client_i:handle_brushdeco_65_()\n\011\011local member = self:member_prefix_()\n\011\011member.deco_a, member.deco_r, member.deco_g, member.deco_b = self:read_bytes_(4)\n\011\011member:update_can_render()\n\011end\n\011\n\011function client_i:handle_clearrect_67_()\n\011\011self:member_prefix_()\n\011\011local x, y = self:read_xy_12_()\n\011\011local w, h = self:read_xy_12_()\n\011\011sim.clearRect(x, y, w, h)\n\011end\n\011\n\011function client_i:handle_canceldraw_68_()\n\011\011local member = self:member_prefix_()\n\011\011member.rect_x, member.rect_y = nil, nil\n\011\011member.line_x, member.line_y = nil, nil\n\011\011member.last_tool = nil\n\011end\n\011\n\011function client_i:handle_loadonline_69_()\n\011\011local member = self:member_prefix_()\n\011\011local id = self:read_24be_()\n\011\011local histhi = self:read_24be_()\n\011\011local histlo = self:read_24be_()\n\011\011local hist = histhi * 0x1000000 + histlo\n\011\011if id > 0 then\n\011\011\011sim.loadSave(id, 1, hist)\n\011\011\011coroutine.yield() -- * sim.loadSave seems to take effect one frame late.\n\011\011\011self.set_id_func_(id, hist)\n\011\011\011self.log_event_func_(colours.commonstr.event .. \"Online save \" .. (hist == 0 and \"id\" or \"history\") .. \":\" .. id .. \" loaded by \" .. member.formatted_nick)\n\011\011end\n\011end\n\011\n\011function client_i:handle_reloadsim_70_()\n\011\011local member = self:member_prefix_()\n\011\011if self.get_id_func_() then\n\011\011\011sim.reloadSave()\n\011\011end\n\011\011self.log_event_func_(colours.commonstr.event .. \"Simulation reloaded by \" .. member.formatted_nick)\n\011end\n\011\n\011function client_i:handle_placestatus_71_()\n\011\011local member = self:member_prefix_()\n\011\011local k = self:read_bytes_(1)\n\011\011local w, h = self:read_xy_12_()\n\011\011if k == 0 then\n\011\011\011member.place = nil\n\011\011elseif k == 1 then\n\011\011\011member.place = \"Pasting\"\n\011\011end\n\011\011member.place_w = w\n\011\011member.place_h = h\n\011end\n\011\n\011function client_i:handle_selectstatus_72_()\n\011\011local member = self:member_prefix_()\n\011\011local k = self:read_bytes_(1)\n\011\011local x, y = self:read_xy_12_()\n\011\011if k == 0 then\n\011\011\011member.select = nil\n\011\011elseif k == 1 then\n\011\011\011member.select = \"Copying\"\n\011\011elseif k == 2 then\n\011\011\011member.select = \"Cutting\"\n\011\011elseif k == 3 then\n\011\011\011member.select = \"Stamping\"\n\011\011end\n\011\011member.select_x = x\n\011\011member.select_y = y\n\011end\n\011\n\011function client_i:handle_zoomstart_73_()\n\011\011local member = self:member_prefix_()\n\011\011local x, y = self:read_xy_12_()\n\011\011local s = self:read_bytes_(1)\n\011\011member.zoom_x = x\n\011\011member.zoom_y = y\n\011\011member.zoom_s = s\n\011end\n\011\n\011function client_i:handle_zoomend_74_()\n\011\011local member = self:member_prefix_()\n\011\011member.zoom_x = nil\n\011\011member.zoom_y = nil\n\011\011member.zoom_s = nil\n\011end\n\011\n\011function client_i:handle_sparksign_75_()\n\011\011local member = self:member_prefix_()\n\011\011local x, y = self:read_xy_12_()\n\011\011sim.partCreate(-1, x, y, elem.DEFAULT_PT_SPRK)\n\011end\n\011\n\011function client_i:handle_fpssync_76_()\n\011\011local member = self:member_prefix_()\n\011\011local hi = self:read_24be_()\n\011\011local mi = self:read_24be_()\n\011\011local lo = self:read_24be_()\n\011\011local elapsed = hi * 0x1000 + math.floor(mi / 0x1000)\n\011\011local count = mi % 0x1000 * 0x1000000 + lo\n\011\011if member.fps_sync and elapsed <= member.fps_sync_elapsed then\n\011\011\011self:fps_sync_end_(member)\n\011\011end\n\011\011local now_msec = get_msec()\n\011\011if not member.fps_sync then\n\011\011\011member.fps_sync = true\n\011\011\011member.fps_sync_count_diff = 0\n\011\011\011member.fps_sync_first = now_msec\n\011\011\011member.fps_sync_history = {}\n\011\011\011if self.fps_sync_count_ then\n\011\011\011\011member.fps_sync_count_offset = count - self.fps_sync_count_\n\011\011\011end\n\011\011\011if self.fps_sync_ then\n\011\011\011\011self.window_:backlog_push_fpssync_enable(member.formatted_nick)\n\011\011\011end\n\011\011end\n\011\011member.fps_sync_last = now_msec\n\011\011member.fps_sync_elapsed = elapsed\n\011\011member.fps_sync_count = count\n\011\011local history_item = { elapsed = elapsed, count = count, now_msec = now_msec }\n\011\011local history_size = #member.fps_sync_history\n\011\011if history_size < 5 then\n\011\011\011table.insert(member.fps_sync_history, 1, history_item)\n\011\011else\n\011\011\011for i = 1, history_size - 1 do\n\011\011\011\011member.fps_sync_history[i + 1] = member.fps_sync_history[i]\n\011\011\011end\n\011\011\011member.fps_sync_history[1] = history_item\n\011\011end\n\011end\n\011\n\011function client_i:handle_sync_request_128_()\n\011\011self:send_sync_done()\n\011end\n\011\n\011function client_i:connect_()\n\011\011self.server_probably_secure_ = nil\n\011\011self.window_:set_subtitle(\"status\", \"Connecting\")\n\011\011self.socket_ = socket.tcp()\n\011\011self.socket_:settimeout(0)\n\011\011self.socket_:setoption(\"tcp-nodelay\", true)\n\011\011while true do\n\011\011\011local ok, err = self.socket_:connect(self.host_, self.port_, self.secure_)\n\011\011\011if ok then\n\011\011\011\011break\n\011\011\011elseif err == \"timeout\" then\n\011\011\011\011coroutine.yield()\n\011\011\011else\n\011\011\011\011local errl = err:lower()\n\011\011\011\011if errl:find(\"schannel\") or errl:find(\"ssl\") then\n\011\011\011\011\011self.server_probably_secure_ = true\n\011\011\011\011end\n\011\011\011\011self:proto_close_(err)\n\011\011\011end\n\011\011end\n\011\011self.connected_ = true\n\011end\n\011\n\011function client_i:handshake_()\n\011\011self.window_:set_subtitle(\"status\", \"Registering\")\n\011\011local uid, sess, name = util.get_user()\n\011\011self:write_bytes_(tpt.version.major, tpt.version.minor, config.version)\n\011\011self:write_nullstr_((name or tpt.get_name() or \"\"):sub(1, 255))\n\011\011self:write_bytes_(0) -- * Flags, currently unused.\n\011\011local qa_host, qa_port, qa_uid, qa_token = self.get_qa_func_():match(\"^([^:]+):([^:]+):([^:]+):([^:]+)$\")\n\011\011self:write_str8_(qa_token and qa_uid == uid and qa_host == self.host_ and tonumber(qa_port) == self.port_ and qa_token or \"\")\n\011\011self:write_str8_(self.initial_room_ or \"\")\n\011\011self:write_flush_()\n\011\011local conn_status = self:read_bytes_(1)\n\011\011local auth_err\n\011\011if conn_status == 4 then -- * Quickauth failed.\n\011\011\011self.window_:set_subtitle(\"status\", \"Authenticating\")\n\011\011\011local token, err, info = get_auth_token(uid, sess, self.host_ .. \":\" .. self.port_)\n\011\011\011if not token then\n\011\011\011\011if err == \"non200\" then\n\011\011\011\011\011auth_err = \"authentication failed (status code \" .. info .. \"); try again later or try restarting TPT\"\n\011\011\011\011elseif err == \"timeout\" then\n\011\011\011\011\011auth_err = \"authentication failed (timeout: \" .. info .. \"); try again later or try restarting TPT\"\n\011\011\011\011else\n\011\011\011\011\011auth_err = \"authentication failed (\" .. err .. \": \" .. info .. \"); try logging out and back in and restarting TPT\"\n\011\011\011\011end\n\011\011\011\011token = \"\"\n\011\011\011end\n\011\011\011self:write_str8_(token)\n\011\011\011self:write_flush_()\n\011\011\011conn_status = self:read_bytes_(1)\n\011\011\011if uid then\n\011\011\011\011self.set_qa_func_((conn_status == 1) and (self.host_ .. \":\" .. self.port_ .. \":\" .. uid .. \":\" .. token) or \"\")\n\011\011\011end\n\011\011end\n\011\011if conn_status == 1 then\n\011\011\011self.should_reconnect_func_()\n\011\011\011self.registered_ = true\n\011\011\011self.nick_ = self:read_str8_()\n\011\011\011self:reformat_nicks_()\n\011\011\011self.flags_ = self:read_bytes_(1)\n\011\011\011self.guest_ = bit.band(self.flags_, 1) ~= 0\n\011\011\011self.last_ping_sent_at_ = socket.gettime()\n\011\011\011self.connecting_since_ = nil\n\011\011\011if tpt.get_name() and auth_err then\n\011\011\011\011self.window_:backlog_push_error(\"Warning: \" .. auth_err)\n\011\011\011end\n\011\011\011self.window_:backlog_push_registered(self.formatted_nick_)\n\011\011\011self.profile_:set_client(self)\n\011\011elseif conn_status == 0 then\n\011\011\011local reason = self:read_nullstr_(255)\n\011\011\011self:proto_close_(auth_err or reason)\n\011\011else\n\011\011\011self:proto_error_(\"invalid connection status (%i)\", conn_status)\n\011\011end\n\011end\n\011\n\011function client_i:send_ping()\n\011\011self:write_flush_(\"\\3\")\n\011end\n\011\n\011function client_i:send_say(str)\n\011\011self:write_(\"\\19\")\n\011\011self:write_str8_(str)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_say3rd(str)\n\011\011self:write_(\"\\20\")\n\011\011self:write_str8_(str)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_mousepos(px, py)\n\011\011self:write_(\"\\32\")\n\011\011self:write_xy_12_(px, py)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_brushmode(bmode)\n\011\011self:write_(\"\\33\")\n\011\011self:write_bytes_(bmode)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_brushsize(sx, sy)\n\011\011self:write_(\"\\34\")\n\011\011self:write_bytes_(sx, sy)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_brushshape(shape)\n\011\011self:write_(\"\\35\")\n\011\011self:write_bytes_(shape)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_keybdmod(c, s, a)\n\011\011self:write_(\"\\36\")\n\011\011self:write_bytes_(bit.bor(c and 1 or 0, s and 2 or 0, a and 4 or 0))\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_selecttool(idx, xtype)\n\011\011self:write_(\"\\37\")\n\011\011local tool = bit.bor(xtype, bit.lshift(idx, 14))\n\011\011local hi = bit.band(bit.rshift(tool, 8), 0xFF)\n\011\011local lo = bit.band(           tool    , 0xFF)\n\011\011self:write_bytes_(hi, lo)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_simstate(ss_p, ss_h, ss_u, ss_n, ss_w, ss_g, ss_a, ss_e, ss_y, ss_t)\n\011\011self:write_(\"\\38\")\n\011\011local toggles = bit.bor(\n\011\011\011           ss_p    ,\n\011\011\011bit.lshift(ss_h, 1),\n\011\011\011bit.lshift(ss_u, 2),\n\011\011\011bit.lshift(ss_n, 3),\n\011\011\011bit.lshift(ss_w, 4),\n\011\011\011bit.lshift(ss_y, 5)\n\011\011)\n\011\011local multis = bit.bor(\n\011\011\011           ss_g    ,\n\011\011\011bit.lshift(ss_a, 2),\n\011\011\011bit.lshift(ss_e, 5)\n\011\011)\n\011\011self:write_bytes_(toggles, multis)\n\011\011self:write_24be_(ss_t)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_flood(index, x, y)\n\011\011self:write_(\"\\39\")\n\011\011self:write_bytes_(index)\n\011\011self:write_xy_12_(x, y)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_lineend(x, y)\n\011\011self:write_(\"\\40\")\n\011\011self:write_xy_12_(x, y)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_rectend(x, y)\n\011\011self:write_(\"\\41\")\n\011\011self:write_xy_12_(x, y)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_pointsstart(index, x, y)\n\011\011self:write_(\"\\42\")\n\011\011self:write_bytes_(index)\n\011\011self:write_xy_12_(x, y)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_pointscont(x, y)\n\011\011self:write_(\"\\43\")\n\011\011self:write_xy_12_(x, y)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_linestart(index, x, y)\n\011\011self:write_(\"\\44\")\n\011\011self:write_bytes_(index)\n\011\011self:write_xy_12_(x, y)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_rectstart(index, x, y)\n\011\011self:write_(\"\\45\")\n\011\011self:write_bytes_(index)\n\011\011self:write_xy_12_(x, y)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_custgolinfo(ruleset, primary, secondary)\n\011\011self:write_(\"\\46\")\n\011\011self:write_24be_(ruleset)\n\011\011self:write_24be_(primary)\n\011\011self:write_24be_(secondary)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_stepsim()\n\011\011self:write_flush_(\"\\50\")\n\011end\n\011\n\011function client_i:send_sparkclear()\n\011\011self:write_flush_(\"\\60\")\n\011end\n\011\n\011function client_i:send_airclear()\n\011\011self:write_flush_(\"\\61\")\n\011end\n\011\n\011function client_i:send_airinv()\n\011\011self:write_flush_(\"\\62\")\n\011end\n\011\n\011function client_i:send_clearsim()\n\011\011self:write_flush_(\"\\63\")\n\011end\n\011\n\011function client_i:send_heatclear()\n\011\011self:write_flush_(\"\\64\")\n\011end\n\011\n\011function client_i:send_brushdeco(deco)\n\011\011self:write_(\"\\65\")\n\011\011self:write_bytes_(\n\011\011\011bit.band(bit.rshift(deco, 24), 0xFF),\n\011\011\011bit.band(bit.rshift(deco, 16), 0xFF),\n\011\011\011bit.band(bit.rshift(deco,  8), 0xFF),\n\011\011\011bit.band(           deco     , 0xFF)\n\011\011)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_clearrect(x, y, w, h)\n\011\011self:write_(\"\\67\")\n\011\011self:write_xy_12_(x, y)\n\011\011self:write_xy_12_(w, h)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_canceldraw()\n\011\011self:write_flush_(\"\\68\")\n\011end\n\011\n\011function client_i:send_loadonline(id, hist)\n\011\011self:write_(\"\\69\")\n\011\011self:write_24be_(id)\n\011\011self:write_24be_(math.floor(hist / 0x1000000))\n\011\011self:write_24be_(           hist % 0x1000000 )\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_pastestamp_data_(pid, x, y, w, h)\n\011\011local data, err = util.stamp_save(x, y, w, h)\n\011\011if not data then\n\011\011\011return nil, err\n\011\011end\n\011\011self:write_(pid)\n\011\011self:write_xy_12_(x, y)\n\011\011self:write_str24_(data)\n\011\011self:write_flush_()\n\011\011return true\n\011end\n\011\n\011function client_i:send_pastestamp(x, y, w, h)\n\011\011local ok, err = self:send_pastestamp_data_(\"\\31\", x, y, w, h)\n\011\011if not ok then\n\011\011\011self.log_event_func_(colours.commonstr.error .. \"Failed to send stamp: \" .. err)\n\011\011end\n\011end\n\011\n\011function client_i:send_sync()\n\011\011local ok, err = self:send_pastestamp_data_(\"\\30\", 0, 0, sim.XRES, sim.YRES)\n\011\011if not ok then\n\011\011\011self.log_event_func_(colours.commonstr.error .. \"Failed to send screen: \" .. err)\n\011\011end\n\011end\n\011\n\011function client_i:send_reloadsim()\n\011\011self:write_flush_(\"\\70\")\n\011end\n\011\n\011function client_i:send_placestatus(k, w, h)\n\011\011self:write_(\"\\71\")\n\011\011self:write_bytes_(k)\n\011\011self:write_xy_12_(w, h)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_selectstatus(k, x, y)\n\011\011self:write_(\"\\72\")\n\011\011self:write_bytes_(k)\n\011\011self:write_xy_12_(x, y)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_zoomstart(x, y, s)\n\011\011self:write_(\"\\73\")\n\011\011self:write_xy_12_(x, y)\n\011\011self:write_bytes_(s)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_zoomend()\n\011\011self:write_flush_(\"\\74\")\n\011end\n\011\n\011function client_i:send_sparksign(x, y)\n\011\011self:write_(\"\\75\")\n\011\011self:write_xy_12_(x, y)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_fpssync(elapsed, count)\n\011\011self:write_(\"\\76\")\n\011\011self:write_24be_(math.floor(elapsed / 0x1000))\n\011\011self:write_24be_(elapsed % 0x1000 * 0x1000 + math.floor(count / 0x1000000))\n\011\011self:write_24be_(count % 0x1000000)\n\011\011self:write_flush_()\n\011end\n\011\n\011function client_i:send_sync_done()\n\011\011self:write_flush_(\"\\128\")\n\011\011local id, hist = self.get_id_func_()\n\011\011self:send_loadonline(id or 0, hist or 0)\n\011\011self:send_sync()\n\011\011self.profile_:simstate_sync()\n\011end\n\011\n\011function client_i:start()\n\011\011assert(self.status_ == \"ready\")\n\011\011self.status_ = \"running\"\n\011\011self.proto_coro_ = coroutine.create(function()\n\011\011\011local wrap_traceback = can_yield_xpcall and xpcall or function(func)\n\011\011\011\011-- * It doesn't matter if wrap_traceback is not a real xpcall\n\011\011\011\011--   as the error would be re-thrown later anyway, but a real\n\011\011\011\011--   xpcall is preferable because it lets us print a stack trace\n\011\011\011\011--   from within the coroutine.\n\011\011\011\011func()\n\011\011\011\011return true\n\011\011\011end\n\011\011\011local ok, err = wrap_traceback(function()\n\011\011\011\011self:connect_()\n\011\011\011\011self:handshake_()\n\011\011\011\011while true do\n\011\011\011\011\011local packet_id = self:read_bytes_(1)\n\011\011\011\011\011local handler = packet_handlers[packet_id]\n\011\011\011\011\011if not handler then\n\011\011\011\011\011\011self:proto_error_(\"invalid packet ID (%i)\", packet_id)\n\011\011\011\011\011end\n\011\011\011\011\011handler(self)\n\011\011\011\011end\n\011\011\011end, function(err)\n\011\011\011\011print(debug.traceback(err, 2))\n\011\011\011end)\n\011\011\011if not ok then\n\011\011\011\011error(err)\n\011\011\011end\n\011\011end)\n\011end\n\011\n\011function client_i:tick_read_()\n\011\011if self.connected_ and not self.read_closed_ then\n\011\011\011while true do\n\011\011\011\011local closed = false\n\011\011\011\011local data, err, partial = self.socket_:receive(config.read_size)\n\011\011\011\011if not data then\n\011\011\011\011\011if err == \"closed\" then\n\011\011\011\011\011\011data = partial\n\011\011\011\011\011\011closed = true\n\011\011\011\011\011elseif err == \"timeout\" then\n\011\011\011\011\011\011data = partial\n\011\011\011\011\011else\n\011\011\011\011\011\011self:stop(err)\n\011\011\011\011\011\011break\n\011\011\011\011\011end\n\011\011\011\011end\n\011\011\011\011local pushed, count = self.rx_:push(data)\n\011\011\011\011if pushed < count then\n\011\011\011\011\011self:stop(\"recv queue limit exceeded\")\n\011\011\011\011\011break\n\011\011\011\011end\n\011\011\011\011if closed then\n\011\011\011\011\011self:tick_resume_()\n\011\011\011\011\011self:stop(\"connection closed: receive failed: \" .. tostring(self.socket_lasterror_))\n\011\011\011\011\011break\n\011\011\011\011end\n\011\011\011\011if #data < config.read_size then\n\011\011\011\011\011break\n\011\011\011\011end\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function client_i:tick_resume_()\n\011\011if self.proto_coro_ then\n\011\011\011local ok, err = coroutine.resume(self.proto_coro_)\n\011\011\011if not ok then\n\011\011\011\011self.proto_coro_ = nil\n\011\011\011\011error(err)\n\011\011\011end\n\011\011\011if self.proto_coro_ and coroutine.status(self.proto_coro_) == \"dead\" then\n\011\011\011\011error(\"proto coroutine terminated\")\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function client_i:tick_write_()\n\011\011if self.connected_ then\n\011\011\011while true do\n\011\011\011\011local data, first, last = self.tx_:next()\n\011\011\011\011if not data then\n\011\011\011\011\011break\n\011\011\011\011end\n\011\011\011\011local closed = false\n\011\011\011\011local count = last - first + 1\n\011\011\011\011if self.socket_:status() ~= \"connected\" then\n\011\011\011\011\011break\n\011\011\011\011end\n\011\011\011\011local written_up_to, err, partial_up_to = self.socket_:send(data, first, last)\n\011\011\011\011if not written_up_to then\n\011\011\011\011\011if err == \"closed\" then\n\011\011\011\011\011\011written_up_to = partial_up_to\n\011\011\011\011\011\011closed = true\n\011\011\011\011\011elseif err == \"timeout\" then\n\011\011\011\011\011\011written_up_to = partial_up_to\n\011\011\011\011\011else\n\011\011\011\011\011\011self:stop(err)\n\011\011\011\011\011\011break\n\011\011\011\011\011end\n\011\011\011\011end\n\011\011\011\011local written = written_up_to - first + 1\n\011\011\011\011self.tx_:pop(written)\n\011\011\011\011if closed then\n\011\011\011\011\011self.socket_lasterror_ = self.socket_:lasterror()\n\011\011\011\011\011self:stop(\"connection closed: send failed: \" .. tostring(self.socket_lasterror_))\n\011\011\011\011\011break\n\011\011\011\011end\n\011\011\011\011if written < count then\n\011\011\011\011\011break\n\011\011\011\011end\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function client_i:tick_connect_()\n\011\011if self.socket_ then\n\011\011\011if self.connecting_since_ and self.connecting_since_ + config.connect_timeout < socket.gettime() then\n\011\011\011\011self:stop(\"connect timeout\")\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function client_i:tick_ping_()\n\011\011if self.registered_ then\n\011\011\011local now = socket.gettime()\n\011\011\011if self.last_ping_sent_at_ + config.ping_interval < now then\n\011\011\011\011self:send_ping()\n\011\011\011\011self.last_ping_sent_at_ = now\n\011\011\011end\n\011\011\011if self.last_ping_received_at_ + config.ping_timeout < now then\n\011\011\011\011self:stop(\"ping timeout\")\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function client_i:tick_sim_()\n\011\011for _, member in pairs(self.id_to_member) do\n\011\011\011if member:can_render() then\n\011\011\011\011local lx, ly = member.line_x, member.line_y\n\011\011\011\011if member.last_tool == util.from_tool.DEFAULT_UI_WIND and not (member.select or member.place) and lx then\n\011\011\011\011\011local px, py = member.pos_x, member.pos_y\n\011\011\011\011\011if member.kmod_a then\n\011\011\011\011\011\011px, py = util.line_snap_coords(lx, ly, px, py)\n\011\011\011\011\011end\n\011\011\011\011\011util.create_line_any(lx, ly, px, py, member.size_x, member.size_y, member.last_tool, member.shape, member, false)\n\011\011\011\011end\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function client_i:fps_sync_end_(member)\n\011\011if self.fps_sync_ then\n\011\011\011self.window_:backlog_push_fpssync_disable(member.formatted_nick)\n\011\011end\n\011\011member.fps_sync = false\n\011end\n\011\n\011function client_i:tick_fpssync_invalidate_()\n\011\011if self.registered_ then\n\011\011\011local now_msec = get_msec()\n\011\011\011for _, member in pairs(self.id_to_member) do\n\011\011\011\011if member.fps_sync then\n\011\011\011\011\011if member.fps_sync_last + config.fps_sync_timeout < now_msec then\n\011\011\011\011\011\011self:fps_sync_end_(member)\n\011\011\011\011\011end\n\011\011\011\011end\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function client_i:tick_fpssync_()\n\011\011if self.registered_ then\n\011\011\011if self.fps_sync_ then\n\011\011\011\011local now_msec = get_msec()\n\011\011\011\011if not self.fps_sync_first_ then\n\011\011\011\011\011self.fps_sync_first_ = now_msec\n\011\011\011\011\011self.fps_sync_last_ = 0\n\011\011\011\011\011self.fps_sync_count_ = 0\n\011\011\011\011\011for _, member in pairs(self.id_to_member) do\n\011\011\011\011\011\011if member.fps_sync then\n\011\011\011\011\011\011\011member.fps_sync_count_offset = member.fps_sync_count\n\011\011\011\011\011\011end\n\011\011\011\011\011end\n\011\011\011\011end\n\011\011\011\011self.fps_sync_count_ = self.fps_sync_count_ + 1\n\011\011\011\011if now_msec >= self.fps_sync_last_ + 1000 then\n\011\011\011\011\011self:send_fpssync(now_msec - self.fps_sync_first_, self.fps_sync_count_)\n\011\011\011\011\011self.fps_sync_last_ = now_msec\n\011\011\011\011end\n\011\011\011\011local target_fps = self.fps_sync_target_\011\011\011\n\011\011\011\011local smallest_target = self.fps_sync_count_ + math.floor(target_fps * config.fps_sync_plan_ahead_by / 1000)\n\011\011\011\011if self.fps_sync_target_ == 2 then\n\011\011\011\011\011smallest_target = math.huge\n\011\011\011\011end\n\011\011\011\011for _, member in pairs(self.id_to_member) do\n\011\011\011\011\011if member.fps_sync and #member.fps_sync_history >= 2 then\n\011\011\011\011\011\011local diff_count = member.fps_sync_history[1].count - member.fps_sync_history[2].count\n\011\011\011\011\011\011local diff_elapsed = member.fps_sync_history[1].elapsed - member.fps_sync_history[2].elapsed\n\011\011\011\011\011\011local slope = diff_count / (diff_elapsed / 1000)\n\011\011\011\011\011\011if slope <     5 then slope =     5 end\n\011\011\011\011\011\011if slope > 10000 then slope = 10000 end\n\011\011\011\011\011\011local current_msec = now_msec - member.fps_sync_history[1].now_msec\n\011\011\011\011\011\011local current_frames_remote = math.floor(member.fps_sync_history[1].count + slope * (current_msec / 1000))\n\011\011\011\011\011\011local current_frames_local = current_frames_remote - member.fps_sync_count_offset\n\011\011\011\011\011\011local target_msec = now_msec - member.fps_sync_history[1].now_msec + config.fps_sync_plan_ahead_by\n\011\011\011\011\011\011local target_frames_remote = math.floor(member.fps_sync_history[1].count + slope * (target_msec / 1000))\n\011\011\011\011\011\011local target_frames_local = target_frames_remote - member.fps_sync_count_offset\n\011\011\011\011\011\011member.fps_sync_count_diff = current_frames_local - self.fps_sync_count_\n\011\011\011\011\011\011if smallest_target > target_frames_local then\n\011\011\011\011\011\011\011smallest_target = target_frames_local\n\011\011\011\011\011\011end\n\011\011\011\011\011end\n\011\011\011\011end\n\011\011\011\011if smallest_target == math.huge then\n\011\011\011\011\011tpt.setfpscap(2)\n\011\011\011\011else\n\011\011\011\011\011local smallest_fps = (smallest_target - self.fps_sync_count_) / (config.fps_sync_plan_ahead_by / 1000)\n\011\011\011\011\011local fps = math.floor((target_fps + (smallest_fps - target_fps) * config.fps_sync_homing_factor) + 0.5)\n\011\011\011\011\011if fps < 10 then fps = 10 end\n\011\011\011\011\011tpt.setfpscap(fps)\n\011\011\011\011end\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function client_i:tick()\n\011\011if self.status_ ~= \"running\" then\n\011\011\011return\n\011\011end\n\011\011self:tick_fpssync_invalidate_()\n\011\011self:tick_read_()\n\011\011self:tick_resume_()\n\011\011self:tick_write_()\n\011\011self:tick_connect_()\n\011\011self:tick_ping_()\n\011\011self:tick_sim_()\n\011\011self:tick_fpssync_()\n\011end\n\011\n\011function client_i:stop(message)\n\011\011if self.status_ == \"dead\" then\n\011\011\011return\n\011\011end\n\011\011self.profile_:clear_client()\n\011\011if self.socket_ then\n\011\011\011if self.connected_ then\n\011\011\011\011self.socket_:shutdown()\n\011\011\011end\n\011\011\011self.socket_:close()\n\011\011\011self.socket_lasterror_ = self.socket_:lasterror()\n\011\011\011self.socket_ = nil\n\011\011\011self.connected_ = nil\n\011\011\011self.registered_ = nil\n\011\011end\n\011\011self.proto_coro_ = nil\n\011\011self.status_ = \"dead\"\n\011\011local disconnected = \"Disconnected\"\n\011\011if message then\n\011\011\011disconnected = disconnected .. \": \" .. message\n\011\011end\n\011\011self.window_:backlog_push_error(disconnected)\n\011\011if self.server_probably_secure_ then\n\011\011\011self.window_:backlog_push_error((\"The server probably does not support secure connections, try /connect %s:%i\"):format(self.host_, self.port_))\n\011\011end\n\011end\n\011\n\011function client_i:write_(data)\n\011\011if not self.write_buf_ then\n\011\011\011self.write_buf_ = data\n\011\011elseif type(self.write_buf_) == \"string\" then\n\011\011\011self.write_buf_ = { self.write_buf_, data }\n\011\011else\n\011\011\011table.insert(self.write_buf_, data)\n\011\011end\n\011end\n\011\n\011function client_i:write_flush_(data)\n\011\011if data then\n\011\011\011self:write_(data)\n\011\011end\n\011\011local buf = self.write_buf_\n\011\011self.write_buf_ = nil\n\011\011local pushed, count = self.tx_:push(type(buf) == \"string\" and buf or table.concat(buf))\n\011\011if pushed < count then\n\011\011\011self:stop(\"send queue limit exceeded\")\n\011\011end\n\011end\n\011\n\011function client_i:write_bytes_(...)\n\011\011self:write_(string.char(...))\n\011end\n\011\n\011function client_i:write_str24_(str)\n\011\011local length = math.min(#str, 0xFFFFFF)\n\011\011self:write_24be_(length)\n\011\011self:write_(str:sub(1, length))\n\011end\n\011\n\011function client_i:write_str8_(str)\n\011\011local length = math.min(#str, 0xFF)\n\011\011self:write_bytes_(length)\n\011\011self:write_(str:sub(1, length))\n\011end\n\011\n\011function client_i:write_nullstr_(str)\n\011\011self:write_(str:gsub(\"[^\\1-\\255]\", \"\"))\n\011\011self:write_(\"\\0\")\n\011end\n\011\n\011function client_i:write_24be_(d24)\n\011\011local hi = bit.band(bit.rshift(d24, 16), 0xFF)\n\011\011local mi = bit.band(bit.rshift(d24,  8), 0xFF)\n\011\011local lo = bit.band(           d24     , 0xFF)\n\011\011self:write_bytes_(hi, mi, lo)\n\011end\n\011\n\011function client_i:write_xy_12_(x, y)\n\011\011self:write_24be_(bit.bor(bit.lshift(x, 12), y))\n\011end\n\011\n\011function client_i:nick()\n\011\011return self.nick_\n\011end\n\011\n\011function client_i:formatted_nick()\n\011\011return self.formatted_nick_\n\011end\n\011\n\011function client_i:status()\n\011\011return self.status_\n\011end\n\011\n\011function client_i:connected()\n\011\011return self.connected_\n\011end\n\011\n\011function client_i:registered()\n\011\011return self.registered_\n\011end\n\011\n\011function client_i:nick_colour_seed(seed)\n\011\011self.nick_colour_seed_ = seed\n\011\011self:reformat_nicks_()\n\011end\n\011\n\011function client_i:fps_sync(fps_sync)\n\011\011if self.fps_sync_ and not fps_sync then\n\011\011\011tpt.setfpscap(self.fps_sync_target_)\n\011\011end\n\011\011if not self.fps_sync_ and fps_sync then\n\011\011\011self.fps_sync_first_ = nil\n\011\011end\n\011\011self.fps_sync_ = fps_sync and true or false\n\011\011self.fps_sync_target_ = fps_sync or false\n\011end\n\011\n\011function client_i:reformat_nicks_()\n\011\011if self.nick_ then\n\011\011\011self.formatted_nick_ = format.nick(self.nick_, self.nick_colour_seed_)\n\011\011end\n\011\011for _, member in pairs(self.id_to_member) do\n\011\011\011member.formatted_nick = format.nick(member.nick, self.nick_colour_seed_)\n\011\011end\n\011end\n\011\n\011for key, value in pairs(client_i) do\n\011\011local packet_id_str = key:match(\"^handle_.+_(%d+)_$\")\n\011\011if packet_id_str then\n\011\011\011local packet_id = tonumber(packet_id_str)\n\011\011\011assert(not packet_handlers[packet_id])\n\011\011\011packet_handlers[packet_id] = value\n\011\011end\n\011end\n\011\n\011local function new(params)\n\011\011local now = socket.gettime()\n\011\011return setmetatable({\n\011\011\011host_ = params.host,\n\011\011\011port_ = params.port,\n\011\011\011secure_ = params.secure,\n\011\011\011event_log_ = params.event_log,\n\011\011\011backlog_ = params.backlog,\n\011\011\011rx_ = buffer_list.new({ limit = config.recvq_limit }),\n\011\011\011tx_ = buffer_list.new({ limit = config.sendq_limit }),\n\011\011\011connecting_since_ = now,\n\011\011\011last_ping_sent_at_ = now,\n\011\011\011last_ping_received_at_ = now,\n\011\011\011status_ = \"ready\",\n\011\011\011window_ = params.window,\n\011\011\011profile_ = params.profile,\n\011\011\011localcmd_ = params.localcmd,\n\011\011\011initial_room_ = params.initial_room,\n\011\011\011set_id_func_ = params.set_id_func,\n\011\011\011get_id_func_ = params.get_id_func,\n\011\011\011set_qa_func_ = params.set_qa_func,\n\011\011\011get_qa_func_ = params.get_qa_func,\n\011\011\011log_event_func_ = params.log_event_func,\n\011\011\011should_reconnect_func_ = params.should_reconnect_func,\n\011\011\011should_not_reconnect_func_ = params.should_not_reconnect_func,\n\011\011\011id_to_member = {},\n\011\011\011nick_colour_seed_ = 0,\n\011\011\011fps_sync_ = false,\n\011\011}, client_m)\n\011end\n\011\n\011return {\n\011\011new = new,\n\011}\n\011\nend\n\nrequire_preload__[\"tptmp.client.colours\"] = function()\n\n\011local utf8 = require(\"tptmp.client.utf8\")\n\011\n\011local function hsv_to_rgb(hue, saturation, value) -- * [0, 1), [0, 1), [0, 1)\n\011\011local sector = math.floor(hue * 6)\n\011\011local offset = hue * 6 - sector\n\011\011local red, green, blue\n\011\011if sector == 0 then\n\011\011\011red, green, blue = 1, offset, 0\n\011\011elseif sector == 1 then\n\011\011\011red, green, blue = 1 - offset, 1, 0\n\011\011elseif sector == 2 then\n\011\011\011red, green, blue = 0, 1, offset\n\011\011elseif sector == 3 then\n\011\011\011red, green, blue = 0, 1 - offset, 1\n\011\011elseif sector == 4 then\n\011\011\011red, green, blue = offset, 0, 1\n\011\011else\n\011\011\011red, green, blue = 1, 0, 1 - offset\n\011\011end\n\011\011return {\n\011\011\011math.floor((saturation * (red   - 1) + 1) * 0xFF * value),\n\011\011\011math.floor((saturation * (green - 1) + 1) * 0xFF * value),\n\011\011\011math.floor((saturation * (blue  - 1) + 1) * 0xFF * value),\n\011\011}\n\011end\n\011\n\011local function escape(rgb)\n\011\011-- * TODO[api]: Fix this TPT bug: most strings are still passed to/from Lua as zero-terminated, hence the math.max.\n\011\011return utf8.encode_multiple(15, math.max(rgb[1], 1), math.max(rgb[2], 1), math.max(rgb[3], 1))\n\011end\n\011\n\011local common = {}\n\011local commonstr = {}\n\011for key, value in pairs({\n\011\011brush           = {   0, 255,   0 },\n\011\011chat            = { 255, 255, 255 },\n\011\011error           = { 255,  50,  50 },\n\011\011event           = { 255, 255, 255 },\n\011\011join            = { 100, 255, 100 },\n\011\011leave           = { 255, 255, 100 },\n\011\011fpssyncenable   = { 255, 100, 255 },\n\011\011fpssyncdisable  = { 130, 130, 255 },\n\011\011lobby           = {   0, 200, 200 },\n\011\011neutral         = { 200, 200, 200 },\n\011\011room            = { 200, 200,   0 },\n\011\011status          = { 150, 150, 150 },\n\011\011notif_normal    = { 100, 100, 100 },\n\011\011notif_important = { 255,  50,  50 },\n\011\011player_cursor   = {   0, 255,   0, 128 },\n\011}) do\n\011\011common[key] = value\n\011\011commonstr[key] = escape(value)\n\011end\n\011\n\011local appearance = {\n\011\011hover = {\n\011\011\011background = {  20,  20,  20 },\n\011\011\011text       = { 255, 255, 255 },\n\011\011\011border     = { 255, 255, 255 },\n\011\011},\n\011\011inactive = {\n\011\011\011background = {   0,   0,   0 },\n\011\011\011text       = { 255, 255, 255 },\n\011\011\011border     = { 200, 200, 200 },\n\011\011},\n\011\011active = {\n\011\011\011background = { 255, 255, 255 },\n\011\011\011text       = {   0,   0,   0 },\n\011\011\011border     = { 235, 235, 235 },\n\011\011},\n\011}\n\011\n\011return {\n\011\011escape = escape,\n\011\011common = common,\n\011\011commonstr = commonstr,\n\011\011hsv_to_rgb = hsv_to_rgb,\n\011\011appearance = appearance,\n\011}\n\011\nend\n\nrequire_preload__[\"tptmp.client.config\"] = function()\n\n\011local common_config = require(\"tptmp.common.config\")\n\011\n\011local versionstr = \"v2.0.22\"\n\011\n\011local config = {\n\011\011-- ***********************************************************************\n\011\011-- *** The following options are purely cosmetic and should be         ***\n\011\011-- *** customised in accordance with your taste.                       ***\n\011\011-- ***********************************************************************\n\011\n\011\011-- * Version string to display in the window title.\n\011\011versionstr = versionstr,\n\011\n\011\011-- * Amount of incoming messages to remember, counted from the\n\011\011--   last one received.\n\011\011backlog_size = 1000,\n\011\n\011\011-- * Amount of outgoing messages to remember, counted from the\n\011\011--   last one sent.\n\011\011history_size = 1000,\n\011\n\011\011-- * Default window width. Overridden by the value loaded from the manager\n\011\011--   backend, if any.\n\011\011default_width = 230,\n\011\n\011\011-- * Default window height. Similar to default_width.\n\011\011default_height = 155,\n\011\n\011\011-- * Default window background alpha. Similar to default_width.\n\011\011default_alpha = 150,\n\011\n\011\011-- * Minimum window width.\n\011\011min_width = 160,\n\011\n\011\011-- * Minimum window height.\n\011\011min_height = 107,\n\011\n\011\011-- * Amount of time in seconds that elapses between a notification bubble\n\011\011--   appearing and settling in its final position.\n\011\011notif_fly_time = 0.1,\n\011\n\011\011-- * Distance in pixels between the position where a notification appears\n\011\011--   and the position where it settles.\n\011\011notif_fly_distance = 3,\n\011\n\011\011-- * Amount of time in seconds that elapses between a message arriving and\n\011\011--   it beginning to fade out if the window is floating.\n\011\011floating_linger_time = 3,\n\011\n\011\011-- * Amount of time in seconds that elapses between a message beginning to\n\011\011--   fade out and disappearing completely if the window is floating.\n\011\011floating_fade_time = 1,\n\011\n\011\011-- * Path to tptmp.client.manager.null configuration file relative to\n\011\011--   current directory. Only relevant if the null manager is active.\n\011\011null_manager_path = \"tptmpsettings.txt\",\n\011\n\011\n\011\011-- ***********************************************************************\n\011\011-- *** The following options should only be changed if you know what   ***\n\011\011-- *** you are doing. This usually involves consulting with the        ***\n\011\011-- *** developers. Otherwise, these are sane values you should trust.  ***\n\011\011-- ***********************************************************************\n\011\n\011\011-- * Specifies whether connections made without specifying the port number\n\011\011--   should be encrypted. Default should match the common setting.\n\011\011default_secure = common_config.secure,\n\011\n\011\011-- * Size of the buffer passed to the recv system call. Bigger values\n\011\011--   consume more memory, smaller ones incur larger system call overhead.\n\011\011read_size = 0x1000000,\n\011\n\011\011-- * Receive queue limit. Specifies the maximum amount of data the server\n\011\011--   is allowed to have sent but which the client has not yet had time to\n\011\011--   process. The connection is closed if the size of the receive queue\n\011\011--   exceeds this limit.\n\011\011recvq_limit = 0x200000,\n\011\n\011\011-- * Send queue limit. Specifies the maximum amount of data the server\n\011\011--   is allowed to have not yet processed but which the client has already\n\011\011--   queued. The connection is closed if the size of the send queue exceeds\n\011\011--   this limit.\n\011\011sendq_limit = 0x2000000,\n\011\n\011\011-- * Maximum amount of time in seconds after which the connection attempt\n\011\011--   should be deemed a failure, unless it succeeds.\n\011\011connect_timeout = 15,\n\011\n\011\011-- * Amount of time in seconds between pings being sent to the server.\n\011\011--   Should be half of the ping_timeout option on the server side or less.\n\011\011ping_interval = 60,\n\011\n\011\011-- * Amount of time in seconds the connection is allowed to be maintained\n\011\011--   without the server sending a ping. Should be twice the ping_interval\n\011\011--   option on the server side or more.\n\011\011ping_timeout = 120,\n\011\n\011\011-- * Amount of time in seconds that elapses between a non-graceful\n\011\011--   connection closure (anything that isn't the client willingly\n\011\011--   disconnecting or the server explicitly dropping the client) and an\n\011\011--   attempt to establish a new connection.\n\011\011reconnect_later_timeout = 2,\n\011\n\011\011-- * Path to the temporary stamp created when syncing.\n\011\011stamp_temp = \".tptmp.stm\",\n\011\n\011\011-- * Pattern used to match word characters by the textbox. Used by cursor\n\011\011--   control, mostly Ctrl+Left and Ctrl+Right and related shortcuts.\n\011\011word_pattern = \"^[A-Za-z0-9-_\\128-\\255]+$\",\n\011\n\011\011-- * Pattern used to match whitespace characters by the textbox. Similar to\n\011\011--   word_pattern.\n\011\011whitespace_pattern = \"^ $\",\n\011\n\011\011-- * Namespace for settings stored in the manager backend.\n\011\011manager_namespace = \"tptmp\",\n\011\n\011\011-- * Grace period in milliseconds after which another client is deemed to\n\011\011--   not have FPS synchronization enabled.\n\011\011fps_sync_timeout = 10000,\n\011\n\011\011-- * Interval to plan ahead in milliseconds, after which local number of\n\011\011--   frames simulated should more or less match the number of frames\n\011\011--   everyone else with FPS synchronization enabled has simulated.\n\011\011fps_sync_plan_ahead_by = 3000,\n\011\n\011\011-- * Coefficient of linear interpolation between the current target FPS and\n\011\011--   that of the slowest client in the room with FPS synchronization\n\011\011--   enabled used when slowing down to match the number of frames simulated\n\011\011--   by this client. 0 means no slowing down at all, 1 means slowing down\n\011\011--   to the framerate the other client seems to be running at.\n\011\011fps_sync_homing_factor = 0.5,\n\011\n\011\n\011\011-- ***********************************************************************\n\011\011-- *** The following options should be changed in                      ***\n\011\011-- *** tptmp/common/config.lua instead. Since these options should     ***\n\011\011-- *** align with the equivalent options on the server side, you       ***\n\011\011-- *** will most likely have to run your own version of the server     ***\n\011\011-- *** if you intend to change these.                                  ***\n\011\011-- ***********************************************************************\n\011\n\011\011-- * Host to connect to by default.\n\011\011default_host = common_config.host,\n\011\n\011\011-- * Port to connect to by default.\n\011\011default_port = common_config.port,\n\011\n\011\011-- * Protocol version.\n\011\011version = common_config.version,\n\011\n\011\011-- * Client-to-server message size limit.\n\011\011message_size = common_config.message_size,\n\011\n\011\011-- * Client-to-server message rate limit.\n\011\011message_interval = common_config.message_interval,\n\011\n\011\011-- * Authentication backend URL. Only relevant if auth = true on the\n\011\011--   server side.\n\011\011auth_backend = common_config.auth_backend,\n\011\n\011\011-- * Authentication backend timeout in seconds. Only relevant if\n\011\011---  auth = true on the server side.\n\011\011auth_backend_timeout = common_config.auth_backend_timeout,\n\011}\n\011config.default_x = math.floor((sim.XRES - config.default_width) / 2)\n\011config.default_y = math.floor((sim.YRES - config.default_height) / 2)\n\011\n\011return config\n\011\nend\n\nrequire_preload__[\"tptmp.client.format\"] = function()\n\n\011local colours = require(\"tptmp.client.colours\")\n\011local util    = require(\"tptmp.client.util\")\n\011\n\011local function nick(unformatted, seed)\n\011\011return colours.escape(colours.hsv_to_rgb(util.fnv1a32(seed .. unformatted .. \"bagels\") / 0x100000000, 0.5, 1)) .. unformatted\n\011end\n\011\n\011local names = {\n\011\011[   \"null\" ] = \"main lobby\",\n\011\011[  \"guest\" ] = \"guest lobby\",\n\011\011[ \"kicked\" ] = \"kicked lobby\",\n\011}\n\011\n\011local function room(unformatted)\n\011\011local name = names[unformatted]\n\011\011return name and (colours.commonstr.lobby .. name) or (colours.commonstr.room .. unformatted)\n\011end\n\011\n\011local function troom(unformatted)\n\011\011local name = names[unformatted]\n\011\011return name and (colours.commonstr.lobby .. name) or (\"room \" .. colours.commonstr.room .. unformatted)\n\011end\n\011\n\011return {\n\011\011nick = nick,\n\011\011room = room,\n\011\011troom = troom,\n\011}\n\011\nend\n\nrequire_preload__[\"tptmp.client.localcmd\"] = function()\n\n\011local config         = require(\"tptmp.client.config\")\n\011local format         = require(\"tptmp.client.format\")\n\011local manager        = require(\"tptmp.client.manager\")\n\011local command_parser = require(\"tptmp.common.command_parser\")\n\011local colours        = require(\"tptmp.client.colours\")\n\011\n\011local localcmd_i = {}\n\011local localcmd_m = { __index = localcmd_i }\n\011\n\011local function parse_fps_sync(fps_sync)\n\011\011fps_sync = fps_sync and tonumber(fps_sync) or false\n\011\011fps_sync = fps_sync and math.floor(fps_sync) or false\n\011\011fps_sync = fps_sync and fps_sync >= 2 and fps_sync or false\n\011\011return fps_sync\n\011end\n\011\n\011local cmdp = command_parser.new({\n\011\011commands = {\n\011\011\011help = {\n\011\011\011\011role = \"help\",\n\011\011\011\011help = \"/help <command>: displays command usage and notes (try /help list)\",\n\011\011\011},\n\011\011\011list = {\n\011\011\011\011role = \"list\",\n\011\011\011\011help = \"/list, no arguments: lists available commands\",\n\011\011\011},\n\011\011\011size = {\n\011\011\011\011func = function(localcmd, message, words, offsets)\n\011\011\011\011\011local width = tonumber(words[2] and #words[2] > 0 and #words[2] <= 7 and not words[2]:find(\"[^0-9]\") and words[2] or \"\")\n\011\011\011\011\011local height = tonumber(words[3] and #words[3] > 0 and #words[3] <= 7 and not words[3]:find(\"[^0-9]\") and words[3] or \"\")\n\011\011\011\011\011if not width or not height then\n\011\011\011\011\011\011return false\n\011\011\011\011\011else\n\011\011\011\011\011\011localcmd.window_:set_size(width, height)\n\011\011\011\011\011end\n\011\011\011\011\011return true\n\011\011\011\011end,\n\011\011\011\011help = \"/size <width> <height>: sets the size of the chat window\",\n\011\011\011},\n\011\011\011sync = {\n\011\011\011\011func = function(localcmd, message, words, offsets)\n\011\011\011\011\011local cli = localcmd.client_func_()\n\011\011\011\011\011if cli then\n\011\011\011\011\011\011cli:send_sync()\n\011\011\011\011\011\011if localcmd.window_status_func_() ~= \"hidden\" then\n\011\011\011\011\011\011\011localcmd.window_:backlog_push_neutral(\"* Simulation synchronized\")\n\011\011\011\011\011\011end\n\011\011\011\011\011else\n\011\011\011\011\011\011if localcmd.window_status_func_() ~= \"hidden\" then\n\011\011\011\011\011\011\011localcmd.window_:backlog_push_error(\"Not connected, cannot sync\")\n\011\011\011\011\011\011end\n\011\011\011\011\011end\n\011\011\011\011\011return true\n\011\011\011\011end,\n\011\011\011\011help = \"/sync, no arguments: synchronizes your simulation with everyone else's in the room; shortcut is Alt+S\",\n\011\011\011},\n\011\011\011S = {\n\011\011\011\011alias = \"sync\",\n\011\011\011},\n\011\011\011fpssync = {\n\011\011\011\011func = function(localcmd, message, words, offsets)\n\011\011\011\011\011local cli = localcmd.client_func_()\n\011\011\011\011\011if words[2] == \"on\" then\n\011\011\011\011\011\011if not localcmd.fps_sync_ then\n\011\011\011\011\011\011\011localcmd.fps_sync_ = tpt.setfpscap()\n\011\011\011\011\011\011end\n\011\011\011\011\011\011if words[3] then\n\011\011\011\011\011\011\011local fps_sync = parse_fps_sync(words[3])\n\011\011\011\011\011\011\011if not fps_sync then\n\011\011\011\011\011\011\011\011return false\n\011\011\011\011\011\011\011end\n\011\011\011\011\011\011\011localcmd.fps_sync_ = fps_sync\n\011\011\011\011\011\011end\n\011\011\011\011\011\011manager.set(\"fpsSync\", tostring(localcmd.fps_sync_))\n\011\011\011\011\011\011if cli then\n\011\011\011\011\011\011\011cli:fps_sync(localcmd.fps_sync_)\n\011\011\011\011\011\011end\n\011\011\011\011\011\011localcmd.window_:backlog_push_neutral(\"* FPS synchronization enabled\")\n\011\011\011\011\011\011return true\n\011\011\011\011\011elseif words[2] == \"check\" or not words[2] then\n\011\011\011\011\011\011if localcmd.fps_sync_ then\n\011\011\011\011\011\011\011local cli = localcmd.client_func_()\n\011\011\011\011\011\011\011if cli then\n\011\011\011\011\011\011\011\011cli:push_fpssync()\n\011\011\011\011\011\011\011else\n\011\011\011\011\011\011\011\011localcmd.window_:backlog_push_fpssync(true)\n\011\011\011\011\011\011\011end\n\011\011\011\011\011\011else\n\011\011\011\011\011\011\011localcmd.window_:backlog_push_fpssync(false)\n\011\011\011\011\011\011end\n\011\011\011\011\011\011return true\n\011\011\011\011\011elseif words[2] == \"off\" then\n\011\011\011\011\011\011localcmd.fps_sync_ = false\n\011\011\011\011\011\011manager.set(\"fpsSync\", tostring(localcmd.fps_sync_))\n\011\011\011\011\011\011if cli then\n\011\011\011\011\011\011\011cli:fps_sync(localcmd.fps_sync_)\n\011\011\011\011\011\011end\n\011\011\011\011\011\011localcmd.window_:backlog_push_neutral(\"* FPS synchronization disabled\")\n\011\011\011\011\011\011return true\n\011\011\011\011\011end\n\011\011\011\011\011return false\n\011\011\011\011end,\n\011\011\011\011help = \"/fpssync on [targetfps]\\\\check\\\\off: enables or disables FPS synchronization with those in the room who also have it enabled; targetfps defaults to the current FPS cap\",\n\011\011\011},\n\011\011\011floating = {\n\011\011\011\011func = function(localcmd, message, words, offsets)\n\011\011\011\011\011local cli = localcmd.client_func_()\n\011\011\011\011\011if words[2] == \"on\" then\n\011\011\011\011\011\011localcmd.floating_ = true\n\011\011\011\011\011\011localcmd.window_set_floating_func_(true)\n\011\011\011\011\011\011manager.set(\"floating\", \"on\")\n\011\011\011\011\011\011localcmd.window_:backlog_push_neutral(\"* Floating mode enabled\")\n\011\011\011\011\011\011return true\n\011\011\011\011\011elseif words[2] == \"check\" or not words[2] then\n\011\011\011\011\011\011if localcmd.floating_ then\n\011\011\011\011\011\011\011localcmd.window_:backlog_push_neutral(\"* Floating mode currenly enabled\")\n\011\011\011\011\011\011else\n\011\011\011\011\011\011\011localcmd.window_:backlog_push_neutral(\"* Floating mode currenly disabled\")\n\011\011\011\011\011\011end\n\011\011\011\011\011\011return true\n\011\011\011\011\011elseif words[2] == \"off\" then\n\011\011\011\011\011\011localcmd.floating_ = false\n\011\011\011\011\011\011localcmd.window_set_floating_func_(false)\n\011\011\011\011\011\011manager.set(\"floating\", \"false\")\n\011\011\011\011\011\011localcmd.window_:backlog_push_neutral(\"* Floating mode disabled\")\n\011\011\011\011\011\011return true\n\011\011\011\011\011end\n\011\011\011\011\011return false\n\011\011\011\011end,\n\011\011\011\011help = \"/floating on\\\\check\\\\off: enables or disables floating mode: messages are drawn even when the window is hidden; chat shortcut is T\",\n\011\011\011},\n\011\011\011connect = {\n\011\011\011\011macro = function(localcmd, message, words, offsets)\n\011\011\011\011\011return { \"connectroom\", \"\", unpack(words, 2) }\n\011\011\011\011end,\n\011\011\011\011help = \"/connect [host[:[+]port]]: connects the default TPTMP server or the specified one, add + to connect securely\",\n\011\011\011},\n\011\011\011C = {\n\011\011\011\011alias = \"connect\",\n\011\011\011},\n\011\011\011reconnect = {\n\011\011\011\011macro = function(localcmd, message, words, offsets)\n\011\011\011\011\011if not localcmd.reconnect_ then\n\011\011\011\011\011\011localcmd.window_:backlog_push_error(\"No successful connection on record, cannot reconnect\")\n\011\011\011\011\011\011return {}\n\011\011\011\011\011end\n\011\011\011\011\011return { \"connectroom\", localcmd.reconnect_.room, localcmd.reconnect_.host .. \":\" .. localcmd.reconnect_.secr .. localcmd.reconnect_.port }\n\011\011\011\011end,\n\011\011\011\011help = \"/reconnect, no arguments: connects back to the most recently visited server\",\n\011\011\011},\n\011\011\011connectroom = {\n\011\011\011\011func = function(localcmd, message, words, offsets)\n\011\011\011\011\011local cli = localcmd.client_func_()\n\011\011\011\011\011if not words[2] then\n\011\011\011\011\011\011return false\n\011\011\011\011\011elseif cli then\n\011\011\011\011\011\011localcmd.window_:backlog_push_error(\"Already connected\")\n\011\011\011\011\011else\n\011\011\011\011\011\011local host = words[3] or config.default_host\n\011\011\011\011\011\011local host_without_port, port = host:match(\"^(.+):(%+?[^:]+)$\")\n\011\011\011\011\011\011host = host_without_port or host\n\011\011\011\011\011\011local secure\n\011\011\011\011\011\011if port then\n\011\011\011\011\011\011\011secure = port:find(\"%+\") and true\n\011\011\011\011\011\011else\n\011\011\011\011\011\011\011secure = config.default_secure\n\011\011\011\011\011\011end\n\011\011\011\011\011\011local new_cli = localcmd.new_client_func_({\n\011\011\011\011\011\011\011host = host,\n\011\011\011\011\011\011\011port = port and tonumber(port:gsub(\"[^0-9]\", \"\"):sub(1, 5)) or config.default_port,\n\011\011\011\011\011\011\011secure = secure,\n\011\011\011\011\011\011\011initial_room = words[2],\n\011\011\011\011\011\011\011localcmd = localcmd,\n\011\011\011\011\011\011})\n\011\011\011\011\011\011new_cli:nick_colour_seed(localcmd.nick_colour_seed_)\n\011\011\011\011\011\011new_cli:fps_sync(localcmd.fps_sync_)\n\011\011\011\011\011\011new_cli:start()\n\011\011\011\011\011end\n\011\011\011\011\011return true\n\011\011\011\011end,\n\011\011\011\011help = \"/connectroom <room> [host[:[+]port]]: same as /connect, but skips the lobby and joins the specified room\",\n\011\011\011},\n\011\011\011CR = {\n\011\011\011\011alias = \"connectroom\",\n\011\011\011},\n\011\011\011disconnect = {\n\011\011\011\011func = function(localcmd, message, words, offsets)\n\011\011\011\011\011local cli = localcmd.client_func_()\n\011\011\011\011\011if cli then\n\011\011\011\011\011\011localcmd.kill_client_func_()\n\011\011\011\011\011else\n\011\011\011\011\011\011localcmd.window_:backlog_push_error(\"Not connected, cannot disconnect\")\n\011\011\011\011\011end\n\011\011\011\011\011return true\n\011\011\011\011end,\n\011\011\011\011help = \"/disconnect, no arguments: disconnects from the current server\",\n\011\011\011},\n\011\011\011D = {\n\011\011\011\011alias = \"disconnect\",\n\011\011\011},\n\011\011\011quit = {\n\011\011\011\011alias = \"disconnect\",\n\011\011\011},\n\011\011\011Q = {\n\011\011\011\011alias = \"disconnect\",\n\011\011\011},\n\011\011\011names = {\n\011\011\011\011func = function(localcmd, message, words, offsets)\n\011\011\011\011\011local cli = localcmd.client_func_()\n\011\011\011\011\011if cli then\n\011\011\011\011\011\011cli:push_names(\"Currently in \")\n\011\011\011\011\011else\n\011\011\011\011\011\011localcmd.window_:backlog_push_error(\"Not connected, cannot list users\")\n\011\011\011\011\011end\n\011\011\011\011\011return true\n\011\011\011\011end,\n\011\011\011\011help = \"/names, no arguments: tells you which room you are in and lists users present\",\n\011\011\011},\n\011\011\011clear = {\n\011\011\011\011func = function(localcmd, message, words, offsets)\n\011\011\011\011\011localcmd.window_:backlog_reset()\n\011\011\011\011\011localcmd.window_:backlog_push_neutral(\"* Backlog cleared\")\n\011\011\011\011\011return true\n\011\011\011\011end,\n\011\011\011\011help = \"/clear, no arguments: clears the chat window\",\n\011\011\011},\n\011\011\011hide = {\n\011\011\011\011func = function(localcmd, message, words, offsets)\n\011\011\011\011\011localcmd.window_.hide_window_func_()\n\011\011\011\011\011return true\n\011\011\011\011end,\n\011\011\011\011help = \"/hide, no arguments: hides the chat window; shortcut is Shift+Escape, this toggles window visibility (different from Escape without Shift, which defocuses the input box, and its counterpart Enter, which focuses it)\",\n\011\011\011},\n\011\011\011me = {\n\011\011\011\011func = function(localcmd, message, words, offsets)\n\011\011\011\011\011local cli = localcmd.client_func_()\n\011\011\011\011\011if not words[2] then\n\011\011\011\011\011\011return false\n\011\011\011\011\011elseif cli then\n\011\011\011\011\011\011local msg = message:sub(offsets[2])\n\011\011\011\011\011\011localcmd.window_:backlog_push_say3rd(cli:formatted_nick(), msg)\n\011\011\011\011\011\011cli:send_say3rd(msg)\n\011\011\011\011\011else\n\011\011\011\011\011\011localcmd.window_:backlog_push_error(\"Not connected, message not sent\")\n\011\011\011\011\011end\n\011\011\011\011\011return true\n\011\011\011\011end,\n\011\011\011\011help = \"/me <message>: says something in third person\",\n\011\011\011},\n\011\011\011ncseed = {\n\011\011\011\011func = function(localcmd, message, words, offsets)\n\011\011\011\011\011localcmd.nick_colour_seed_ = words[2] or tostring(math.random())\n\011\011\011\011\011manager.set(\"nickColourSeed\", tostring(localcmd.nick_colour_seed_))\n\011\011\011\011\011local cli = localcmd.client_func_()\n\011\011\011\011\011localcmd.window_:nick_colour_seed(localcmd.nick_colour_seed_)\n\011\011\011\011\011if cli then\n\011\011\011\011\011\011cli:nick_colour_seed(localcmd.nick_colour_seed_)\n\011\011\011\011\011end\n\011\011\011\011\011return true\n\011\011\011\011end,\n\011\011\011\011help = \"/ncseed [seed]: set nick colour seed, randomize it if not specified, default is 0\",\n\011\011\011},\n\011\011},\n\011\011respond = function(localcmd, message)\n\011\011\011localcmd.window_:backlog_push_neutral(message)\n\011\011end,\n\011\011cmd_fallback = function(localcmd, message)\n\011\011\011local cli = localcmd.client_func_()\n\011\011\011if cli then\n\011\011\011\011cli:send_say(\"/\" .. message)\n\011\011\011\011return true\n\011\011\011end\n\011\011\011return false\n\011\011end,\n\011\011help_fallback = function(localcmd, cmdstr)\n\011\011\011local cli = localcmd.client_func_()\n\011\011\011if cli then\n\011\011\011\011cli:send_say(\"/shelp \" .. cmdstr)\n\011\011\011\011return true\n\011\011\011end\n\011\011\011return false\n\011\011end,\n\011\011list_extra = function(localcmd, cmdstr)\n\011\011\011local cli = localcmd.client_func_()\n\011\011\011if cli then\n\011\011\011\011cli:send_say(\"/slist\")\n\011\011\011else\n\011\011\011\011localcmd.window_:backlog_push_neutral(\"* Server commands are not currently available (connect to a server first)\")\n\011\011\011end\n\011\011end,\n\011\011help_format = colours.commonstr.neutral .. \"* %s\",\n\011\011alias_format = colours.commonstr.neutral .. \"* /%s is an alias for /%s\",\n\011\011list_format = colours.commonstr.neutral .. \"* Client commands: %s\",\n\011\011unknown_format = colours.commonstr.error .. \"* No such command, try /list (maybe it is server-only, connect and try again)\",\n\011})\n\011\n\011function localcmd_i:parse(str)\n\011\011if str:find(\"^/\") and not str:find(\"^//\") then\n\011\011\011cmdp:parse(self, str:sub(2))\n\011\011\011return true\n\011\011end\n\011end\n\011\n\011function localcmd_i:reconnect_commit(reconnect)\n\011\011self.reconnect_ = {\n\011\011\011room = reconnect.room,\n\011\011\011host = reconnect.host,\n\011\011\011port = tostring(reconnect.port),\n\011\011\011secr = reconnect.secure and \"+\" or \"\",\n\011\011}\n\011\011manager.set(\"reconnectRoom\", self.reconnect_.room)\n\011\011manager.set(\"reconnectHost\", self.reconnect_.host)\n\011\011manager.set(\"reconnectPort\", self.reconnect_.port)\n\011\011manager.set(\"reconnectSecure\", self.reconnect_.secr)\n\011end\n\011\n\011local function new(params)\n\011\011local reconnect = {\n\011\011\011room = manager.get(\"reconnectRoom\", \"\"),\n\011\011\011host = manager.get(\"reconnectHost\", \"\"),\n\011\011\011port = manager.get(\"reconnectPort\", \"\"),\n\011\011\011secr = manager.get(\"reconnectSecure\", \"\"),\n\011\011}\n\011\011if #reconnect.room == 0 or #reconnect.host == 0 or #reconnect.port == 0 then\n\011\011\011reconnect = nil\n\011\011end\n\011\011local fps_sync = parse_fps_sync(manager.get(\"fpsSync\", \"0\"))\n\011\011local floating = manager.get(\"floating\", \"off\") == \"on\"\n\011\011local cmd = setmetatable({\n\011\011\011fps_sync_ = fps_sync,\n\011\011\011floating_ = floating,\n\011\011\011reconnect_ = reconnect,\n\011\011\011window_status_func_ = params.window_status_func,\n\011\011\011window_set_floating_func_ = params.window_set_floating_func,\n\011\011\011client_func_ = params.client_func,\n\011\011\011new_client_func_ = params.new_client_func,\n\011\011\011kill_client_func_ = params.kill_client_func,\n\011\011\011nick_colour_seed_ = manager.get(\"nickColourSeed\", \"0\"),\n\011\011\011window_ = params.window,\n\011\011}, localcmd_m)\n\011\011cmd.window_:nick_colour_seed(cmd.nick_colour_seed_)\n\011\011cmd.window_set_floating_func_(floating)\n\011\011return cmd\n\011end\n\011\n\011return {\n\011\011new = new,\n\011}\n\011\nend\n\nrequire_preload__[\"tptmp.client.manager\"] = function()\n\n\011local jacobs = require(\"tptmp.client.manager.jacobs\")\n\011local null   = require(\"tptmp.client.manager.null\")\n\011\n\011if rawget(_G, \"MANAGER\") then\n\011\011return jacobs\n\011else\n\011\011return null\n\011end\n\011\nend\n\nrequire_preload__[\"tptmp.client.manager.jacobs\"] = function()\n\n\011local config = require(\"tptmp.client.config\")\n\011\n\011local MANAGER = rawget(_G, \"MANAGER\")\n\011\n\011local function get(key, default)\n\011\011local value = MANAGER.getsetting(config.manager_namespace, key)\n\011\011return type(value) == \"string\" and value or default\n\011end\n\011\n\011local function set(key, value)\n\011\011MANAGER.savesetting(config.manager_namespace, key, value)\n\011end\n\011\n\011local function hidden()\n\011\011return MANAGER.hidden\n\011end\n\011\n\011local function print(msg)\n\011\011return MANAGER.print(msg)\n\011end\n\011\n\011return {\n\011\011hidden = hidden,\n\011\011get = get,\n\011\011set = set,\n\011\011print = print,\n\011\011brand = \"jacobs\",\n\011\011minimize_conflict = true,\n\011\011side_button_conflict = true,\n\011}\n\011\nend\n\nrequire_preload__[\"tptmp.client.manager.null\"] = function()\n\n\011local config = require(\"tptmp.client.config\")\n\011\n\011local data\n\011\n\011local function load_data()\n\011\011if data then\n\011\011\011return\n\011\011end\n\011\011data = {}\n\011\011local handle = io.open(config.null_manager_path, \"r\")\n\011\011if not handle then\n\011\011\011return\n\011\011end\n\011\011for line in handle:read(\"*a\"):gmatch(\"[^\\r\\n]+\") do\n\011\011\011local key, value = line:match(\"^([^=]+)=(.*)$\")\n\011\011\011if key then\n\011\011\011\011data[key] = value\n\011\011\011end\n\011\011end\n\011\011handle:close()\n\011end\n\011\n\011local function save_data()\n\011\011local handle = io.open(config.null_manager_path, \"w\")\n\011\011if not handle then\n\011\011\011return\n\011\011end\n\011\011local collect = {}\n\011\011for key, value in pairs(data) do\n\011\011\011table.insert(collect, tostring(key))\n\011\011\011table.insert(collect, \"=\")\n\011\011\011table.insert(collect, tostring(value))\n\011\011\011table.insert(collect, \"\\n\")\n\011\011end\n\011\011handle:write(table.concat(collect))\n\011\011handle:close()\n\011end\n\011\n\011local function get(key, default)\n\011\011load_data()\n\011\011return data[key] or default\n\011end\n\011\n\011local function set(key, value)\n\011\011data[key] = value\n\011\011save_data()\n\011end\n\011\n\011local function print(msg)\n\011\011print(msg)\n\011end\n\011\n\011return {\n\011\011get = get,\n\011\011set = set,\n\011\011print = print,\n\011\011brand = \"null\",\n\011}\n\011\nend\n\nrequire_preload__[\"tptmp.client.profile\"] = function()\n\n\011local vanilla = require(\"tptmp.client.profile.vanilla\")\n\011local jacobs  = require(\"tptmp.client.profile.jacobs\")\n\011\n\011if tpt.version.jacob1s_mod then\n\011\011return jacobs\n\011else\n\011\011return vanilla\n\011end\n\011\nend\n\nrequire_preload__[\"tptmp.client.profile.jacobs\"] = function()\n\n\011local vanilla = require(\"tptmp.client.profile.vanilla\")\n\011local config  = require(\"tptmp.client.config\")\n\011\n\011local profile_i = {}\n\011local profile_m = { __index = profile_i }\n\011\n\011for key, value in pairs(vanilla.profile_i) do\n\011\011profile_i[key] = value\n\011end\n\011\n\011function profile_i:handle_mousedown(px, py, button)\n\011\011if self.client and (tpt.tab_menu() == 1 or self.kmod_c_) and px >= sim.XRES and py < 116 and not self.kmod_a_ then\n\011\011\011self.log_event_func_(config.print_prefix .. \"The tab menu is disabled because it does not sync (press the Alt key to override)\")\n\011\011\011return true\n\011\011end\n\011\011return vanilla.profile_i.handle_mousedown(self, px, py, button)\n\011end\n\011\n\011local function new(params)\n\011\011local prof = vanilla.new(params)\n\011\011prof.buttons_.clear = { x = gfx.WIDTH - 148, y = gfx.HEIGHT - 16, w = 17, h = 15 }\n\011\011setmetatable(prof, profile_m)\n\011\011return prof\n\011end\n\011\n\011return {\n\011\011new = new,\n\011\011brand = \"jacobs\",\n\011}\n\011\nend\n\nrequire_preload__[\"tptmp.client.profile.vanilla\"] = function()\n\n\011local util   = require(\"tptmp.client.util\")\n\011local config = require(\"tptmp.client.config\")\n\011local sdl    = require(\"tptmp.client.sdl\")\n\011\n\011local profile_i = {}\n\011local profile_m = { __index = profile_i }\n\011\n\011local index_to_lrax = {\n\011\011[ 0 ] = \"tool_l_\",\n\011\011[ 1 ] = \"tool_r_\",\n\011\011[ 2 ] = \"tool_a_\",\n\011\011[ 3 ] = \"tool_x_\",\n\011}\n\011local index_to_lraxid = {\n\011\011[ 0 ] = \"tool_lid_\",\n\011\011[ 1 ] = \"tool_rid_\",\n\011\011[ 2 ] = \"tool_aid_\",\n\011\011[ 3 ] = \"tool_xid_\",\n\011}\n\011local toolwarn_tools = {\n\011\011[ \"DEFAULT_UI_PROPERTY\" ] = \"prop\",\n\011\011[ \"DEFAULT_TOOL_MIX\"    ] = \"mix\",\n\011\011[ \"DEFAULT_PT_LIGH\"     ] = \"ligh\",\n\011\011[ \"DEFAULT_PT_STKM\"     ] = \"stkm\",\n\011\011[ \"DEFAULT_PT_STKM2\"    ] = \"stkm\",\n\011\011[ \"DEFAULT_PT_SPAWN\"    ] = \"stkm\",\n\011\011[ \"DEFAULT_PT_SPAWN2\"   ] = \"stkm\",\n\011\011[ \"DEFAULT_PT_FIGH\"     ] = \"stkm\",\n\011\011[ \"UNKNOWN\"             ] = \"unknown\",\n\011}\n\011local toolwarn_messages = {\n\011\011prop      =                      \"The PROP tool does not sync, you will have to use /sync\",\n\011\011mix       =                       \"The MIX tool does not sync, you will have to use /sync\",\n\011\011ligh      =                               \"LIGH does not sync, you will have to use /sync\",\n\011\011stkm      =                             \"Stickmen do not sync, you will have to use /sync\",\n\011\011cbrush    =                       \"Custom brushes do not sync, you will have to use /sync\",\n\011\011ipcirc    =               \"The old circle brush does not sync, you will have to use /sync\",\n\011\011unknown   =  \"This custom element is not supported, please avoid using it while connected\",\n\011\011cgol      = \"This custom GOL type is not supported, please avoid using it while connected\",\n\011\011cgolcolor =  \"Custom GOL currently syncs without colours, use /sync to get colours across\",\n\011}\n\011\n\011local BRUSH_COUNT = 3\n\011local MOUSEUP_REASON_MOUSEUP = 0\n\011local MOUSEUP_REASON_BLUR    = 1\n\011local MAX_SIGNS = 0\n\011while sim.signs[MAX_SIGNS + 1] do\n\011\011MAX_SIGNS = MAX_SIGNS + 1\n\011end\n\011\n\011local function rulestring_bits(str)\n\011\011local bits = 0\n\011\011for i = 1, #str do\n\011\011\011bits = bit.bor(bits, bit.lshift(1, str:byte(i) - 48))\n\011\011end\n\011\011return bits\n\011end\n\011\n\011local function get_custgolinfo(identifier)\n\011\011-- * TODO[api]: add an api for this to tpt\n\011\011local pref = io.open(\"powder.pref\")\n\011\011if not pref then\n\011\011\011return\n\011\011end\n\011\011local pref_data = pref:read(\"*a\")\n\011\011pref:close()\n\011\011local types = pref_data:match([=[\"Types\"%s*:%s*%[([^%]]+)%]]=])\n\011\011if not types then\n\011\011\011return\n\011\011end\n\011\011for name, ruleset, primary, secondary in types:gmatch([[\"(%S+)%s+(%S+)%s+(%S+)%s+(%S+)\"]]) do\n\011\011\011if \"DEFAULT_PT_LIFECUST_\" .. name == identifier then\n\011\011\011\011local begin, stay, states = ruleset:match(\"^B([1-8]+)/S([0-8]+)/([0-9]+)$\")\n\011\011\011\011if not begin then\n\011\011\011\011\011begin, stay = ruleset:match(\"^B([1-8]+)/S([0-8]+)$\")\n\011\011\011\011\011states = \"2\"\n\011\011\011\011end\n\011\011\011\011states = tonumber(states)\n\011\011\011\011states = states >= 2 and states <= 17 and states\n\011\011\011\011ruleset = begin and stay and states and bit.bor(bit.lshift(rulestring_bits(begin), 8), rulestring_bits(stay), bit.lshift(states - 2, 17))\n\011\011\011\011primary = tonumber(primary)\n\011\011\011\011secondary = tonumber(secondary)\n\011\011\011\011if ruleset and primary and secondary then\n\011\011\011\011\011return ruleset, primary, secondary\n\011\011\011\011end\n\011\011\011\011break\n\011\011\011end\n\011\011end\n\011end\n\011\n\011local function get_sign_data()\n\011\011local sign_data = {}\n\011\011for i = 1, MAX_SIGNS do\n\011\011\011local text = sim.signs[i].text\n\011\011\011if text then\n\011\011\011\011sign_data[i] = {\n\011\011\011\011\011tx = text,\n\011\011\011\011\011ju = sim.signs[i].justification,\n\011\011\011\011\011px = sim.signs[i].x,\n\011\011\011\011\011py = sim.signs[i].y,\n\011\011\011\011}\n\011\011\011end\n\011\011end\n\011\011return sign_data\n\011end\n\011\n\011local function perfect_circle()\n\011\011return sim.brush(1, 1, 1, 1, 0)() == 0\n\011end\n\011\n\011local props = {}\n\011for key, value in pairs(sim) do\n\011\011if key:find(\"^FIELD_\") and key ~= \"FIELD_TYPE\" then\n\011\011\011table.insert(props, value)\n\011\011end\n\011end\n\011\n\011local function stash_part()\n\011\011local id = sim.parts()()\n\011\011local info\n\011\011if id then\n\011\011\011local x, y = sim.partPosition(id)\n\011\011\011id = sim.partID(math.floor(x + 0.5), math.floor(y + 0.5))\n\011\011\011local ty = sim.partProperty(id, \"type\")\n\011\011\011if ty then\n\011\011\011\011info = { [ sim.FIELD_TYPE ] = ty }\n\011\011\011\011for _, v in ipairs(props) do\n\011\011\011\011\011info[v] = sim.partProperty(id, v)\n\011\011\011\011end\n\011\011\011else\n\011\011\011\011info = false\n\011\011\011end\n\011\011\011sim.partProperty(id, \"type\", elem.DEFAULT_PT_ELEC)\n\011\011else\n\011\011\011id = sim.partCreate(-3, 0, 0, elem.DEFAULT_PT_ELEC)\n\011\011end\n\011\011return id, info\n\011end\n\011\n\011local function unstash_part(id, info)\n\011\011if info == nil then\n\011\011\011return\n\011\011end\n\011\011if not info then\n\011\011\011sim.partKill(id)\n\011\011\011return\n\011\011end\n\011\011sim.partProperty(id, \"type\", info[sim.FIELD_TYPE])\n\011\011for _, v in ipairs(props) do\n\011\011\011sim.partProperty(id, v, info[v])\n\011\011end\n\011end\n\011\n\011local function in_zoom_window(x, y)\n\011\011local ax, ay = sim.adjustCoords(x, y)\n\011\011return ren.zoomEnabled() and (ax ~= x or ay ~= y)\n\011end\n\011\n\011function profile_i:report_loadonline_(id, hist)\n\011\011if self.client_ then\n\011\011\011self.client_:send_loadonline(id, hist)\n\011\011end\n\011end\n\011\n\011function profile_i:report_pos_()\n\011\011if self.client_ then\n\011\011\011self.client_:send_mousepos(self.pos_x_, self.pos_y_)\n\011\011end\n\011end\n\011\n\011function profile_i:report_size_()\n\011\011if self.client_ then\n\011\011\011self.client_:send_brushsize(self.size_x_, self.size_y_)\n\011\011end\n\011end\n\011\n\011function profile_i:report_zoom_()\n\011\011if self.client_ then\n\011\011\011if self.zenabled_ then\n\011\011\011\011self.client_:send_zoomstart(self.zcx_, self.zcy_, self.zsize_)\n\011\011\011else\n\011\011\011\011self.client_:send_zoomend()\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function profile_i:report_bmode_()\n\011\011if self.client_ then\n\011\011\011self.client_:send_brushmode(self.bmode_)\n\011\011end\n\011end\n\011\n\011function profile_i:report_shape_()\n\011\011if self.client_ then\n\011\011\011self.client_:send_brushshape(self.shape_ < BRUSH_COUNT and self.shape_ or 0)\n\011\011end\n\011end\n\011\n\011function profile_i:report_sparksign_(x, y)\n\011\011if self.client_ then\n\011\011\011self.client_:send_sparksign(x, y)\n\011\011end\n\011end\n\011\n\011function profile_i:report_flood_(i, x, y)\n\011\011if self.client_ then\n\011\011\011self.client_:send_flood(i, x, y)\n\011\011end\n\011end\n\011\n\011function profile_i:report_lineend_(x, y)\n\011\011self.lss_i_ = nil\n\011\011if self.client_ then\n\011\011\011self.client_:send_lineend(x, y)\n\011\011end\n\011end\n\011\n\011function profile_i:report_rectend_(x, y)\n\011\011self.rss_i_ = nil\n\011\011if self.client_ then\n\011\011\011self.client_:send_rectend(x, y)\n\011\011end\n\011end\n\011\n\011function profile_i:sync_linestart_(i, x, y)\n\011\011if self.client_ and self.lss_i_ then\n\011\011\011self.client_:send_linestart(self.lss_i_, self.lss_x_, self.lss_y_)\n\011\011end\n\011end\n\011\n\011function profile_i:report_linestart_(i, x, y)\n\011\011self.lss_i_ = i\n\011\011self.lss_x_ = x\n\011\011self.lss_y_ = y\n\011\011if self.client_ then\n\011\011\011self.client_:send_linestart(i, x, y)\n\011\011end\n\011end\n\011\n\011function profile_i:sync_rectstart_(i, x, y)\n\011\011if self.client_ and self.rss_i_ then\n\011\011\011self.client_:send_rectstart(self.rss_i_, self.rss_x_, self.rss_y_)\n\011\011end\n\011end\n\011\n\011function profile_i:report_rectstart_(i, x, y)\n\011\011self.rss_i_ = i\n\011\011self.rss_x_ = x\n\011\011self.rss_y_ = y\n\011\011if self.client_ then\n\011\011\011self.client_:send_rectstart(i, x, y)\n\011\011end\n\011end\n\011\n\011function profile_i:sync_pointsstart_()\n\011\011if self.client_ and self.pts_i_ then\n\011\011\011self.client_:send_pointsstart(self.pts_i_, self.pts_x_, self.pts_y_)\n\011\011end\n\011end\n\011\n\011function profile_i:report_pointsstart_(i, x, y)\n\011\011self.pts_i_ = i\n\011\011self.pts_x_ = x\n\011\011self.pts_y_ = y\n\011\011if self.client_ then\n\011\011\011self.client_:send_pointsstart(i, x, y)\n\011\011end\n\011end\n\011\n\011function profile_i:report_pointscont_(x, y, done)\n\011\011if self.client_ then\n\011\011\011self.client_:send_pointscont(x, y)\n\011\011end\n\011\011self.pts_x_ = x\n\011\011self.pts_y_ = y\n\011\011if done then\n\011\011\011self.pts_i_ = nil\n\011\011end\n\011end\n\011\n\011function profile_i:report_kmod_()\n\011\011if self.client_ then\n\011\011\011self.client_:send_keybdmod(self.kmod_c_, self.kmod_s_, self.kmod_a_)\n\011\011end\n\011end\n\011\n\011function profile_i:report_framestep_()\n\011\011if self.client_ then\n\011\011\011self.client_:send_stepsim()\n\011\011end\n\011end\n\011\n\011function profile_i:report_airinvert_()\n\011\011if self.client_ then\n\011\011\011self.client_:send_airinv()\n\011\011end\n\011end\n\011\n\011function profile_i:report_reset_spark_()\n\011\011if self.client_ then\n\011\011\011self.client_:send_sparkclear()\n\011\011end\n\011end\n\011\n\011function profile_i:report_reset_air_()\n\011\011if self.client_ then\n\011\011\011self.client_:send_airclear()\n\011\011end\n\011end\n\011\n\011function profile_i:report_reset_airtemp_()\n\011\011if self.client_ then\n\011\011\011self.client_:send_heatclear()\n\011\011end\n\011end\n\011\n\011function profile_i:report_clearrect_(x, y, w, h)\n\011\011if self.client_ then\n\011\011\011self.client_:send_clearrect(x, y, w, h)\n\011\011end\n\011end\n\011\n\011function profile_i:report_clearsim_()\n\011\011if self.client_ then\n\011\011\011self.client_:send_clearsim()\n\011\011end\n\011end\n\011\n\011function profile_i:report_reloadsim_()\n\011\011if self.client_ then\n\011\011\011self.client_:send_reloadsim()\n\011\011end\n\011end\n\011\n\011function profile_i:simstate_sync()\n\011\011if self.client_ then\n\011\011\011self.client_:send_simstate(self.ss_p_, self.ss_h_, self.ss_u_, self.ss_n_, self.ss_w_, self.ss_g_, self.ss_a_, self.ss_e_, self.ss_y_, self.ss_t_)\n\011\011end\n\011end\n\011\n\011function profile_i:report_tool_(index)\n\011\011if self.client_ then\n\011\011\011self.client_:send_selecttool(index, self[index_to_lrax[index]])\n\011\011\011local identifier = self[index_to_lraxid[index]]\n\011\011\011if identifier:find(\"^DEFAULT_PT_LIFECUST_\") then\n\011\011\011\011local ruleset, primary, secondary = get_custgolinfo(identifier)\n\011\011\011\011if ruleset then\n\011\011\011\011\011self.client_:send_custgolinfo(ruleset, primary, secondary)\n\011\011\011\011\011-- * TODO[api]: add an api for setting gol colour\n\011\011\011\011\011self.display_toolwarn_[\"cgolcolor\"] = true\n\011\011\011\011else\n\011\011\011\011\011self.display_toolwarn_[\"cgol\"] = true\n\011\011\011\011end\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function profile_i:report_deco_()\n\011\011if self.client_ then\n\011\011\011self.client_:send_brushdeco(self.deco_)\n\011\011end\n\011end\n\011\n\011function profile_i:sync_placestatus_()\n\011\011if self.client_ and self.pes_k_ ~= 0 then\n\011\011\011self.client_:send_placestatus(self.pes_k_, self.pes_w_, self.pes_h_)\n\011\011end\n\011end\n\011\n\011function profile_i:report_placestatus_(k, w, h)\n\011\011self.pes_k_ = k\n\011\011self.pes_w_ = w\n\011\011self.pes_h_ = h\n\011\011if self.client_ then\n\011\011\011self.client_:send_placestatus(k, w, h)\n\011\011end\n\011end\n\011\n\011function profile_i:sync_selectstatus_()\n\011\011if self.client_ and self.sts_k_ ~= 0 then\n\011\011\011self.client_:send_selectstatus(self.sts_k_, self.sts_x_, self.sts_y_)\n\011\011end\n\011end\n\011\n\011function profile_i:report_selectstatus_(k, x, y)\n\011\011self.sts_k_ = k\n\011\011self.sts_x_ = x\n\011\011self.sts_y_ = y\n\011\011if self.client_ then\n\011\011\011self.client_:send_selectstatus(k, x, y)\n\011\011end\n\011end\n\011\n\011function profile_i:report_pastestamp_(x, y, w, h)\n\011\011if self.client_ then\n\011\011\011self.client_:send_pastestamp(x, y, w, h)\n\011\011end\n\011end\n\011\n\011function profile_i:report_canceldraw_()\n\011\011if self.client_ then\n\011\011\011self.client_:send_canceldraw()\n\011\011end\n\011end\n\011\n\011function profile_i:get_stamp_size_()\n\011\011local stampsdef = io.open(\"stamps/stamps.def\", \"rb\")\n\011\011if not stampsdef then\n\011\011\011return\n\011\011end\n\011\011local name = stampsdef:read(10)\n\011\011stampsdef:close()\n\011\011if type(name) ~= \"string\" or #name ~= 10 then\n\011\011\011return\n\011\011end\n\011\011local stamp = io.open(\"stamps/\" .. name .. \".stm\", \"rb\")\n\011\011if not stamp then\n\011\011\011return\n\011\011end\n\011\011local header = stamp:read(12)\n\011\011stamp:close()\n\011\011if type(header) ~= \"string\" or #header ~= 12 then\n\011\011\011return\n\011\011end\n\011\011local bw, bh = header:byte(7, 8) -- * Works for OPS and PSv too.\n\011\011return bw * 4, bh * 4\n\011end\n\011\n\011function profile_i:user_sync()\n\011\011self:report_size_()\n\011\011self:report_tool_(0)\n\011\011self:report_tool_(1)\n\011\011self:report_tool_(2)\n\011\011self:report_tool_(3)\n\011\011self:report_deco_()\n\011\011self:report_bmode_()\n\011\011self:report_shape_()\n\011\011self:report_kmod_()\n\011\011self:report_pos_()\n\011\011self:sync_pointsstart_()\n\011\011self:sync_placestatus_()\n\011\011self:sync_selectstatus_()\n\011\011self:sync_linestart_()\n\011\011self:sync_rectstart_()\n\011\011self:report_zoom_()\n\011end\n\011\n\011function profile_i:post_event_check_()\n\011\011if self.placesave_postmsg_ then\n\011\011\011local partcount = self.placesave_postmsg_.partcount\n\011\011\011if self.debug_ then\n\011\011\011\011self.debug_(\"fallback placesave detection\", sim.NUM_PARTS, partcount)\n\011\011\011end\n\011\011\011if partcount and (partcount ~= sim.NUM_PARTS or sim.NUM_PARTS == sim.XRES * sim.YRES) and self.registered_func_() then\n\011\011\011\011-- * TODO[api]: get rid of all of this nonsense once redo-ui lands\n\011\011\011\011if self.client_ then\n\011\011\011\011\011self.client_:send_sync()\n\011\011\011\011end\n\011\011\011\011if self.debug_ then\n\011\011\011\011\011self.debug_(\"failed to determine paste area while connected, syncing everything\")\n\011\011\011\011end\n\011\011\011end\n\011\011\011self.placesave_postmsg_ = nil\n\011\011end\n\011\011if self.placesave_size_ then\n\011\011\011local x1, y1, x2, y2 = self:end_placesave_size_()\n\011\011\011if x1 then\n\011\011\011\011if self.debug_ then\n\011\011\011\011\011self.debug_(\"placesave size determined to be\", x1, y1, x2, y2)\n\011\011\011\011end\n\011\011\011\011local x, y, w, h = util.corners_to_rect(x1, y1, x2, y2)\n\011\011\011\011self.simstate_invalid_ = true\n\011\011\011\011if self.placesave_open_ then\n\011\011\011\011\011local id, hist = util.get_save_id()\n\011\011\011\011\011self.set_id_func_(id, hist)\n\011\011\011\011\011if id then\n\011\011\011\011\011\011self:report_loadonline_(id, hist)\n\011\011\011\011\011else\n\011\011\011\011\011\011self:report_pastestamp_(x, y, w, h)\n\011\011\011\011\011end\n\011\011\011\011elseif self.placesave_reload_ then\n\011\011\011\011\011if not self.get_id_func_() then\n\011\011\011\011\011\011self:report_pastestamp_(x, y, w, h)\n\011\011\011\011\011end\n\011\011\011\011\011self:report_reloadsim_()\n\011\011\011\011elseif self.placesave_clear_ then\n\011\011\011\011\011self.set_id_func_(nil, nil)\n\011\011\011\011\011self:report_clearsim_()\n\011\011\011\011else\n\011\011\011\011\011self:report_pastestamp_(x, y, w, h)\n\011\011\011\011end\n\011\011\011else\n\011\011\011\011if self.debug_ then\n\011\011\011\011\011self.debug_(\"placesave size not determined\")\n\011\011\011\011end\n\011\011\011end\n\011\011\011self.placesave_open_ = nil\n\011\011\011self.placesave_reload_ = nil\n\011\011\011self.placesave_clear_ = nil\n\011\011end\n\011\011if self.zoom_invalid_ then\n\011\011\011self.zoom_invalid_ = nil\n\011\011\011self:update_zoom_()\n\011\011end\n\011\011if self.simstate_invalid_ then\n\011\011\011self.simstate_invalid_ = nil\n\011\011\011self:check_simstate()\n\011\011end\n\011\011if self.bmode_invalid_ then\n\011\011\011self.bmode_invalid_ = nil\n\011\011\011self:update_bmode_()\n\011\011end\n\011\011self:update_size_()\n\011\011self:update_shape_()\n\011\011self:update_tools_()\n\011\011self:update_deco_()\n\011end\n\011\n\011function profile_i:sample_simstate()\n\011\011local ss_p = tpt.set_pause()\n\011\011local ss_h = tpt.heat()\n\011\011local ss_u = tpt.ambient_heat()\n\011\011local ss_n = tpt.newtonian_gravity()\n\011\011local ss_w = sim.waterEqualisation()\n\011\011local ss_g = sim.gravityMode()\n\011\011local ss_a = sim.airMode()\n\011\011local ss_e = sim.edgeMode()\n\011\011local ss_y = sim.prettyPowders()\n\011\011local ss_t = util.ambient_air_temp()\n\011\011if self.ss_p_ ~= ss_p or\n\011\011   self.ss_h_ ~= ss_h or\n\011\011   self.ss_u_ ~= ss_u or\n\011\011   self.ss_n_ ~= ss_n or\n\011\011   self.ss_w_ ~= ss_w or\n\011\011   self.ss_g_ ~= ss_g or\n\011\011   self.ss_a_ ~= ss_a or\n\011\011   self.ss_e_ ~= ss_e or\n\011\011   self.ss_y_ ~= ss_y or\n\011\011   self.ss_t_ ~= ss_t then\n\011\011\011self.ss_p_ = ss_p\n\011\011\011self.ss_h_ = ss_h\n\011\011\011self.ss_u_ = ss_u\n\011\011\011self.ss_n_ = ss_n\n\011\011\011self.ss_w_ = ss_w\n\011\011\011self.ss_g_ = ss_g\n\011\011\011self.ss_a_ = ss_a\n\011\011\011self.ss_e_ = ss_e\n\011\011\011self.ss_y_ = ss_y\n\011\011\011self.ss_t_ = ss_t\n\011\011\011return true\n\011\011end\n\011\011return false\n\011end\n\011\n\011function profile_i:check_signs(old_data)\n\011\011local new_data = get_sign_data()\n\011\011local bw = sim.XRES / 4\n\011\011local to_send = {}\n\011\011local function key(x, y)\n\011\011\011return math.floor(x / 4) + math.floor(y / 4) * bw\n\011\011end\n\011\011for i = 1, MAX_SIGNS do\n\011\011\011if old_data[i] and new_data[i] then\n\011\011\011\011if old_data[i].ju ~= new_data[i].ju or\n\011\011\011\011   old_data[i].tx ~= new_data[i].tx or\n\011\011\011\011   old_data[i].px ~= new_data[i].px or\n\011\011\011\011   old_data[i].py ~= new_data[i].py then\n\011\011\011\011\011to_send[key(old_data[i].px, old_data[i].py)] = true\n\011\011\011\011\011to_send[key(new_data[i].px, new_data[i].py)] = true\n\011\011\011\011end\n\011\011\011elseif old_data[i] then\n\011\011\011\011to_send[key(old_data[i].px, old_data[i].py)] = true\n\011\011\011elseif new_data[i] then\n\011\011\011\011to_send[key(new_data[i].px, new_data[i].py)] = true\n\011\011\011end\n\011\011end\n\011\011for k in pairs(to_send) do\n\011\011\011local x, y, w, h = k % bw * 4, math.floor(k / bw) * 4, 4, 4\n\011\011\011self:report_clearrect_(x, y, w, h)\n\011\011\011self:report_pastestamp_(x, y, w, h)\n\011\011end\n\011end\n\011\n\011function profile_i:check_simstate()\n\011\011if self:sample_simstate() then\n\011\011\011self:simstate_sync()\n\011\011end\n\011end\n\011\n\011function profile_i:update_draw_mode_()\n\011\011if self.kmod_c_ and self.kmod_s_ then\n\011\011\011if util.xid_class[self[index_to_lrax[self.last_toolslot_]]] == \"TOOL\" then\n\011\011\011\011self.draw_mode_ = \"points\"\n\011\011\011else\n\011\011\011\011self.draw_mode_ = \"flood\"\n\011\011\011end\n\011\011elseif self.kmod_c_ then\n\011\011\011self.draw_mode_ = \"rect\"\n\011\011elseif self.kmod_s_ then\n\011\011\011self.draw_mode_ = \"line\"\n\011\011else\n\011\011\011self.draw_mode_ = \"points\"\n\011\011end\n\011end\n\011\n\011function profile_i:enable_shift_()\n\011\011self.kmod_changed_ = true\n\011\011self.kmod_s_ = true\n\011\011if not self.dragging_mouse_ or self.select_mode_ ~= \"none\" then\n\011\011\011self:update_draw_mode_()\n\011\011end\n\011end\n\011\n\011function profile_i:enable_ctrl_()\n\011\011self.kmod_changed_ = true\n\011\011self.kmod_c_ = true\n\011\011if not self.dragging_mouse_ or self.select_mode_ ~= \"none\" then\n\011\011\011self:update_draw_mode_()\n\011\011end\n\011end\n\011\n\011function profile_i:enable_alt_()\n\011\011self.kmod_changed_ = true\n\011\011self.kmod_a_ = true\n\011end\n\011\n\011function profile_i:disable_shift_()\n\011\011self.kmod_changed_ = true\n\011\011self.kmod_s_ = false\n\011\011if not self.dragging_mouse_ or self.select_mode_ ~= \"none\" then\n\011\011\011self:update_draw_mode_()\n\011\011end\n\011end\n\011\n\011function profile_i:disable_ctrl_()\n\011\011self.kmod_changed_ = true\n\011\011self.kmod_c_ = false\n\011\011if not self.dragging_mouse_ or self.select_mode_ ~= \"none\" then\n\011\011\011self:update_draw_mode_()\n\011\011end\n\011end\n\011\n\011function profile_i:disable_alt_()\n\011\011self.kmod_changed_ = true\n\011\011self.kmod_a_ = false\n\011end\n\011\n\011function profile_i:update_pos_(x, y)\n\011\011x, y = sim.adjustCoords(x, y)\n\011\011if x < 0         then x = 0            end\n\011\011if x >= sim.XRES then x = sim.XRES - 1 end\n\011\011if y < 0         then y = 0            end\n\011\011if y >= sim.YRES then y = sim.YRES - 1 end\n\011\011if self.pos_x_ ~= x or self.pos_y_ ~= y then\n\011\011\011self.pos_x_ = x\n\011\011\011self.pos_y_ = y\n\011\011\011self:report_pos_(self.pos_x_, self.pos_y_)\n\011\011end\n\011end\n\011\n\011function profile_i:update_size_()\n\011\011local x, y = tpt.brushx, tpt.brushy\n\011\011if x < 0   then x = 0   end\n\011\011if x > 255 then x = 255 end\n\011\011if y < 0   then y = 0   end\n\011\011if y > 255 then y = 255 end\n\011\011if self.size_x_ ~= x or self.size_y_ ~= y then\n\011\011\011self.size_x_ = x\n\011\011\011self.size_y_ = y\n\011\011\011self:report_size_(self.size_x_, self.size_y_)\n\011\011end\n\011end\n\011\n\011function profile_i:update_zoom_()\n\011\011local zenabled = ren.zoomEnabled()\n\011\011local zcx, zcy, zsize = ren.zoomScope()\n\011\011if self.zenabled_ ~= zenabled or self.zcx_ ~= zcx or self.zcy_ ~= zcy or self.zsize_ ~= zsize then\n\011\011\011self.zenabled_ = zenabled\n\011\011\011self.zcx_ = zcx\n\011\011\011self.zcy_ = zcy\n\011\011\011self.zsize_ = zsize\n\011\011\011self:report_zoom_()\n\011\011end\n\011end\n\011\n\011function profile_i:update_bmode_()\n\011\011local bmode = sim.replaceModeFlags()\n\011\011if self.bmode_ ~= bmode then\n\011\011\011self.bmode_ = bmode\n\011\011\011self:report_bmode_()\n\011\011end\n\011end\n\011\n\011function profile_i:update_shape_()\n\011\011local pcirc = self.perfect_circle_\n\011\011if self.perfect_circle_invalid_ then\n\011\011\011pcirc = perfect_circle()\n\011\011end\n\011\011local shape = tpt.brushID\n\011\011if self.shape_ ~= shape or self.perfect_circle_ ~= pcirc then\n\011\011\011local old_cbrush = self.cbrush_\n\011\011\011self.cbrush_ = shape >= BRUSH_COUNT or nil\n\011\011\011if not old_cbrush and self.cbrush_ then\n\011\011\011\011self.display_toolwarn_[\"cbrush\"] = true\n\011\011\011end\n\011\011\011local old_ipcirc = self.ipcirc_\n\011\011\011self.ipcirc_ = shape == 0 and not pcirc\n\011\011\011if not old_ipcirc and self.ipcirc_ then\n\011\011\011\011self.display_toolwarn_[\"ipcirc\"] = true\n\011\011\011end\n\011\011\011self.shape_ = shape\n\011\011\011self.perfect_circle_ = pcirc\n\011\011\011self:report_shape_()\n\011\011end\n\011end\n\011\n\011function profile_i:update_tools_()\n\011\011local tlid = tpt.selectedl\n\011\011local trid = tpt.selectedr\n\011\011local taid = tpt.selecteda\n\011\011local txid = tpt.selectedreplace\n\011\011if self.tool_lid_ ~= tlid then\n\011\011\011self.tool_l_ = util.from_tool[tlid] or util.unknown_xid\n\011\011\011self.tool_lid_ = tlid\n\011\011\011self:report_tool_(0)\n\011\011end\n\011\011if self.tool_rid_ ~= trid then\n\011\011\011self.tool_r_ = util.from_tool[trid] or util.unknown_xid\n\011\011\011self.tool_rid_ = trid\n\011\011\011self:report_tool_(1)\n\011\011end\n\011\011if self.tool_aid_ ~= taid then\n\011\011\011self.tool_a_ = util.from_tool[taid] or util.unknown_xid\n\011\011\011self.tool_aid_ = taid\n\011\011\011self:report_tool_(2)\n\011\011end\n\011\011if self.tool_xid_ ~= txid then\n\011\011\011self.tool_x_ = util.from_tool[txid] or util.unknown_xid\n\011\011\011self.tool_xid_ = txid\n\011\011\011self:report_tool_(3)\n\011\011end\n\011\011local new_tool = util.to_tool[self[index_to_lrax[self.last_toolslot_]]]\n\011\011local new_tool_id = self[index_to_lraxid[self.last_toolslot_]]\n\011\011if self.last_tool_ ~= new_tool then\n\011\011\011if not new_tool_id:find(\"^DEFAULT_PT_LIFECUST_\") then\n\011\011\011\011if toolwarn_tools[new_tool] then\n\011\011\011\011\011self.display_toolwarn_[toolwarn_tools[new_tool]] = true\n\011\011\011\011end\n\011\011\011end\n\011\011\011self.last_tool_ = new_tool\n\011\011end\n\011end\n\011\n\011function profile_i:update_kmod_()\n\011\011if self.kmod_changed_ then\n\011\011\011self.kmod_changed_ = nil\n\011\011\011self:report_kmod_()\n\011\011end\n\011end\n\011\n\011function profile_i:update_deco_()\n\011\011local deco = sim.decoColour()\n\011\011if self.deco_ ~= deco then\n\011\011\011self.deco_ = deco\n\011\011\011self:report_deco_()\n\011\011end\n\011end\n\011\n\011function profile_i:begin_placesave_size_(x, y, aux_button)\n\011\011local bx, by = math.floor(x / 4), math.floor(y / 4)\n\011\011local p = 0\n\011\011local pres = {}\n\011\011local function push(x, y)\n\011\011\011p = p + 2\n\011\011\011local pr = sim.pressure(x, y)\n\011\011\011if pr >  256 then pr =  256 end\n\011\011\011if pr < -256 then pr = -256 end\n\011\011\011local st = (math.floor(pr * 0x10) * 0x1000 + math.random(0x000, 0xFFF)) / 0x10000\n\011\011\011pres[p - 1] = pr\n\011\011\011pres[p] = st\n\011\011\011sim.pressure(x, y, st)\n\011\011end\n\011\011for x = 0, sim.XRES / 4 - 1 do\n\011\011\011push(x, by)\n\011\011end\n\011\011for y = 0, sim.YRES / 4 - 1 do\n\011\011\011if y ~= by then\n\011\011\011\011push(bx, y)\n\011\011\011end\n\011\011end\n\011\011local pss = {\n\011\011\011pres = pres,\n\011\011\011bx = bx,\n\011\011\011by = by,\n\011\011\011aux_button = aux_button,\n\011\011\011airmode = sim.airMode(),\n\011\011\011partcount = sim.NUM_PARTS,\n\011\011}\n\011\011if aux_button then\n\011\011\011-- * This means that begin_placesave_size_ was called from a button\n\011\011\011--   callback, i.e. not really in response to pasting, but reloading /\n\011\011\011--   clearing / opening a save. In this case, the air mode should\n\011\011\011--   not be reset to the original air mode, but left to be whatever\n\011\011\011--   value these actions set it to.\n\011\011\011self.placesave_size_next_ = pss\n\011\011else\n\011\011\011self.placesave_size_ = pss\n\011\011end\n\011\011sim.airMode(4)\n\011end\n\011\n\011function profile_i:end_placesave_size_()\n\011\011local bx, by = self.placesave_size_.bx, self.placesave_size_.by\n\011\011local pres = self.placesave_size_.pres\n\011\011local p = 0\n\011\011local lx, ly, hx, hy = math.huge, math.huge, -math.huge, -math.huge\n\011\011local function pop(x, y)\n\011\011\011p = p + 2\n\011\011\011if sim.pressure(x, y) == pres[p] then\n\011\011\011\011sim.pressure(x, y, pres[p - 1])\n\011\011\011else\n\011\011\011\011lx = math.min(lx, x)\n\011\011\011\011ly = math.min(ly, y)\n\011\011\011\011hx = math.max(hx, x)\n\011\011\011\011hy = math.max(hy, y)\n\011\011\011end\n\011\011end\n\011\011for x = 0, sim.XRES / 4 - 1 do\n\011\011\011pop(x, by)\n\011\011end\n\011\011for y = 0, sim.YRES / 4 - 1 do\n\011\011\011if y ~= by then\n\011\011\011\011pop(bx, y)\n\011\011\011end\n\011\011end\n\011\011-- * Unlike normal stamp pastes, auxiliary button events (open, save, clear)\n\011\011--   are guaranteed to have been cancelled if no air change is detected.\n\011\011--   The following block roughly translates to resetting the air mode to\n\011\011--   the sampled value if the change in the simulation occurred due to\n\011\011--   a paste event, otherwise only if we actually detected a change in air.\n\011\011if not self.placesave_size_.aux_button or lx == math.huge then\n\011\011\011sim.airMode(self.placesave_size_.airmode)\n\011\011end\n\011\011local partcount = self.placesave_size_.partcount\n\011\011self.placesave_size_ = nil\n\011\011if lx == math.huge then\n\011\011\011self.placesave_postmsg_ = {\n\011\011\011\011partcount = partcount,\n\011\011\011}\n\011\011else\n\011\011\011return math.max((lx - 2) * 4, 0),\n\011\011\011       math.max((ly - 2) * 4, 0),\n\011\011\011       math.min((hx + 2) * 4, sim.XRES) - 1,\n\011\011\011       math.min((hy + 2) * 4, sim.YRES) - 1\n\011\011end\n\011end\n\011\n\011function profile_i:handle_tick()\n\011\011self:post_event_check_()\n\011\011if self.want_stamp_size_ then\n\011\011\011self.want_stamp_size_ = nil\n\011\011\011local w, h = self:get_stamp_size_()\n\011\011\011if w then\n\011\011\011\011self.place_x_, self.place_y_ = w, h\n\011\011\011end\n\011\011end\n\011\011if self.signs_invalid_ then\n\011\011\011local sign_data = self.signs_invalid_\n\011\011\011self.signs_invalid_ = nil\n\011\011\011self:check_signs(sign_data)\n\011\011end\n\011\011self:update_pos_(tpt.mousex, tpt.mousey)\n\011\011-- * Here the assumption is made that no Lua hook cancels the tick event.\n\011\011if self.placing_zoom_ then\n\011\011\011self.zoom_invalid_ = true\n\011\011end\n\011\011if self.skip_draw_ then\n\011\011\011self.skip_draw_ = nil\n\011\011else\n\011\011\011if self.select_mode_ == \"none\" and self.dragging_mouse_ then\n\011\011\011\011if self.draw_mode_ == \"flood\" then\n\011\011\011\011\011self:report_flood_(self.last_toolslot_, self.pos_x_, self.pos_y_)\n\011\011\011\011end\n\011\011\011\011if self.draw_mode_ == \"points\" then\n\011\011\011\011\011self:report_pointscont_(self.pos_x_, self.pos_y_)\n\011\011\011\011end\n\011\011\011end\n\011\011end\n\011\011if self.simstate_invalid_next_ then\n\011\011\011self.simstate_invalid_next_ = nil\n\011\011\011self.simstate_invalid_ = true\n\011\011end\n\011\011if self.placesave_size_next_ then\n\011\011\011self.placesave_size_ = self.placesave_size_next_\n\011\011\011self.placesave_size_next_ = nil\n\011\011end\n\011\011local complete_select_mode = self.select_x_ and self.select_mode_\n\011\011if self.prev_select_mode_ ~= complete_select_mode then\n\011\011\011self.prev_select_mode_ = complete_select_mode\n\011\011\011if self.select_mode_ == \"copy\"\n\011\011\011or self.select_mode_ == \"cut\"\n\011\011\011or self.select_mode_ == \"stamp\" then\n\011\011\011\011if self.select_mode_ == \"copy\" then\n\011\011\011\011\011self:report_selectstatus_(1, self.select_x_, self.select_y_)\n\011\011\011\011elseif self.select_mode_ == \"cut\" then\n\011\011\011\011\011self:report_selectstatus_(2, self.select_x_, self.select_y_)\n\011\011\011\011elseif self.select_mode_ == \"stamp\" then\n\011\011\011\011\011self:report_selectstatus_(3, self.select_x_, self.select_y_)\n\011\011\011\011end\n\011\011\011else\n\011\011\011\011self.select_x_, self.select_y_ = nil, nil\n\011\011\011\011self:report_selectstatus_(0, 0, 0)\n\011\011\011end\n\011\011end\n\011\011local complete_place_mode = self.place_x_ and self.select_mode_\n\011\011if self.prev_place_mode_ ~= complete_place_mode then\n\011\011\011self.prev_place_mode_ = complete_place_mode\n\011\011\011if self.select_mode_ == \"place\" then\n\011\011\011\011self:report_placestatus_(1, self.place_x_, self.place_y_)\n\011\011\011else\n\011\011\011\011self.place_x_, self.place_y_ = nil, nil\n\011\011\011\011self:report_placestatus_(0, 0, 0)\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function profile_i:handle_mousedown(px, py, button)\n\011\011self:post_event_check_()\n\011\011self:update_pos_(px, py)\n\011\011self.last_in_zoom_window_ = in_zoom_window(px, py)\n\011\011-- * Here the assumption is made that no Lua hook cancels the mousedown event.\n\011\011if not self.kmod_c_ and not self.kmod_s_ and self.kmod_a_ and button == sdl.SDL_BUTTON_LEFT then\n\011\011\011button = 2\n\011\011end\n\011\011for _, btn in pairs(self.buttons_) do\n\011\011\011if util.inside_rect(btn.x, btn.y, btn.w, btn.h, tpt.mousex, tpt.mousey) then\n\011\011\011\011btn.active = true\n\011\011\011end\n\011\011end\n\011\011if not self.placing_zoom_ then\n\011\011\011if self.select_mode_ ~= \"none\" then\n\011\011\011\011self.sel_x1_ = self.pos_x_\n\011\011\011\011self.sel_y1_ = self.pos_y_\n\011\011\011\011self.sel_x2_ = self.pos_x_\n\011\011\011\011self.sel_y2_ = self.pos_y_\n\011\011\011\011self.dragging_mouse_ = true\n\011\011\011\011self.select_x_, self.select_y_ = self.pos_x_, self.pos_y_\n\011\011\011\011return\n\011\011\011end\n\011\011\011if px < sim.XRES and py < sim.YRES then\n\011\011\011\011if button == sdl.SDL_BUTTON_LEFT then\n\011\011\011\011\011self.last_toolslot_ = 0\n\011\011\011\011elseif button == sdl.SDL_BUTTON_MIDDLE then\n\011\011\011\011\011self.last_toolslot_ = 2\n\011\011\011\011elseif button == sdl.SDL_BUTTON_RIGHT then\n\011\011\011\011\011self.last_toolslot_ = 1\n\011\011\011\011else\n\011\011\011\011\011return\n\011\011\011\011end\n\011\011\011\011self:update_tools_()\n\011\011\011\011if next(self.display_toolwarn_) then\n\011\011\011\011\011if self.registered_func_() then\n\011\011\011\011\011\011for key in pairs(self.display_toolwarn_) do\n\011\011\011\011\011\011\011self.log_event_func_(toolwarn_messages[key])\n\011\011\011\011\011\011end\n\011\011\011\011\011end\n\011\011\011\011\011self.display_toolwarn_ = {}\n\011\011\011\011end\n\011\011\011\011self:update_draw_mode_()\n\011\011\011\011self.dragging_mouse_ = true\n\011\011\011\011if self.draw_mode_ == \"rect\" then\n\011\011\011\011\011self:report_rectstart_(self.last_toolslot_, self.pos_x_, self.pos_y_)\n\011\011\011\011end\n\011\011\011\011if self.draw_mode_ == \"line\" then\n\011\011\011\011\011self:report_linestart_(self.last_toolslot_, self.pos_x_, self.pos_y_)\n\011\011\011\011end\n\011\011\011\011if self.draw_mode_ == \"flood\" then\n\011\011\011\011\011if util.xid_class[self[index_to_lrax[self.last_toolslot_]]] == \"DECOR\" and self.registered_func_() then\n\011\011\011\011\011\011self.log_event_func_(\"Decoration flooding does not sync, you will have to use /sync\")\n\011\011\011\011\011end\n\011\011\011\011\011self:report_flood_(self.last_toolslot_, self.pos_x_, self.pos_y_)\n\011\011\011\011end\n\011\011\011\011if self.draw_mode_ == \"points\" then\n\011\011\011\011\011self:report_pointsstart_(self.last_toolslot_, self.pos_x_, self.pos_y_)\n\011\011\011\011end\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function profile_i:cancel_drawing_()\n\011\011if self.dragging_mouse_ then\n\011\011\011self:report_canceldraw_()\n\011\011\011self.dragging_mouse_ = false\n\011\011end\n\011end\n\011\n\011function profile_i:handle_mousemove(px, py, delta_x, delta_y)\n\011\011self:post_event_check_()\n\011\011self:update_pos_(px, py)\n\011\011for _, btn in pairs(self.buttons_) do\n\011\011\011if not util.inside_rect(btn.x, btn.y, btn.w, btn.h, tpt.mousex, tpt.mousey) then\n\011\011\011\011btn.active = false\n\011\011\011end\n\011\011end\n\011\011-- * Here the assumption is made that no Lua hook cancels the mousemove event.\n\011\011if self.select_mode_ ~= \"none\" then\n\011\011\011if self.select_mode_ == \"place\" then\n\011\011\011\011self.sel_x1_ = self.pos_x_\n\011\011\011\011self.sel_y1_ = self.pos_y_\n\011\011\011end\n\011\011\011if self.sel_x1_ then\n\011\011\011\011self.sel_x2_ = self.pos_x_\n\011\011\011\011self.sel_y2_ = self.pos_y_\n\011\011\011end\n\011\011elseif self.dragging_mouse_ then\n\011\011\011local last = self.last_in_zoom_window_\n\011\011\011self.last_in_zoom_window_ = in_zoom_window(px, py)\n\011\011\011if last ~= self.last_in_zoom_window_ and (self.draw_mode_ == \"flood\" or self.draw_mode_ == \"points\") then\n\011\011\011\011self:cancel_drawing_()\n\011\011\011\011return\n\011\011\011end\n\011\011\011if self.draw_mode_ == \"flood\" then\n\011\011\011\011self:report_flood_(self.last_toolslot_, self.pos_x_, self.pos_y_)\n\011\011\011\011self.skip_draw_ = true\n\011\011\011end\n\011\011\011if self.draw_mode_ == \"points\" then\n\011\011\011\011self:report_pointscont_(self.pos_x_, self.pos_y_)\n\011\011\011\011self.skip_draw_ = true\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function profile_i:handle_mouseup(px, py, button, reason)\n\011\011self:post_event_check_()\n\011\011self:update_pos_(px, py)\n\011\011for name, btn in pairs(self.buttons_) do\n\011\011\011if btn.active then\n\011\011\011\011self[\"button_\" .. name .. \"_\"](self)\n\011\011\011end\n\011\011\011btn.active = false\n\011\011end\n\011\011-- * Here the assumption is made that no Lua hook cancels the mouseup event.\n\011\011if px >= sim.XRES or py >= sim.YRES then\n\011\011\011self.perfect_circle_invalid_ = true\n\011\011\011self.simstate_invalid_next_ = true\n\011\011end\n\011\011if reason == MOUSEUP_REASON_MOUSEUP and self[index_to_lrax[self.last_toolslot_]] ~= util.from_tool.DEFAULT_UI_SIGN or button ~= 1 then\n\011\011\011for i = 1, MAX_SIGNS do\n\011\011\011\011local x = sim.signs[i].screenX\n\011\011\011\011if x then\n\011\011\011\011\011local t = sim.signs[i].text\n\011\011\011\011\011local y = sim.signs[i].screenY\n\011\011\011\011\011local w = sim.signs[i].width + 1\n\011\011\011\011\011local h = sim.signs[i].height\n\011\011\011\011\011if util.inside_rect(x, y, w, h, self.pos_x_, self.pos_y_) then\n\011\011\011\011\011\011if t:match(\"^{b|.*}$\") then\n\011\011\011\011\011\011\011self:report_sparksign_(sim.signs[i].x, sim.signs[i].y)\n\011\011\011\011\011\011end\n\011\011\011\011\011\011if t:match(\"^{c:[0-9]+|.*}$\") then\n\011\011\011\011\011\011\011if self.client_ then\n\011\011\011\011\011\011\011\011self.placesave_open_ = true\n\011\011\011\011\011\011\011\011self:begin_placesave_size_(100, 100, true)\n\011\011\011\011\011\011\011end\n\011\011\011\011\011\011end\n\011\011\011\011\011end\n\011\011\011\011end\n\011\011\011end\n\011\011end\n\011\011if self.placing_zoom_ then\n\011\011\011self.placing_zoom_ = false\n\011\011\011self.draw_mode_ = \"points\"\n\011\011\011self:cancel_drawing_()\n\011\011elseif self.dragging_mouse_ then\n\011\011\011if self.select_mode_ ~= \"none\" then\n\011\011\011\011if reason == MOUSEUP_REASON_MOUSEUP then\n\011\011\011\011\011local x, y, w, h = util.corners_to_rect(self.sel_x1_, self.sel_y1_, self.sel_x2_, self.sel_y2_)\n\011\011\011\011\011if self.select_mode_ == \"place\" then\n\011\011\011\011\011\011if self.client_ then\n\011\011\011\011\011\011\011self:begin_placesave_size_(x, y)\n\011\011\011\011\011\011end\n\011\011\011\011\011elseif self.select_mode_ == \"copy\" then\n\011\011\011\011\011\011self.clipsize_x_ = w\n\011\011\011\011\011\011self.clipsize_y_ = h\n\011\011\011\011\011elseif self.select_mode_ == \"cut\" then\n\011\011\011\011\011\011self.clipsize_x_ = w\n\011\011\011\011\011\011self.clipsize_y_ = h\n\011\011\011\011\011\011self:report_clearrect_(x, y, w, h)\n\011\011\011\011\011elseif self.select_mode_ == \"stamp\" then\n\011\011\011\011\011\011-- * Nothing.\n\011\011\011\011\011end\n\011\011\011\011end\n\011\011\011\011self.select_mode_ = \"none\"\n\011\011\011\011self:cancel_drawing_()\n\011\011\011\011return\n\011\011\011end\n\011\011\011if reason == MOUSEUP_REASON_MOUSEUP then\n\011\011\011\011if self.draw_mode_ == \"rect\" then\n\011\011\011\011\011self:report_rectend_(self.pos_x_, self.pos_y_)\n\011\011\011\011end\n\011\011\011\011if self.draw_mode_ == \"line\" then\n\011\011\011\011\011self:report_lineend_(self.pos_x_, self.pos_y_)\n\011\011\011\011end\n\011\011\011\011if self.draw_mode_ == \"flood\" then\n\011\011\011\011\011self:report_flood_(self.last_toolslot_, self.pos_x_, self.pos_y_)\n\011\011\011\011end\n\011\011\011\011if self.draw_mode_ == \"points\" then\n\011\011\011\011\011self:report_pointscont_(self.pos_x_, self.pos_y_, true)\n\011\011\011\011end\n\011\011\011end\n\011\011\011self:cancel_drawing_()\n\011\011elseif self.select_mode_ ~= \"none\" and button ~= 1 then\n\011\011\011if reason == MOUSEUP_REASON_MOUSEUP then\n\011\011\011\011self.select_mode_ = \"none\"\n\011\011\011end\n\011\011end\n\011\011self:update_draw_mode_()\n\011end\n\011\n\011function profile_i:handle_mousewheel(px, py, dir)\n\011\011self:post_event_check_()\n\011\011self:update_pos_(px, py)\n\011\011-- * Here the assumption is made that no Lua hook cancels the mousewheel event.\n\011\011if self.placing_zoom_ then\n\011\011\011self.zoom_invalid_ = true\n\011\011end\n\011end\n\011\n\011function profile_i:handle_keypress(key, scan, rep, shift, ctrl, alt)\n\011\011self:post_event_check_()\n\011\011if shift and not self.kmod_s_ then\n\011\011\011self:enable_shift_()\n\011\011end\n\011\011if ctrl and not self.kmod_c_ then\n\011\011\011self:enable_ctrl_()\n\011\011end\n\011\011if alt and not self.kmod_a_ then\n\011\011\011self:enable_alt_()\n\011\011end\n\011\011self:update_kmod_()\n\011\011-- * Here the assumption is made that no Lua hook cancels the keypress event.\n\011\011if not rep then\n\011\011\011if not self.stk2_out_ or ctrl then\n\011\011\011\011if scan == sdl.SDL_SCANCODE_W then\n\011\011\011\011\011self.simstate_invalid_ = true\n\011\011\011\011elseif scan == sdl.SDL_SCANCODE_S then\n\011\011\011\011\011self.select_mode_ = \"stamp\"\n\011\011\011\011\011self:cancel_drawing_()\n\011\011\011\011end\n\011\011\011end\n\011\011end\n\011\011-- * Here the assumption is made that no debug hook cancels the keypress event.\n\011\011if self.select_mode_ == \"place\" then\n\011\011\011-- * Note: Sadly, there's absolutely no way to know how these operations\n\011\011\011--         affect the save being placed, as it only grows if particles\n\011\011\011--         in it would go beyond its border.\n\011\011\011if key == sdl.SDLK_RIGHT then\n\011\011\011\011-- * Move. See note above.\n\011\011\011\011return\n\011\011\011elseif key == sdl.SDLK_LEFT then\n\011\011\011\011-- * Move. See note above.\n\011\011\011\011return\n\011\011\011elseif key == sdl.SDLK_DOWN then\n\011\011\011\011-- * Move. See note above.\n\011\011\011\011return\n\011\011\011elseif key == sdl.SDLK_UP then\n\011\011\011\011-- * Move. See note above.\n\011\011\011\011return\n\011\011\011elseif scan == sdl.SDL_SCANCODE_R and not rep then\n\011\011\011\011if ctrl and shift then\n\011\011\011\011\011-- * Rotate. See note above.\n\011\011\011\011elseif not ctrl and shift then\n\011\011\011\011\011-- * Rotate. See note above.\n\011\011\011\011else\n\011\011\011\011\011-- * Rotate. See note above.\n\011\011\011\011end\n\011\011\011\011return\n\011\011\011end\n\011\011end\n\011\011if rep then\n\011\011\011return\n\011\011end\n\011\011local did_shortcut = true\n\011\011if scan == sdl.SDL_SCANCODE_SPACE then\n\011\011\011self.simstate_invalid_ = true\n\011\011elseif scan == sdl.SDL_SCANCODE_GRAVE then\n\011\011\011if self.registered_func_() and not alt then\n\011\011\011\011self.log_event_func_(\"The console is disabled because it does not sync (press the Alt key to override)\")\n\011\011\011\011return true\n\011\011\011end\n\011\011elseif scan == sdl.SDL_SCANCODE_Z then\n\011\011\011if self.select_mode_ == \"none\" or not self.dragging_mouse_ then\n\011\011\011\011if ctrl and not self.dragging_mouse_ then\n\011\011\011\011\011if self.registered_func_() and not alt then\n\011\011\011\011\011\011self.log_event_func_(\"Undo is disabled because it does not sync (press the Alt key to override)\")\n\011\011\011\011\011\011return true\n\011\011\011\011\011end\n\011\011\011\011else\n\011\011\011\011\011self:cancel_drawing_()\n\011\011\011\011\011self.placing_zoom_ = true\n\011\011\011\011\011self.zoom_invalid_ = true\n\011\011\011\011end\n\011\011\011end\n\011\011elseif scan == sdl.SDL_SCANCODE_F5 or (ctrl and scan == sdl.SDL_SCANCODE_R) then\n\011\011\011self:button_reload_()\n\011\011elseif scan == sdl.SDL_SCANCODE_F and not ctrl then\n\011\011\011if ren.debugHUD() == 1 and (shift or alt) then\n\011\011\011\011if self.registered_func_() and not alt then\n\011\011\011\011\011self.log_event_func_(\"Partial framesteps do not sync, you will have to use /sync\")\n\011\011\011\011end\n\011\011\011end\n\011\011\011self:report_framestep_()\n\011\011\011self.simstate_invalid_ = true\n\011\011elseif scan == sdl.SDL_SCANCODE_B and not ctrl then\n\011\011\011self.simstate_invalid_ = true\n\011\011elseif scan == sdl.SDL_SCANCODE_Y then\n\011\011\011if ctrl then\n\011\011\011\011if self.registered_func_() and not alt then\n\011\011\011\011\011self.log_event_func_(\"Redo is disabled because it does not sync (press the Alt key to override)\")\n\011\011\011\011\011return true\n\011\011\011\011end\n\011\011\011else\n\011\011\011\011self.simstate_invalid_ = true\n\011\011\011end\n\011\011elseif scan == sdl.SDL_SCANCODE_U then\n\011\011\011if ctrl then\n\011\011\011\011self:report_reset_airtemp_()\n\011\011\011else\n\011\011\011\011self.simstate_invalid_ = true\n\011\011\011end\n\011\011elseif scan == sdl.SDL_SCANCODE_N then\n\011\011\011self.simstate_invalid_ = true\n\011\011elseif scan == sdl.SDL_SCANCODE_EQUALS then\n\011\011\011if ctrl then\n\011\011\011\011self:report_reset_spark_()\n\011\011\011else\n\011\011\011\011self:report_reset_air_()\n\011\011\011end\n\011\011elseif scan == sdl.SDL_SCANCODE_C and ctrl then\n\011\011\011self.select_mode_ = \"copy\"\n\011\011\011self:cancel_drawing_()\n\011\011elseif scan == sdl.SDL_SCANCODE_X and ctrl then\n\011\011\011self.select_mode_ = \"cut\"\n\011\011\011self:cancel_drawing_()\n\011\011elseif scan == sdl.SDL_SCANCODE_V and ctrl then\n\011\011\011if self.clipsize_x_ then\n\011\011\011\011self.select_mode_ = \"place\"\n\011\011\011\011self:cancel_drawing_()\n\011\011\011\011self.place_x_, self.place_y_ = self.clipsize_x_, self.clipsize_y_\n\011\011\011end\n\011\011elseif scan == sdl.SDL_SCANCODE_L then\n\011\011\011self.select_mode_ = \"place\"\n\011\011\011self:cancel_drawing_()\n\011\011\011self.want_stamp_size_ = true\n\011\011elseif scan == sdl.SDL_SCANCODE_K then\n\011\011\011self.select_mode_ = \"place\"\n\011\011\011self:cancel_drawing_()\n\011\011\011self.want_stamp_size_ = true\n\011\011elseif scan == sdl.SDL_SCANCODE_RIGHTBRACKET then\n\011\011\011if self.placing_zoom_ then\n\011\011\011\011self.zoom_invalid_ = true\n\011\011\011end\n\011\011elseif scan == sdl.SDL_SCANCODE_LEFTBRACKET then\n\011\011\011if self.placing_zoom_ then\n\011\011\011\011self.zoom_invalid_ = true\n\011\011\011end\n\011\011elseif scan == sdl.SDL_SCANCODE_I and not ctrl then\n\011\011\011self:report_airinvert_()\n\011\011elseif scan == sdl.SDL_SCANCODE_SEMICOLON then\n\011\011\011if self.client_ then\n\011\011\011\011self.bmode_invalid_ = true\n\011\011\011end\n\011\011end\n\011\011if key == sdl.SDLK_INSERT or key == sdl.SDLK_DELETE then\n\011\011\011if self.client_ then\n\011\011\011\011self.bmode_invalid_ = true\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function profile_i:handle_keyrelease(key, scan, rep, shift, ctrl, alt)\n\011\011self:post_event_check_()\n\011\011if not shift and self.kmod_s_ then\n\011\011\011self:disable_shift_()\n\011\011end\n\011\011if not ctrl and self.kmod_c_ then\n\011\011\011self:disable_ctrl_()\n\011\011end\n\011\011if not alt and self.kmod_a_ then\n\011\011\011self:disable_alt_()\n\011\011end\n\011\011self:update_kmod_()\n\011\011-- * Here the assumption is made that no Lua hook cancels the keyrelease event.\n\011\011-- * Here the assumption is made that no debug hook cancels the keyrelease event.\n\011\011if rep then\n\011\011\011return\n\011\011end\n\011\011if scan == sdl.SDL_SCANCODE_Z then\n\011\011\011if self.placing_zoom_ and not alt then\n\011\011\011\011self.placing_zoom_ = false\n\011\011\011\011self.zoom_invalid_ = true\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function profile_i:handle_textinput(text)\n\011\011self:post_event_check_()\n\011end\n\011\n\011function profile_i:handle_textediting(text)\n\011\011self:post_event_check_()\n\011end\n\011\n\011function profile_i:handle_blur()\n\011\011self:post_event_check_()\n\011\011for _, btn in pairs(self.buttons_) do\n\011\011\011btn.active = false\n\011\011end\n\011\011if self[index_to_lrax[self.last_toolslot_]] == util.from_tool.DEFAULT_UI_SIGN then\n\011\011\011self.signs_invalid_ = get_sign_data()\n\011\011end\n\011\011self:disable_shift_()\n\011\011self:disable_ctrl_()\n\011\011self:disable_alt_()\n\011\011self:update_kmod_()\n\011\011self:cancel_drawing_()\n\011\011self.draw_mode_ = \"points\"\n\011end\n\011\n\011function profile_i:should_ignore_mouse()\n\011\011return self.placing_zoom_ or self.select_mode_ ~= \"none\"\n\011end\n\011\n\011function profile_i:button_open_()\n\011\011if self.client_ then\n\011\011\011self.placesave_open_ = true\n\011\011\011self:begin_placesave_size_(100, 100, true)\n\011\011end\n\011end\n\011\n\011function profile_i:button_reload_()\n\011\011if self.client_ then\n\011\011\011self.placesave_reload_ = true\n\011\011\011self:begin_placesave_size_(100, 100, true)\n\011\011end\n\011end\n\011\n\011function profile_i:button_clear_()\n\011\011if self.client_ then\n\011\011\011self.placesave_clear_ = true\n\011\011\011self:begin_placesave_size_(100, 100, true)\n\011\011end\n\011end\n\011\n\011function profile_i:set_client(client)\n\011\011self.client_ = client\n\011\011self.bmode_invalid_ = true\n\011\011self.set_id_func_(util.get_save_id())\n\011end\n\011\n\011function profile_i:clear_client()\n\011\011self.client_ = nil\n\011end\n\011\n\011local function new(params)\n\011\011local prof = setmetatable({\n\011\011\011placing_zoom_ = false,\n\011\011\011kmod_c_ = false,\n\011\011\011kmod_s_ = false,\n\011\011\011kmod_a_ = false,\n\011\011\011bmode_ = 0,\n\011\011\011dragging_mouse_ = false,\n\011\011\011select_mode_ = \"none\",\n\011\011\011prev_select_mode_ = false,\n\011\011\011prev_place_mode_ = false,\n\011\011\011draw_mode_ = \"points\",\n\011\011\011last_toolslot_ = 0,\n\011\011\011shape_ = 0,\n\011\011\011stk2_out_ = false,\n\011\011\011perfect_circle_invalid_ = true,\n\011\011\011registered_func_ = params.registered_func,\n\011\011\011log_event_func_ = params.log_event_func,\n\011\011\011set_id_func_ = params.set_id_func,\n\011\011\011get_id_func_ = params.get_id_func,\n\011\011\011display_toolwarn_ = {},\n\011\011\011buttons_ = {\n\011\011\011\011open   = { x =               1, y = gfx.HEIGHT - 16, w = 17, h = 15 },\n\011\011\011\011reload = { x =              19, y = gfx.HEIGHT - 16, w = 17, h = 15 },\n\011\011\011\011clear  = { x = gfx.WIDTH - 159, y = gfx.HEIGHT - 16, w = 17, h = 15 },\n\011\011\011},\n\011\011}, profile_m)\n\011\011prof.tool_l_ = util.from_tool.UNKNOWN\n\011\011prof.tool_r_ = util.from_tool.UNKNOWN\n\011\011prof.tool_a_ = util.from_tool.UNKNOWN\n\011\011prof.tool_x_ = util.from_tool.UNKNOWN\n\011\011prof.last_tool_ = prof.tool_l_\n\011\011prof.deco_ = sim.decoColour()\n\011\011prof:update_pos_(tpt.mousex, tpt.mousey)\n\011\011prof:update_size_()\n\011\011prof:update_tools_()\n\011\011prof:update_deco_()\n\011\011prof:check_simstate()\n\011\011prof:update_kmod_()\n\011\011prof:update_bmode_()\n\011\011prof:update_shape_()\n\011\011prof:update_zoom_()\n\011\011prof:check_signs({})\n\011\011if false then\n\011\011\011prof.debug_ = function(...)\n\011\011\011\011print(\"[prof debug]\", ...)\n\011\011\011end\n\011\011end\n\011\011return prof\n\011end\n\011\n\011return {\n\011\011new = new,\n\011\011brand = \"vanilla\",\n\011\011profile_i = profile_i,\n\011}\n\011\nend\n\nrequire_preload__[\"tptmp.client.sdl\"] = function()\n\n\011-- * TODO[api]: get these from tpt\n\011return {\n\011    SDL_SCANCODE_A            =   4,\n\011    SDL_SCANCODE_B            =   5,\n\011    SDL_SCANCODE_C            =   6,\n\011    SDL_SCANCODE_F            =   9,\n\011    SDL_SCANCODE_I            =  12,\n\011    SDL_SCANCODE_K            =  14,\n\011    SDL_SCANCODE_L            =  15,\n\011    SDL_SCANCODE_N            =  17,\n\011    SDL_SCANCODE_R            =  21,\n\011    SDL_SCANCODE_S            =  22,\n\011    SDL_SCANCODE_T            =  23,\n\011    SDL_SCANCODE_U            =  24,\n\011    SDL_SCANCODE_V            =  25,\n\011    SDL_SCANCODE_W            =  26,\n\011    SDL_SCANCODE_X            =  27,\n\011    SDL_SCANCODE_Y            =  28,\n\011    SDL_SCANCODE_Z            =  29,\n\011    SDL_SCANCODE_RETURN       =  40,\n\011    SDL_SCANCODE_ESCAPE       =  41,\n\011    SDL_SCANCODE_BACKSPACE    =  42,\n\011    SDL_SCANCODE_TAB          =  43,\n\011    SDL_SCANCODE_SPACE        =  44,\n\011    SDL_SCANCODE_EQUALS       =  46,\n\011    SDL_SCANCODE_LEFTBRACKET  =  47,\n\011    SDL_SCANCODE_RIGHTBRACKET =  48,\n\011    SDL_SCANCODE_SEMICOLON    =  51,\n\011    SDL_SCANCODE_GRAVE        =  53,\n\011    SDL_SCANCODE_F5           =  62,\n\011    SDL_SCANCODE_HOME         =  74,\n\011    SDL_SCANCODE_DELETE       =  76,\n\011    SDL_SCANCODE_END          =  77,\n\011    SDL_SCANCODE_RIGHT        =  79,\n\011    SDL_SCANCODE_LEFT         =  80,\n\011    SDL_SCANCODE_DOWN         =  81,\n\011    SDL_SCANCODE_UP           =  82,\n\011    SDL_SCANCODE_LCTRL        = 224,\n\011    SDL_SCANCODE_LSHIFT       = 225,\n\011    SDL_SCANCODE_LALT         = 226,\n\011    SDL_SCANCODE_RCTRL        = 228,\n\011    SDL_SCANCODE_RSHIFT       = 229,\n\011    SDL_SCANCODE_RALT         = 230,\n\011    SDLK_DELETE               = 127,\n\011    SDLK_INSERT               = 0x40000000 + 73,\n\011    SDLK_RIGHT                = 0x40000000 + 79,\n\011    SDLK_LEFT                 = 0x40000000 + 80,\n\011    SDLK_DOWN                 = 0x40000000 + 81,\n\011    SDLK_UP                   = 0x40000000 + 82,\n\011    SDL_BUTTON_LEFT           = 1,\n\011    SDL_BUTTON_MIDDLE         = 2,\n\011    SDL_BUTTON_RIGHT          = 3,\n\011}\n\011\nend\n\nrequire_preload__[\"tptmp.client.side_button\"] = function()\n\n\011local colours = require(\"tptmp.client.colours\")\n\011local util    = require(\"tptmp.client.util\")\n\011local utf8    = require(\"tptmp.client.utf8\")\n\011local config  = require(\"tptmp.client.config\")\n\011local manager = require(\"tptmp.client.manager\")\n\011local sdl     = require(\"tptmp.client.sdl\")\n\011\n\011local side_button_i = {}\n\011local side_button_m = { __index = side_button_i }\n\011\n\011function side_button_i:draw_button_()\n\011\011local inside = util.inside_rect(self.pos_x_, self.pos_y_, self.width_, self.height_, util.mouse_pos())\n\011\011if self.active_ and not inside then\n\011\011\011self.active_ = false\n\011\011end\n\011\011local state\n\011\011if self.active_ or self.window_status_func_() == \"shown\" then\n\011\011\011state = \"active\"\n\011\011elseif inside then\n\011\011\011state = \"hover\"\n\011\011else\n\011\011\011state = \"inactive\"\n\011\011end\n\011\011local text_colour = colours.appearance[state].text\n\011\011local border_colour = colours.appearance[state].border\n\011\011local background_colour = colours.appearance[state].background\n\011\011gfx.fillRect(self.pos_x_ + 1, self.pos_y_ + 1, self.width_ - 2, self.height_ - 2, unpack(background_colour))\n\011\011gfx.drawRect(self.pos_x_, self.pos_y_, self.width_, self.height_, unpack(border_colour))\n\011\011gfx.drawText(self.tx_, self.ty_, self.text_, unpack(text_colour))\n\011end\n\011\n\011function side_button_i:update_notif_count_()\n\011\011local notif_count = self.notif_count_func_()\n\011\011local notif_important = self.notif_important_func_()\n\011\011if self.notif_count_ ~= notif_count or self.notif_important_ ~= notif_important then\n\011\011\011self.notif_count_ = notif_count\n\011\011\011self.notif_important_ = notif_important\n\011\011\011local notif_count_str = tostring(self.notif_count_)\n\011\011\011self.notif_background_ = utf8.encode_multiple(0xE03B, 0xE039) .. utf8.encode_multiple(0xE03C):rep(#notif_count_str - 1) .. utf8.encode_multiple(0xE03A)\n\011\011\011self.notif_border_ = utf8.encode_multiple(0xE02D, 0xE02B) .. utf8.encode_multiple(0xE02E):rep(#notif_count_str - 1) .. utf8.encode_multiple(0xE02C)\n\011\011\011self.notif_text_ = notif_count_str:gsub(\".\", function(ch)\n\011\011\011\011return utf8.encode_multiple(ch:byte() + 0xDFFF)\n\011\011\011end)\n\011\011\011self.notif_width_ = gfx.textSize(self.notif_background_)\n\011\011\011self.notif_last_change_ = socket.gettime()\n\011\011end\n\011end\n\011\n\011function side_button_i:draw_notif_count_()\n\011\011if self.notif_count_ > 0 then\n\011\011\011local since_last_change = socket.gettime() - self.notif_last_change_\n\011\011\011local fly = since_last_change > config.notif_fly_time and 0 or ((1 - since_last_change / config.notif_fly_time) * config.notif_fly_distance)\n\011\011\011gfx.drawText(self.pos_x_ - self.notif_width_ + 4, self.pos_y_ - 4 - fly, self.notif_background_, unpack(self.notif_important_ and colours.common.notif_important or colours.common.notif_normal))\n\011\011\011gfx.drawText(self.pos_x_ - self.notif_width_ + 4, self.pos_y_ - 4 - fly, self.notif_border_)\n\011\011\011gfx.drawText(self.pos_x_ - self.notif_width_ + 7, self.pos_y_ - 4 - fly, self.notif_text_)\n\011\011end\n\011end\n\011\n\011function side_button_i:handle_tick()\n\011\011self:draw_button_()\n\011\011self:update_notif_count_()\n\011\011self:draw_notif_count_()\n\011end\n\011\n\011function side_button_i:handle_mousedown(mx, my, button)\n\011\011if button == sdl.SDL_BUTTON_LEFT then\n\011\011\011if util.inside_rect(self.pos_x_, self.pos_y_, self.width_, self.height_, util.mouse_pos()) then\n\011\011\011\011self.active_ = true\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function side_button_i:handle_mouseup(mx, my, button)\n\011\011if button == sdl.SDL_BUTTON_LEFT then\n\011\011\011if self.active_ then\n\011\011\011\011if manager.minimize_conflict and not manager.hidden() then\n\011\011\011\011\011manager.print(\"minimize the manager before opening TPTMP\")\n\011\011\011\011else\n\011\011\011\011\011if self.window_status_func_() == \"shown\" then\n\011\011\011\011\011\011self.hide_window_func_()\n\011\011\011\011\011else\n\011\011\011\011\011\011self.show_window_func_()\n\011\011\011\011\011end\n\011\011\011\011end\n\011\011\011\011self.active_ = false\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function side_button_i:handle_mousewheel(pos_x, pos_y, dir)\n\011end\n\011\n\011function side_button_i:handle_keypress(key, scan, rep, shift, ctrl, alt)\n\011\011if shift and not ctrl and not alt and scan == sdl.SDL_SCANCODE_ESCAPE then\n\011\011\011self.show_window_func_()\n\011\011\011return true\n\011\011elseif alt and not ctrl and not shift and scan == sdl.SDL_SCANCODE_S then\n\011\011\011self.sync_func_()\n\011\011\011return true\n\011\011elseif not alt and not ctrl and not shift and scan == sdl.SDL_SCANCODE_T and self.window_status_func_() == \"floating\" then\n\011\011\011self.begin_chat_func_()\n\011\011\011return true\n\011\011end\n\011end\n\011\n\011function side_button_i:handle_keyrelease(key, scan, rep, shift, ctrl, alt)\n\011end\n\011\n\011function side_button_i:handle_textinput(text)\n\011end\n\011\n\011function side_button_i:handle_textediting(text)\n\011end\n\011\n\011function side_button_i:handle_blur()\n\011\011self.active_ = false\n\011end\n\011\n\011local function new(params)\n\011\011local pos_x, pos_y, width, height = 613, 136, 15, 15\n\011\011if tpt.version.jacob1s_mod and tpt.oldmenu and tpt.oldmenu() == 1 then\n\011\011\011pos_y = 392\n\011\011elseif tpt.num_menus then\n\011\011\011pos_y = 392 - 16 * tpt.num_menus() - (not tpt.version.jacob1s_mod and 16 or 0)\n\011\011end\n\011\011if manager.side_button_conflict then\n\011\011\011pos_y = pos_y - 17\n\011\011end\n\011\011local text = \"<<\"\n\011\011local tw, th = gfx.textSize(text)\n\011\011local tx = pos_x + math.ceil((width - tw) / 2)\n\011\011local ty = pos_y + math.floor((height - th) / 2)\n\011\011return setmetatable({\n\011\011\011text_ = text,\n\011\011\011tx_ = tx,\n\011\011\011pos_x_ = pos_x,\n\011\011\011ty_ = ty,\n\011\011\011pos_y_ = pos_y,\n\011\011\011width_ = width,\n\011\011\011height_ = height,\n\011\011\011active_ = false,\n\011\011\011notif_last_change_ = 0,\n\011\011\011notif_count_ = 0,\n\011\011\011notif_important_ = false,\n\011\011\011notif_count_func_ = params.notif_count_func,\n\011\011\011notif_important_func_ = params.notif_important_func,\n\011\011\011show_window_func_ = params.show_window_func,\n\011\011\011hide_window_func_ = params.hide_window_func,\n\011\011\011begin_chat_func_ = params.begin_chat_func,\n\011\011\011window_status_func_ = params.window_status_func,\n\011\011\011sync_func_ = params.sync_func,\n\011\011}, side_button_m)\n\011end\n\011\n\011return {\n\011\011new = new,\n\011}\n\011\nend\n\nrequire_preload__[\"tptmp.client.utf8\"] = function()\n\n\011local function code_points(str)\n\011\011local cps = {}\n\011\011local cursor = 0\n\011\011while true do\n\011\011\011local old_cursor = cursor\n\011\011\011cursor = cursor + 1\n\011\011\011local head = str:byte(cursor)\n\011\011\011if not head then\n\011\011\011\011break\n\011\011\011end\n\011\011\011local size = 1\n\011\011\011if head >= 0x80 then\n\011\011\011\011if head < 0xC0 then\n\011\011\011\011\011return nil, cursor\n\011\011\011\011end\n\011\011\011\011size = 2\n\011\011\011\011if head >= 0xE0 then\n\011\011\011\011\011size = 3\n\011\011\011\011end\n\011\011\011\011if head >= 0xF0 then\n\011\011\011\011\011size = 4\n\011\011\011\011end\n\011\011\011\011if head >= 0xF8 then\n\011\011\011\011\011return nil, cursor\n\011\011\011\011end\n\011\011\011\011head = bit.band(head, bit.lshift(1, 7 - size) - 1)\n\011\011\011\011for ix = 2, size do\n\011\011\011\011\011local by = str:byte(cursor + ix - 1)\n\011\011\011\011\011if not by then\n\011\011\011\011\011\011return nil, cursor\n\011\011\011\011\011end\n\011\011\011\011\011if by < 0x80 or by >= 0xC0 then\n\011\011\011\011\011\011return nil, cursor + ix\n\011\011\011\011\011end\n\011\011\011\011\011head = bit.bor(bit.lshift(head, 6), bit.band(by, 0x3F))\n\011\011\011\011end\n\011\011\011\011cursor = cursor - 1 + size\n\011\011\011end\n\011\011\011local pos = old_cursor + 1\n\011\011\011if (head < 0x80 and size > 1)\n\011\011\011or (head < 0x800 and size > 2)\n\011\011\011or (head < 0x10000 and size > 3) then\n\011\011\011\011return nil, pos\n\011\011\011end\n\011\011\011table.insert(cps, { cp = head, pos = pos, size = size })\n\011\011end\n\011\011return cps\n\011end\n\011\n\011local function encode(code_point)\n\011\011if code_point < 0x80 then\n\011\011\011return string.char(code_point)\n\011\011elseif code_point < 0x800 then\n\011\011\011return string.char(\n\011\011\011\011bit.bor(0xC0,          bit.rshift(code_point,  6)       ),\n\011\011\011\011bit.bor(0x80, bit.band(           code_point     , 0x3F))\n\011\011\011)\n\011\011elseif code_point < 0x10000 then\n\011\011\011return string.char(\n\011\011\011\011bit.bor(0xE0,          bit.rshift(code_point, 12)       ),\n\011\011\011\011bit.bor(0x80, bit.band(bit.rshift(code_point,  6), 0x3F)),\n\011\011\011\011bit.bor(0x80, bit.band(           code_point     , 0x3F))\n\011\011\011)\n\011\011elseif code_point < 0x200000 then\n\011\011\011return string.char(\n\011\011\011\011bit.bor(0xF0,          bit.rshift(code_point, 18)       ),\n\011\011\011\011bit.bor(0x80, bit.band(bit.rshift(code_point, 12), 0x3F)),\n\011\011\011\011bit.bor(0x80, bit.band(bit.rshift(code_point,  6), 0x3F)),\n\011\011\011\011bit.bor(0x80, bit.band(           code_point     , 0x3F))\n\011\011\011)\n\011\011else\n\011\011\011error(\"invalid code point\")\n\011\011end\n\011end\n\011\n\011local function encode_multiple(cp, ...)\n\011\011if not ... then\n\011\011\011return encode(cp)\n\011\011end\n\011\011local cps = { cp, ... }\n\011\011local collect = {}\n\011\011for i = 1, #cps do\n\011\011\011table.insert(collect, encode(cps[i]))\n\011\011end\n\011\011return table.concat(collect)\n\011end\n\011\n\011if tpt.version.jacob1s_mod then\n\011\011function code_points(str)\n\011\011\011local cps = {}\n\011\011\011for pos in str:gmatch(\"().\") do\n\011\011\011\011table.insert(cps, { cp = str:byte(pos), pos = pos, size = 1 })\n\011\011\011end\n\011\011\011return cps\n\011\011end\n\011\n\011\011function encode(cp)\n\011\011\011if cp >= 0xE000 then\n\011\011\011\011cp = cp - 0xDF80\n\011\011\011end\n\011\011\011return string.char(cp)\n\011\011end\n\011end\n\011\n\011return {\n\011\011code_points = code_points,\n\011\011encode = encode,\n\011\011encode_multiple = encode_multiple,\n\011}\n\011\nend\n\nrequire_preload__[\"tptmp.client.util\"] = function()\n\n\011local config      = require(\"tptmp.client.config\")\n\011local common_util = require(\"tptmp.common.util\")\n\011\n\011local jacobsmod = rawget(_G, \"jacobsmod\")\n\011local from_tool = {}\n\011local to_tool = {}\n\011local xid_first = {}\n\011local PMAPBITS = sim.PMAPBITS\n\011\n\011local tpt_version = { tpt.version.major, tpt.version.minor }\n\011local has_ambient_heat_tools\n\011do\n\011\011local old_selectedl = tpt.selectedl\n\011\011if old_selectedl == \"DEFAULT_UI_PROPERTY\" or old_selectedl == \"DEFAULT_UI_ADDLIFE\" then\n\011\011\011old_selectedl = \"DEFAULT_PT_DUST\"\n\011\011end\n\011\011has_ambient_heat_tools = pcall(function() tpt.selectedl = \"DEFAULT_TOOL_AMBM\" end)\n\011\011tpt.selectedl = old_selectedl\n\011end\n\011\n\011local function array_concat(...)\n\011\011local tbl = {}\n\011\011local arrays = { ... }\n\011\011for i = 1, #arrays do\n\011\011\011for j = 1, #arrays[i] do\n\011\011\011\011table.insert(tbl, arrays[i][j])\n\011\011\011end\n\011\011end\n\011\011return tbl\n\011end\n\011\n\011local function array_keyify(arr)\n\011\011local tbl = {}\n\011\011for i = 1, #arr do\n\011\011\011tbl[arr[i]] = true\n\011\011end\n\011\011return tbl\n\011end\n\011\n\011local tools = array_concat({\n\011\011\"DEFAULT_PT_LIFE_GOL\",\n\011\011\"DEFAULT_PT_LIFE_HLIF\",\n\011\011\"DEFAULT_PT_LIFE_ASIM\",\n\011\011\"DEFAULT_PT_LIFE_2X2\",\n\011\011\"DEFAULT_PT_LIFE_DANI\",\n\011\011\"DEFAULT_PT_LIFE_AMOE\",\n\011\011\"DEFAULT_PT_LIFE_MOVE\",\n\011\011\"DEFAULT_PT_LIFE_PGOL\",\n\011\011\"DEFAULT_PT_LIFE_DMOE\",\n\011\011\"DEFAULT_PT_LIFE_3-4\",\n\011\011\"DEFAULT_PT_LIFE_LLIF\",\n\011\011\"DEFAULT_PT_LIFE_STAN\",\n\011\011\"DEFAULT_PT_LIFE_SEED\",\n\011\011\"DEFAULT_PT_LIFE_MAZE\",\n\011\011\"DEFAULT_PT_LIFE_COAG\",\n\011\011\"DEFAULT_PT_LIFE_WALL\",\n\011\011\"DEFAULT_PT_LIFE_GNAR\",\n\011\011\"DEFAULT_PT_LIFE_REPL\",\n\011\011\"DEFAULT_PT_LIFE_MYST\",\n\011\011\"DEFAULT_PT_LIFE_LOTE\",\n\011\011\"DEFAULT_PT_LIFE_FRG2\",\n\011\011\"DEFAULT_PT_LIFE_STAR\",\n\011\011\"DEFAULT_PT_LIFE_FROG\",\n\011\011\"DEFAULT_PT_LIFE_BRAN\",\n\011}, {\n\011\011\"DEFAULT_WL_ERASE\",\n\011\011\"DEFAULT_WL_CNDTW\",\n\011\011\"DEFAULT_WL_EWALL\",\n\011\011\"DEFAULT_WL_DTECT\",\n\011\011\"DEFAULT_WL_STRM\",\n\011\011\"DEFAULT_WL_FAN\",\n\011\011\"DEFAULT_WL_LIQD\",\n\011\011\"DEFAULT_WL_ABSRB\",\n\011\011\"DEFAULT_WL_WALL\",\n\011\011\"DEFAULT_WL_AIR\",\n\011\011\"DEFAULT_WL_POWDR\",\n\011\011\"DEFAULT_WL_CNDTR\",\n\011\011\"DEFAULT_WL_EHOLE\",\n\011\011\"DEFAULT_WL_GAS\",\n\011\011\"DEFAULT_WL_GRVTY\",\n\011\011\"DEFAULT_WL_ENRGY\",\n\011\011\"DEFAULT_WL_NOAIR\",\n\011\011\"DEFAULT_WL_ERASEA\",\n\011\011\"DEFAULT_WL_STASIS\",\n\011}, {\n\011\011\"DEFAULT_UI_SAMPLE\",\n\011\011\"DEFAULT_UI_SIGN\",\n\011\011\"DEFAULT_UI_PROPERTY\",\n\011\011\"DEFAULT_UI_WIND\",\n\011\011\"DEFAULT_UI_ADDLIFE\",\n\011}, {\n\011\011\"DEFAULT_TOOL_HEAT\",\n\011\011\"DEFAULT_TOOL_COOL\",\n\011\011\"DEFAULT_TOOL_AIR\",\n\011\011\"DEFAULT_TOOL_VAC\",\n\011\011\"DEFAULT_TOOL_PGRV\",\n\011\011\"DEFAULT_TOOL_NGRV\",\n\011\011\"DEFAULT_TOOL_MIX\",\n\011\011\"DEFAULT_TOOL_CYCL\",\n\011\011has_ambient_heat_tools and \"DEFAULT_TOOL_AMBM\" or nil,\n\011\011has_ambient_heat_tools and \"DEFAULT_TOOL_AMBP\" or nil,\n\011}, {\n\011\011\"DEFAULT_DECOR_SET\",\n\011\011\"DEFAULT_DECOR_CLR\",\n\011\011\"DEFAULT_DECOR_ADD\",\n\011\011\"DEFAULT_DECOR_SUB\",\n\011\011\"DEFAULT_DECOR_MUL\",\n\011\011\"DEFAULT_DECOR_DIV\",\n\011\011\"DEFAULT_DECOR_SMDG\",\n\011})\n\011local xid_class = {}\n\011for i = 1, #tools do\n\011\011local xtype = 0x2000 + i\n\011\011local tool = tools[i]\n\011\011from_tool[tool] = xtype\n\011\011to_tool[xtype] = tool\n\011\011local class = tool:match(\"^[^_]+_(.-)_[^_]+$\")\n\011\011xid_class[xtype] = class\n\011\011xid_first[class] = math.min(xid_first[class] or math.huge, xtype)\n\011end\n\011-- * TODO[opt]: support custom elements\n\011local known_elements = array_keyify({\n\011\011\"DEFAULT_PT_NONE\",\n\011\011\"DEFAULT_PT_DUST\",\n\011\011\"DEFAULT_PT_WATR\",\n\011\011\"DEFAULT_PT_OIL\",\n\011\011\"DEFAULT_PT_FIRE\",\n\011\011\"DEFAULT_PT_STNE\",\n\011\011\"DEFAULT_PT_LAVA\",\n\011\011\"DEFAULT_PT_GUN\",\n\011\011\"DEFAULT_PT_GUNP\",\n\011\011\"DEFAULT_PT_NITR\",\n\011\011\"DEFAULT_PT_CLNE\",\n\011\011\"DEFAULT_PT_GAS\",\n\011\011\"DEFAULT_PT_C-4\",\n\011\011\"DEFAULT_PT_PLEX\",\n\011\011\"DEFAULT_PT_GOO\",\n\011\011\"DEFAULT_PT_ICE\",\n\011\011\"DEFAULT_PT_ICEI\",\n\011\011\"DEFAULT_PT_METL\",\n\011\011\"DEFAULT_PT_SPRK\",\n\011\011\"DEFAULT_PT_SNOW\",\n\011\011\"DEFAULT_PT_WOOD\",\n\011\011\"DEFAULT_PT_NEUT\",\n\011\011\"DEFAULT_PT_PLUT\",\n\011\011\"DEFAULT_PT_PLNT\",\n\011\011\"DEFAULT_PT_ACID\",\n\011\011\"DEFAULT_PT_VOID\",\n\011\011\"DEFAULT_PT_WTRV\",\n\011\011\"DEFAULT_PT_CNCT\",\n\011\011\"DEFAULT_PT_DSTW\",\n\011\011\"DEFAULT_PT_SALT\",\n\011\011\"DEFAULT_PT_SLTW\",\n\011\011\"DEFAULT_PT_DMND\",\n\011\011\"DEFAULT_PT_BMTL\",\n\011\011\"DEFAULT_PT_BRMT\",\n\011\011\"DEFAULT_PT_PHOT\",\n\011\011\"DEFAULT_PT_URAN\",\n\011\011\"DEFAULT_PT_WAX\",\n\011\011\"DEFAULT_PT_MWAX\",\n\011\011\"DEFAULT_PT_PSCN\",\n\011\011\"DEFAULT_PT_NSCN\",\n\011\011\"DEFAULT_PT_LNTG\",\n\011\011\"DEFAULT_PT_LN2\",\n\011\011\"DEFAULT_PT_INSL\",\n\011\011\"DEFAULT_PT_BHOL\",\n\011\011\"DEFAULT_PT_VACU\",\n\011\011\"DEFAULT_PT_WHOL\",\n\011\011\"DEFAULT_PT_VENT\",\n\011\011\"DEFAULT_PT_RBDM\",\n\011\011\"DEFAULT_PT_LRBD\",\n\011\011\"DEFAULT_PT_NTCT\",\n\011\011\"DEFAULT_PT_SAND\",\n\011\011\"DEFAULT_PT_GLAS\",\n\011\011\"DEFAULT_PT_PTCT\",\n\011\011\"DEFAULT_PT_BGLA\",\n\011\011\"DEFAULT_PT_THDR\",\n\011\011\"DEFAULT_PT_PLSM\",\n\011\011\"DEFAULT_PT_ETRD\",\n\011\011\"DEFAULT_PT_NICE\",\n\011\011\"DEFAULT_PT_NBLE\",\n\011\011\"DEFAULT_PT_BTRY\",\n\011\011\"DEFAULT_PT_LCRY\",\n\011\011\"DEFAULT_PT_STKM\",\n\011\011\"DEFAULT_PT_SWCH\",\n\011\011\"DEFAULT_PT_SMKE\",\n\011\011\"DEFAULT_PT_DESL\",\n\011\011\"DEFAULT_PT_COAL\",\n\011\011\"DEFAULT_PT_LO2\",\n\011\011\"DEFAULT_PT_LOXY\",\n\011\011\"DEFAULT_PT_O2\",\n\011\011\"DEFAULT_PT_OXYG\",\n\011\011\"DEFAULT_PT_INWR\",\n\011\011\"DEFAULT_PT_YEST\",\n\011\011\"DEFAULT_PT_DYST\",\n\011\011\"DEFAULT_PT_THRM\",\n\011\011\"DEFAULT_PT_GLOW\",\n\011\011\"DEFAULT_PT_BRCK\",\n\011\011\"DEFAULT_PT_HFLM\",\n\011\011\"DEFAULT_PT_CFLM\",\n\011\011\"DEFAULT_PT_FIRW\",\n\011\011\"DEFAULT_PT_FUSE\",\n\011\011\"DEFAULT_PT_FSEP\",\n\011\011\"DEFAULT_PT_AMTR\",\n\011\011\"DEFAULT_PT_BCOL\",\n\011\011\"DEFAULT_PT_PCLN\",\n\011\011\"DEFAULT_PT_HSWC\",\n\011\011\"DEFAULT_PT_IRON\",\n\011\011\"DEFAULT_PT_MORT\",\n\011\011\"DEFAULT_PT_LIFE\",\n\011\011\"DEFAULT_PT_DLAY\",\n\011\011\"DEFAULT_PT_CO2\",\n\011\011\"DEFAULT_PT_DRIC\",\n\011\011\"DEFAULT_PT_BUBW\",\n\011\011\"DEFAULT_PT_CBNW\",\n\011\011\"DEFAULT_PT_STOR\",\n\011\011\"DEFAULT_PT_PVOD\",\n\011\011\"DEFAULT_PT_CONV\",\n\011\011\"DEFAULT_PT_CAUS\",\n\011\011\"DEFAULT_PT_LIGH\",\n\011\011\"DEFAULT_PT_TESC\",\n\011\011\"DEFAULT_PT_DEST\",\n\011\011\"DEFAULT_PT_SPNG\",\n\011\011\"DEFAULT_PT_RIME\",\n\011\011\"DEFAULT_PT_FOG\",\n\011\011\"DEFAULT_PT_BCLN\",\n\011\011\"DEFAULT_PT_LOVE\",\n\011\011\"DEFAULT_PT_DEUT\",\n\011\011\"DEFAULT_PT_WARP\",\n\011\011\"DEFAULT_PT_PUMP\",\n\011\011\"DEFAULT_PT_FWRK\",\n\011\011\"DEFAULT_PT_PIPE\",\n\011\011\"DEFAULT_PT_FRZZ\",\n\011\011\"DEFAULT_PT_FRZW\",\n\011\011\"DEFAULT_PT_GRAV\",\n\011\011\"DEFAULT_PT_BIZR\",\n\011\011\"DEFAULT_PT_BIZG\",\n\011\011\"DEFAULT_PT_BIZRG\",\n\011\011\"DEFAULT_PT_BIZRS\",\n\011\011\"DEFAULT_PT_BIZS\",\n\011\011\"DEFAULT_PT_INST\",\n\011\011\"DEFAULT_PT_ISOZ\",\n\011\011\"DEFAULT_PT_ISZS\",\n\011\011\"DEFAULT_PT_PRTI\",\n\011\011\"DEFAULT_PT_PRTO\",\n\011\011\"DEFAULT_PT_PSTE\",\n\011\011\"DEFAULT_PT_PSTS\",\n\011\011\"DEFAULT_PT_ANAR\",\n\011\011\"DEFAULT_PT_VINE\",\n\011\011\"DEFAULT_PT_INVIS\",\n\011\011\"DEFAULT_PT_INVS\",\n\011\011\"DEFAULT_PT_116\",\n\011\011\"DEFAULT_PT_EQVE\",\n\011\011\"DEFAULT_PT_SPAWN2\",\n\011\011\"DEFAULT_PT_SPWN2\",\n\011\011\"DEFAULT_PT_SPWN\",\n\011\011\"DEFAULT_PT_SPAWN\",\n\011\011\"DEFAULT_PT_SHLD\",\n\011\011\"DEFAULT_PT_SHLD1\",\n\011\011\"DEFAULT_PT_SHLD2\",\n\011\011\"DEFAULT_PT_SHD2\",\n\011\011\"DEFAULT_PT_SHD3\",\n\011\011\"DEFAULT_PT_SHLD3\",\n\011\011\"DEFAULT_PT_SHLD4\",\n\011\011\"DEFAULT_PT_SHD4\",\n\011\011\"DEFAULT_PT_LOLZ\",\n\011\011\"DEFAULT_PT_WIFI\",\n\011\011\"DEFAULT_PT_FILT\",\n\011\011\"DEFAULT_PT_ARAY\",\n\011\011\"DEFAULT_PT_BRAY\",\n\011\011\"DEFAULT_PT_STKM2\",\n\011\011\"DEFAULT_PT_STK2\",\n\011\011\"DEFAULT_PT_BOMB\",\n\011\011\"DEFAULT_PT_C5\",\n\011\011\"DEFAULT_PT_C-5\",\n\011\011\"DEFAULT_PT_SING\",\n\011\011\"DEFAULT_PT_QRTZ\",\n\011\011\"DEFAULT_PT_PQRT\",\n\011\011\"DEFAULT_PT_EMP\",\n\011\011\"DEFAULT_PT_BREC\",\n\011\011\"DEFAULT_PT_BREL\",\n\011\011\"DEFAULT_PT_ELEC\",\n\011\011\"DEFAULT_PT_ACEL\",\n\011\011\"DEFAULT_PT_DCEL\",\n\011\011\"DEFAULT_PT_TNT\",\n\011\011\"DEFAULT_PT_BANG\",\n\011\011\"DEFAULT_PT_IGNT\",\n\011\011\"DEFAULT_PT_IGNC\",\n\011\011\"DEFAULT_PT_BOYL\",\n\011\011\"DEFAULT_PT_GEL\",\n\011\011\"DEFAULT_PT_TRON\",\n\011\011\"DEFAULT_PT_TTAN\",\n\011\011\"DEFAULT_PT_EXOT\",\n\011\011\"DEFAULT_PT_EMBR\",\n\011\011\"DEFAULT_PT_HYGN\",\n\011\011\"DEFAULT_PT_H2\",\n\011\011\"DEFAULT_PT_SOAP\",\n\011\011\"DEFAULT_PT_NBHL\",\n\011\011\"DEFAULT_PT_NWHL\",\n\011\011\"DEFAULT_PT_MERC\",\n\011\011\"DEFAULT_PT_PBCN\",\n\011\011\"DEFAULT_PT_GPMP\",\n\011\011\"DEFAULT_PT_CLST\",\n\011\011\"DEFAULT_PT_WWLD\",\n\011\011\"DEFAULT_PT_WIRE\",\n\011\011\"DEFAULT_PT_GBMB\",\n\011\011\"DEFAULT_PT_FIGH\",\n\011\011\"DEFAULT_PT_FRAY\",\n\011\011\"DEFAULT_PT_RPEL\",\n\011\011\"DEFAULT_PT_PPIP\",\n\011\011\"DEFAULT_PT_DTEC\",\n\011\011\"DEFAULT_PT_DMG\",\n\011\011\"DEFAULT_PT_TSNS\",\n\011\011\"DEFAULT_PT_VIBR\",\n\011\011\"DEFAULT_PT_BVBR\",\n\011\011\"DEFAULT_PT_CRAY\",\n\011\011\"DEFAULT_PT_PSTN\",\n\011\011\"DEFAULT_PT_FRME\",\n\011\011\"DEFAULT_PT_GOLD\",\n\011\011\"DEFAULT_PT_TUNG\",\n\011\011\"DEFAULT_PT_PSNS\",\n\011\011\"DEFAULT_PT_PROT\",\n\011\011\"DEFAULT_PT_VIRS\",\n\011\011\"DEFAULT_PT_VRSS\",\n\011\011\"DEFAULT_PT_VRSG\",\n\011\011\"DEFAULT_PT_GRVT\",\n\011\011\"DEFAULT_PT_DRAY\",\n\011\011\"DEFAULT_PT_CRMC\",\n\011\011\"DEFAULT_PT_HEAC\",\n\011\011\"DEFAULT_PT_SAWD\",\n\011\011\"DEFAULT_PT_POLO\",\n\011\011\"DEFAULT_PT_RFRG\",\n\011\011\"DEFAULT_PT_RFGL\",\n\011\011\"DEFAULT_PT_LSNS\",\n\011\011\"DEFAULT_PT_LDTC\",\n\011\011\"DEFAULT_PT_SLCN\",\n\011\011\"DEFAULT_PT_PTNM\",\n\011\011\"DEFAULT_PT_VSNS\",\n\011\011\"DEFAULT_PT_ROCK\",\n\011\011\"DEFAULT_PT_LITH\",\n\011})\n\011for key, value in pairs(elem) do\n\011\011if known_elements[key] then\n\011\011\011from_tool[key] = value\n\011\011\011to_tool[value] = key\n\011\011end\n\011end\n\011local unknown_xid = 0x3FFF\n\011assert(not to_tool[unknown_xid])\n\011from_tool[\"UNKNOWN\"] = unknown_xid\n\011to_tool[unknown_xid] = \"UNKNOWN\"\n\011\n\011local WL_FAN = from_tool.DEFAULT_WL_FAN - xid_first.WL\n\011\n\011local create_override = {\n\011\011[ from_tool.DEFAULT_PT_STKM ] = function(rx, ry, c)\n\011\011\011return 0, 0, c\n\011\011end,\n\011\011[ from_tool.DEFAULT_PT_LIGH ] = function(rx, ry, c)\n\011\011\011local tmp = rx + ry\n\011\011\011if tmp > 55 then\n\011\011\011\011tmp = 55\n\011\011\011end\n\011\011\011return 0, 0, c + bit.lshift(tmp, PMAPBITS)\n\011\011end,\n\011\011[ from_tool.DEFAULT_PT_TESC ] = function(rx, ry, c)\n\011\011\011local tmp = rx * 4 + ry * 4 + 7\n\011\011\011if tmp > 300 then\n\011\011\011\011tmp = 300\n\011\011\011end\n\011\011\011return rx, ry, c + bit.lshift(tmp, PMAPBITS)\n\011\011end,\n\011\011[ from_tool.DEFAULT_PT_STKM2 ] = function(rx, ry, c)\n\011\011\011return 0, 0, c\n\011\011end,\n\011\011[ from_tool.DEFAULT_PT_FIGH ] = function(rx, ry, c)\n\011\011\011return 0, 0, c\n\011\011end,\n\011}\n\011local no_flood = {\n\011\011[ from_tool.DEFAULT_PT_SPRK  ] = true,\n\011\011[ from_tool.DEFAULT_PT_STKM  ] = true,\n\011\011[ from_tool.DEFAULT_PT_LIGH  ] = true,\n\011\011[ from_tool.DEFAULT_PT_STKM2 ] = true,\n\011\011[ from_tool.DEFAULT_PT_FIGH  ] = true,\n\011}\n\011local no_shape = {\n\011\011[ from_tool.DEFAULT_PT_STKM  ] = true,\n\011\011[ from_tool.DEFAULT_PT_LIGH  ] = true,\n\011\011[ from_tool.DEFAULT_PT_STKM2 ] = true,\n\011\011[ from_tool.DEFAULT_PT_FIGH  ] = true,\n\011}\n\011local no_create = {\n\011\011[ from_tool.DEFAULT_UI_PROPERTY ] = true,\n\011\011[ from_tool.DEFAULT_UI_SAMPLE   ] = true,\n\011\011[ from_tool.DEFAULT_UI_SIGN     ] = true,\n\011\011[ from_tool.UNKNOWN             ] = true,\n\011}\n\011local line_only = {\n\011\011[ from_tool.DEFAULT_UI_WIND ] = true,\n\011}\n\011\n\011local function heat_clear()\n\011\011local temp = sim.ambientAirTemp()\n\011\011for x = 0, sim.XRES / sim.CELL - 1 do\n\011\011\011for y = 0, sim.YRES / sim.CELL - 1 do\n\011\011\011\011sim.ambientHeat(x, y, temp)\n\011\011\011end\n\011\011end\n\011end\n\011\n\011local function stamp_load(x, y, data, reset)\n\011\011if data == \"\" then -- * Is this check needed at all?\n\011\011\011return nil, \"no stamp data\"\n\011\011end\n\011\011local handle = io.open(config.stamp_temp, \"wb\")\n\011\011if not handle then\n\011\011\011return nil, \"cannot write stamp data\"\n\011\011end\n\011\011handle:write(data)\n\011\011handle:close()\n\011\011if reset then\n\011\011\011sim.clearRect(0, 0, sim.XRES, sim.YRES)\n\011\011\011heat_clear()\n\011\011\011tpt.reset_velocity()\n\011\011\011tpt.set_pressure()\n\011\011end\n\011\011local ok, err = sim.loadStamp(config.stamp_temp, x, y)\n\011\011if not ok then\n\011\011\011os.remove(config.stamp_temp)\n\011\011\011if err then\n\011\011\011\011return nil, \"cannot load stamp data: \" .. err\n\011\011\011else\n\011\011\011\011return nil, \"cannot load stamp data\"\n\011\011\011end\n\011\011end\n\011\011os.remove(config.stamp_temp)\n\011\011return true\n\011end\n\011\n\011local function stamp_save(x, y, w, h)\n\011\011local name = sim.saveStamp(x, y, w - 1, h - 1)\n\011\011if not name then\n\011\011\011return nil, \"error saving stamp\"\n\011\011end\n\011\011local handle = io.open(\"stamps/\" .. name .. \".stm\", \"rb\")\n\011\011if not handle then\n\011\011\011sim.deleteStamp(name)\n\011\011\011return nil, \"cannot read stamp data\"\n\011\011end\n\011\011local data = handle:read(\"*a\")\n\011\011handle:close()\n\011\011sim.deleteStamp(name)\n\011\011return data\n\011end\n\011\n\011local function get_user()\n\011\011local pref = io.open(\"powder.pref\")\n\011\011if not pref then\n\011\011\011return\n\011\011end\n\011\011local pref_data = pref:read(\"*a\")\n\011\011pref:close()\n\011\011local user = pref_data:match([[\"User\"%s*:%s*(%b{})]])\n\011\011if not user then\n\011\011\011return\n\011\011end\n\011\011local uid = user:match([[\"ID\"%s*:%s*(%d+)]])\n\011\011local sess = user:match([[\"SessionID\"%s*:%s*\"([^\"]+)\"]])\n\011\011local name = user:match([[\"Username\"%s*:%s*\"([^\"]+)\"]])\n\011\011if not uid or not sess or not name then\n\011\011\011return\n\011\011end\n\011\011if name ~= tpt.get_name() then\n\011\011\011return\n\011\011end\n\011\011return uid, sess, name\n\011end\n\011\n\011-- * Finds bynd, the smallest idx in [first, last] for which beyond(idx)\n\011--   is true. Assumes that for all idx in [first, bynd-1] beyond(idx) is\n\011--   false and for all idx in [bynd, last] beyond(idx) is true. beyond(first-1)\n\011--   is implicitly false and beyond(last+1) is implicitly true, thus an\n\011--   all-false field yields last+1 and an all-true field yields first.\n\011local function binary_search_implicit(first, last, beyond)\n\011\011local function beyond_wrap(idx)\n\011\011\011if idx < first then\n\011\011\011\011return false\n\011\011\011end\n\011\011\011if idx > last then\n\011\011\011\011return true\n\011\011\011end\n\011\011\011return beyond(idx)\n\011\011end\n\011\011while first <= last do\n\011\011\011local mid = math.floor((first + last) / 2)\n\011\011\011if beyond_wrap(mid) then\n\011\011\011\011if beyond_wrap(mid - 1) then\n\011\011\011\011\011last = mid - 1\n\011\011\011\011else\n\011\011\011\011\011return mid\n\011\011\011\011end\n\011\011\011else\n\011\011\011\011first = mid + 1\n\011\011\011end\n\011\011end\n\011\011return first\n\011end\n\011\n\011local function inside_rect(pos_x, pos_y, width, height, check_x, check_y)\n\011\011return pos_x <= check_x and pos_y <= check_y and pos_x + width > check_x and pos_y + height > check_y\n\011end\n\011\n\011local function mouse_pos()\n\011\011return tpt.mousex, tpt.mousey\n\011end\n\011\n\011local function brush_size()\n\011\011return tpt.brushx, tpt.brushy\n\011end\n\011\n\011local function selected_tools()\n\011\011return tpt.selectedl, tpt.selecteda, tpt.selectedr, tpt.selectedreplace\n\011end\n\011\n\011local function wall_snap_coords(x, y)\n\011\011return math.floor(x / 4) * 4, math.floor(y / 4) * 4\n\011end\n\011\n\011local function line_snap_coords(x1, y1, x2, y2)\n\011\011local dx, dy = x2 - x1, y2 - y1\n\011\011if math.abs(math.floor(dx / 2)) > math.abs(dy) then\n\011\011\011return x2, y1\n\011\011elseif math.abs(dx) < math.abs(math.floor(dy / 2)) then\n\011\011\011return x1, y2\n\011\011elseif dx * dy > 0 then\n\011\011\011return x1 + math.floor((dx + dy) / 2), y1 + math.floor((dy + dx) / 2)\n\011\011else\n\011\011\011return x1 + math.floor((dx - dy) / 2), y1 + math.floor((dy - dx) / 2)\n\011\011end\n\011end\n\011\n\011local function rect_snap_coords(x1, y1, x2, y2)\n\011\011local dx, dy = x2 - x1, y2 - y1\n\011\011if dx * dy > 0 then\n\011\011\011return x1 + math.floor((dx + dy) / 2), y1 + math.floor((dy + dx) / 2)\n\011\011else\n\011\011\011return x1 + math.floor((dx - dy) / 2), y1 + math.floor((dy - dx) / 2)\n\011\011end\n\011end\n\011\n\011local function create_parts_any(x, y, rx, ry, xtype, brush, member)\n\011\011if line_only[xtype] or no_create[xtype] then\n\011\011\011return\n\011\011end\n\011\011local class = xid_class[xtype]\n\011\011if class == \"WL\" then\n\011\011\011if xtype == from_tool.DEFAULT_WL_STRM then\n\011\011\011\011rx, ry = 0, 0\n\011\011\011end\n\011\011\011sim.createWalls(x, y, rx, ry, xtype - xid_first.WL, brush)\n\011\011\011return\n\011\011elseif class == \"TOOL\" then\n\011\011\011local str = 1\n\011\011\011if member.kmod_s then\n\011\011\011\011str = 10\n\011\011\011elseif member.kmod_c then\n\011\011\011\011str = 0.1\n\011\011\011end\n\011\011\011sim.toolBrush(x, y, rx, ry, xtype - xid_first.TOOL, brush, str)\n\011\011\011return\n\011\011elseif class == \"DECOR\" then\n\011\011\011sim.decoBrush(x, y, rx, ry, member.deco_r, member.deco_g, member.deco_b, member.deco_a, xtype - xid_first.DECOR, brush)\n\011\011\011return\n\011\011elseif class == \"PT_LIFE\" then\n\011\011\011xtype = bit.bor(elem.DEFAULT_PT_LIFE, bit.lshift(xtype - xid_first.PT_LIFE, PMAPBITS))\n\011\011elseif type(xtype) == \"table\" and xtype.type == \"cgol\" then\n\011\011\011-- * TODO[api]: add an api for setting gol colour\n\011\011\011xtype = xtype.elem\n\011\011end\n\011\011local ov = create_override[xtype]\n\011\011if ov then\n\011\011\011rx, ry, xtype = ov(rx, ry, xtype)\n\011\011end\n\011\011local selectedreplace\n\011\011if member.bmode ~= 0 then\n\011\011\011selectedreplace = tpt.selectedreplace\n\011\011\011tpt.selectedreplace = to_tool[member.tool_x] or \"DEFAULT_PT_NONE\"\n\011\011end\n\011\011sim.createParts(x, y, rx, ry, xtype, brush, member.bmode)\n\011\011if member.bmode ~= 0 then\n\011\011\011tpt.selectedreplace = selectedreplace\n\011\011end\n\011end\n\011\n\011local function create_line_any(x1, y1, x2, y2, rx, ry, xtype, brush, member, cont)\n\011\011if no_create[xtype] or no_shape[xtype] or (jacobsmod and xtype == tpt.element(\"ball\") and not member.kmod_s) then\n\011\011\011return\n\011\011end\n\011\011local class = xid_class[xtype]\n\011\011if class == \"WL\" then\n\011\011\011local str = 1\n\011\011\011if cont then\n\011\011\011\011if member.kmod_s then\n\011\011\011\011\011str = 10\n\011\011\011\011elseif member.kmod_c then\n\011\011\011\011\011str = 0.1\n\011\011\011\011end\n\011\011\011\011str = str * 5\n\011\011\011end\n\011\011\011if not cont and xtype == from_tool.DEFAULT_WL_FAN and tpt.get_wallmap(math.floor(x1 / 4), math.floor(y1 / 4)) == WL_FAN then\n\011\011\011\011local fvx = (x2 - x1) * 0.005\n\011\011\011\011local fvy = (y2 - y1) * 0.005\n\011\011\011\011local bw = sim.XRES / 4\n\011\011\011\011local bh = sim.YRES / 4\n\011\011\011\011local visit = {}\n\011\011\011\011local mark = {}\n\011\011\011\011local last = 0\n\011\011\011\011local function enqueue(x, y)\n\011\011\011\011\011if x >= 0 and y >= 0 and x < bw and y < bh and tpt.get_wallmap(x, y) == WL_FAN then\n\011\011\011\011\011\011local k = x + y * bw\n\011\011\011\011\011\011if not mark[k] then\n\011\011\011\011\011\011\011last = last + 1\n\011\011\011\011\011\011\011visit[last] = k\n\011\011\011\011\011\011\011mark[k] = true\n\011\011\011\011\011\011end\n\011\011\011\011\011end\n\011\011\011\011end\n\011\011\011\011enqueue(math.floor(x1 / 4), math.floor(y1 / 4))\n\011\011\011\011local curr = 1\n\011\011\011\011while visit[curr] do\n\011\011\011\011\011local k = visit[curr]\n\011\011\011\011\011local x, y = k % bw, math.floor(k / bw)\n\011\011\011\011\011tpt.set_wallmap(x, y, 1, 1, fvx, fvy, WL_FAN)\n\011\011\011\011\011enqueue(x - 1, y)\n\011\011\011\011\011enqueue(x, y - 1)\n\011\011\011\011\011enqueue(x + 1, y)\n\011\011\011\011\011enqueue(x, y + 1)\n\011\011\011\011\011curr = curr + 1\n\011\011\011\011end\n\011\011\011\011return\n\011\011\011end\n\011\011\011if xtype == from_tool.DEFAULT_WL_STRM then\n\011\011\011\011rx, ry = 0, 0\n\011\011\011end\n\011\011\011sim.createWallLine(x1, y1, x2, y2, rx, ry, xtype - xid_first.WL, brush)\n\011\011\011return\n\011\011elseif xtype == from_tool.DEFAULT_UI_WIND then\n\011\011\011local str = 1\n\011\011\011if cont then\n\011\011\011\011if member.kmod_s then\n\011\011\011\011\011str = 10\n\011\011\011\011elseif member.kmod_c then\n\011\011\011\011\011str = 0.1\n\011\011\011\011end\n\011\011\011\011str = str * 5\n\011\011\011end\n\011\011\011sim.toolLine(x1, y1, x2, y2, rx, ry, sim.TOOL_WIND, brush, str)\n\011\011\011return\n\011\011elseif class == \"TOOL\" then\n\011\011\011local str = 1\n\011\011\011if cont then\n\011\011\011\011if member.kmod_s then\n\011\011\011\011\011str = 10\n\011\011\011\011elseif member.kmod_c then\n\011\011\011\011\011str = 0.1\n\011\011\011\011end\n\011\011\011end\n\011\011\011sim.toolLine(x1, y1, x2, y2, rx, ry, xtype - xid_first.TOOL, brush, str)\n\011\011\011return\n\011\011elseif class == \"DECOR\" then\n\011\011\011sim.decoLine(x1, y1, x2, y2, rx, ry, member.deco_r, member.deco_g, member.deco_b, member.deco_a, xtype - xid_first.DECOR, brush)\n\011\011\011return\n\011\011elseif class == \"PT_LIFE\" then\n\011\011\011xtype = bit.bor(elem.DEFAULT_PT_LIFE, bit.lshift(xtype - xid_first.PT_LIFE, PMAPBITS))\n\011\011elseif type(xtype) == \"table\" and xtype.type == \"cgol\" then\n\011\011\011-- * TODO[api]: add an api for setting gol colour\n\011\011\011xtype = xtype.elem\n\011\011end\n\011\011local ov = create_override[xtype]\n\011\011if ov then\n\011\011\011rx, ry, xtype = ov(rx, ry, xtype)\n\011\011end\n\011\011local selectedreplace\n\011\011if member.bmode ~= 0 then\n\011\011\011selectedreplace = tpt.selectedreplace\n\011\011\011tpt.selectedreplace = to_tool[member.tool_x] or \"DEFAULT_PT_NONE\"\n\011\011end\n\011\011sim.createLine(x1, y1, x2, y2, rx, ry, xtype, brush, member.bmode)\n\011\011if member.bmode ~= 0 then\n\011\011\011tpt.selectedreplace = selectedreplace\n\011\011end\n\011end\n\011\n\011local function create_box_any(x1, y1, x2, y2, xtype, member)\n\011\011if line_only[xtype] or no_create[xtype] or no_shape[xtype] then\n\011\011\011return\n\011\011end\n\011\011local class = xid_class[xtype]\n\011\011if class == \"WL\" then\n\011\011\011sim.createWallBox(x1, y1, x2, y2, xtype - xid_first.WL)\n\011\011\011return\n\011\011elseif class == \"TOOL\" then\n\011\011\011sim.toolBox(x1, y1, x2, y2, xtype - xid_first.TOOL)\n\011\011\011return\n\011\011elseif class == \"DECOR\" then\n\011\011\011sim.decoBox(x1, y1, x2, y2, member.deco_r, member.deco_g, member.deco_b, member.deco_a, xtype - xid_first.DECOR)\n\011\011\011return\n\011\011elseif class == \"PT_LIFE\" then\n\011\011\011xtype = bit.bor(elem.DEFAULT_PT_LIFE, bit.lshift(xtype - xid_first.PT_LIFE, PMAPBITS))\n\011\011elseif type(xtype) == \"table\" and xtype.type == \"cgol\" then\n\011\011\011-- * TODO[api]: add an api for setting gol colour\n\011\011\011xtype = xtype.elem\n\011\011end\n\011\011local _\n\011\011local ov = create_override[xtype]\n\011\011if ov then\n\011\011\011_, _, xtype = ov(member.size_x, member.size_y, xtype)\n\011\011end\n\011\011local selectedreplace\n\011\011if member.bmode ~= 0 then\n\011\011\011selectedreplace = tpt.selectedreplace\n\011\011\011tpt.selectedreplace = to_tool[member.tool_x] or \"DEFAULT_PT_NONE\"\n\011\011end\n\011\011sim.createBox(x1, y1, x2, y2, xtype, member and member.bmode)\n\011\011if member.bmode ~= 0 then\n\011\011\011tpt.selectedreplace = selectedreplace\n\011\011end\n\011end\n\011\n\011local function flood_any(x, y, xtype, part_flood_hint, wall_flood_hint, member)\n\011\011if line_only[xtype] or no_create[xtype] or no_flood[xtype] then\n\011\011\011return\n\011\011end\n\011\011local class = xid_class[xtype]\n\011\011if class == \"WL\" then\n\011\011\011sim.floodWalls(x, y, xtype - xid_first.WL, wall_flood_hint)\n\011\011\011return\n\011\011elseif class == \"DECOR\" or class == \"TOOL\" then\n\011\011\011return\n\011\011elseif class == \"PT_LIFE\" then\n\011\011\011xtype = bit.bor(elem.DEFAULT_PT_LIFE, bit.lshift(xtype - xid_first.PT_LIFE, PMAPBITS))\n\011\011elseif type(xtype) == \"table\" and xtype.type == \"cgol\" then\n\011\011\011-- * TODO[api]: add an api for setting gol colour\n\011\011\011xtype = xtype.elem\n\011\011end\n\011\011local _\n\011\011local ov = create_override[xtype]\n\011\011if ov then\n\011\011\011_, _, xtype = ov(member.size_x, member.size_y, xtype)\n\011\011end\n\011\011local selectedreplace\n\011\011if member.bmode ~= 0 then\n\011\011\011selectedreplace = tpt.selectedreplace\n\011\011\011tpt.selectedreplace = to_tool[member.tool_x] or \"DEFAULT_PT_NONE\"\n\011\011end\n\011\011sim.floodParts(x, y, xtype, part_flood_hint, member.bmode)\n\011\011if member.bmode ~= 0 then\n\011\011\011tpt.selectedreplace = selectedreplace\n\011\011end\n\011end\n\011\n\011local function corners_to_rect(x1, y1, x2, y2)\n\011\011local xl = math.min(x1, x2)\n\011\011local yl = math.min(y1, y2)\n\011\011local xh = math.max(x1, x2)\n\011\011local yh = math.max(y1, y2)\n\011\011return xl, yl, xh - xl + 1, yh - yl + 1\n\011end\n\011\n\011local function escape_regex(str)\n\011\011return (str:gsub(\"[%$%%%(%)%*%+%-%.%?%[%^%]]\", \"%%%1\"))\n\011end\n\011\n\011local function fnv1a32(data)\n\011\011local hash = 2166136261\n\011\011for i = 1, #data do\n\011\011\011hash = bit.bxor(hash, data:byte(i))\n\011\011\011hash = bit.band(bit.lshift(hash, 24), 0xFFFFFFFF) + bit.band(bit.lshift(hash, 8), 0xFFFFFFFF) + hash * 147\n\011\011end\n\011\011hash = bit.band(hash, 0xFFFFFFFF)\n\011\011return hash < 0 and (hash + 0x100000000) or hash\n\011end\n\011\n\011local function ambient_air_temp(temp)\n\011\011if temp then\n\011\011\011local set = temp / 0x400\n\011\011\011sim.ambientAirTemp(set)\n\011\011\011return set\n\011\011else\n\011\011\011return math.floor(sim.ambientAirTemp() * 0x400)\n\011\011end\n\011end\n\011\n\011local function get_save_id()\n\011\011local id, hist = sim.getSaveID()\n\011\011if id and not hist then\n\011\011\011hist = 0\n\011\011end\n\011\011return id, hist\n\011end\n\011\n\011local function urlencode(str)\n\011\011return (str:gsub(\"[^ !'()*%-%.0-9A-Z_a-z]\", function(cap)\n\011\011\011return (\"%%%02x\"):format(cap:byte())\n\011\011end))\n\011end\n\011\n\011return {\n\011\011get_user = get_user,\n\011\011stamp_load = stamp_load,\n\011\011stamp_save = stamp_save,\n\011\011binary_search_implicit = binary_search_implicit,\n\011\011inside_rect = inside_rect,\n\011\011mouse_pos = mouse_pos,\n\011\011brush_size = brush_size,\n\011\011selected_tools = selected_tools,\n\011\011wall_snap_coords = wall_snap_coords,\n\011\011line_snap_coords = line_snap_coords,\n\011\011rect_snap_coords = rect_snap_coords,\n\011\011create_parts_any = create_parts_any,\n\011\011create_line_any = create_line_any,\n\011\011create_box_any = create_box_any,\n\011\011flood_any = flood_any,\n\011\011from_tool = from_tool,\n\011\011to_tool = to_tool,\n\011\011create_override = create_override,\n\011\011no_flood = no_flood,\n\011\011no_shape = no_shape,\n\011\011xid_class = xid_class,\n\011\011corners_to_rect = corners_to_rect,\n\011\011escape_regex = escape_regex,\n\011\011fnv1a32 = fnv1a32,\n\011\011ambient_air_temp = ambient_air_temp,\n\011\011get_save_id = get_save_id,\n\011\011version_less = common_util.version_less,\n\011\011version_equal = common_util.version_equal,\n\011\011tpt_version = tpt_version,\n\011\011urlencode = urlencode,\n\011\011heat_clear = heat_clear,\n\011\011unknown_xid = unknown_xid,\n\011}\n\011\nend\n\nrequire_preload__[\"tptmp.client.window\"] = function()\n\n\011local config  = require(\"tptmp.client.config\")\n\011local colours = require(\"tptmp.client.colours\")\n\011local format  = require(\"tptmp.client.format\")\n\011local utf8    = require(\"tptmp.client.utf8\")\n\011local util    = require(\"tptmp.client.util\")\n\011local manager = require(\"tptmp.client.manager\")\n\011local sdl     = require(\"tptmp.client.sdl\")\n\011\n\011local window_i = {}\n\011local window_m = { __index = window_i }\n\011\n\011local wrap_padding = 11 -- * Width of \"* \"\n\011\n\011function window_i:backlog_push_join(formatted_nick)\n\011\011self:backlog_push_str(colours.commonstr.join .. \"* \" .. formatted_nick .. colours.commonstr.join .. \" has joined\", true)\n\011end\n\011\n\011function window_i:backlog_push_leave(formatted_nick)\n\011\011self:backlog_push_str(colours.commonstr.leave .. \"* \" .. formatted_nick .. colours.commonstr.leave .. \" has left\", true)\n\011end\n\011\n\011function window_i:backlog_push_fpssync_enable(formatted_nick)\n\011\011self:backlog_push_str(colours.commonstr.fpssyncenable .. \"* \" .. formatted_nick .. colours.commonstr.fpssyncenable .. \" has enabled FPS synchronization\", true)\n\011end\n\011\n\011function window_i:backlog_push_fpssync_disable(formatted_nick)\n\011\011self:backlog_push_str(colours.commonstr.fpssyncdisable .. \"* \" .. formatted_nick .. colours.commonstr.fpssyncdisable .. \" has disabled FPS synchronization\", true)\n\011end\n\011\n\011function window_i:backlog_push_error(str)\n\011\011self:backlog_push_str(colours.commonstr.error .. \"* \" .. str, true)\n\011end\n\011\n\011function window_i:get_important_(str)\n\011\011local cli = self.client_func_()\n\011\011if cli then\n\011\011\011if (\" \" .. str .. \" \"):lower():find(\"[^a-z0-9-_]\" .. cli:nick():lower() .. \"[^a-z0-9-_]\") then\n\011\011\011\011return true\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function window_i:backlog_push_say_other(formatted_nick, str)\n\011\011self:backlog_push_say(formatted_nick, str, self:get_important_(str))\n\011end\n\011\n\011function window_i:backlog_push_say3rd_other(formatted_nick, str)\n\011\011self:backlog_push_say3rd(formatted_nick, str, self:get_important_(str))\n\011end\n\011\n\011function window_i:backlog_push_say(formatted_nick, str, important)\n\011\011self:backlog_push_str(colours.commonstr.chat .. \"<\" .. formatted_nick .. colours.commonstr.chat .. \"> \" .. str, important)\n\011end\n\011\n\011function window_i:backlog_push_say3rd(formatted_nick, str, important)\n\011\011self:backlog_push_str(colours.commonstr.chat .. \"* \" .. formatted_nick .. colours.commonstr.chat .. \" \" .. str, important)\n\011end\n\011\n\011function window_i:backlog_push_room(room, members, prefix)\n\011\011local sep = colours.commonstr.neutral .. \", \"\n\011\011local collect = { colours.commonstr.neutral, \"* \", prefix, format.troom(room), sep }\n\011\011if next(members) then\n\011\011\011table.insert(collect, \"present: \")\n\011\011\011local first = true\n\011\011\011for id, member in pairs(members) do\n\011\011\011\011if first then\n\011\011\011\011\011first = false\n\011\011\011\011else\n\011\011\011\011\011table.insert(collect, sep)\n\011\011\011\011end\n\011\011\011\011table.insert(collect, member.formatted_nick)\n\011\011\011end\n\011\011else\n\011\011\011table.insert(collect, \"nobody else present\")\n\011\011end\n\011\011self:backlog_push_str(table.concat(collect), true)\n\011end\n\011\n\011function window_i:backlog_push_fpssync(members)\n\011\011local sep = colours.commonstr.neutral .. \", \"\n\011\011local collect = { colours.commonstr.neutral, \"* \" }\n\011\011if members == true then\n\011\011\011table.insert(collect, \"FPS synchronization is enabled\")\n\011\011elseif members then\n\011\011\011if next(members) then\n\011\011\011\011table.insert(collect, \"FPS synchronization is enabled, in sync with: \")\n\011\011\011\011local first = true\n\011\011\011\011for id, member in pairs(members) do\n\011\011\011\011\011if first then\n\011\011\011\011\011\011first = false\n\011\011\011\011\011else\n\011\011\011\011\011\011table.insert(collect, sep)\n\011\011\011\011\011end\n\011\011\011\011\011table.insert(collect, member.formatted_nick)\n\011\011\011\011end\n\011\011\011else\n\011\011\011\011table.insert(collect, \"FPS synchronization is enabled, not in sync with anyone\")\n\011\011\011end\n\011\011else\n\011\011\011table.insert(collect, \"FPS synchronization is disabled\")\n\011\011end\n\011\011self:backlog_push_str(table.concat(collect), true)\n\011end\n\011\n\011function window_i:backlog_push_registered(formatted_nick)\n\011\011self:backlog_push_str(colours.commonstr.neutral .. \"* Connected as \" .. formatted_nick, true)\n\011end\n\011\n\011local server_colours = {\n\011\011n = colours.commonstr.neutral,\n\011\011e = colours.commonstr.error,\n\011\011j = colours.commonstr.join,\n\011\011l = colours.commonstr.leave,\n\011}\n\011function window_i:backlog_push_server(str)\n\011\011local formatted = str\n\011\011\011:gsub(\"\\au([A-Za-z0-9-_]+)\", function(cap) return format.nick(cap, self.nick_colour_seed_) end)\n\011\011\011:gsub(\"\\ar([A-Za-z0-9-_]+)\", function(cap) return format.room(cap)                         end)\n\011\011\011:gsub(\"\\a([nejl])\"         , function(cap) return server_colours[cap]                      end)\n\011\011self:backlog_push_str(formatted, true)\n\011end\n\011\n\011function window_i:nick_colour_seed(seed)\n\011\011self.nick_colour_seed_ = seed\n\011end\n\011\n\011function window_i:backlog_push_neutral(str)\n\011\011self:backlog_push_str(colours.commonstr.neutral .. str, true)\n\011end\n\011\n\011function window_i:backlog_wrap_(msg)\n\011\011if msg == self.backlog_first_ then\n\011\011\011return\n\011\011end\n\011\011if msg.wrapped_to ~= self.width_ then\n\011\011\011local line = {}\n\011\011\011local wrapped = {}\n\011\011\011local collect = msg.collect\n\011\011\011local i = 0\n\011\011\011local word = {}\n\011\011\011local word_width = 0\n\011\011\011local line_width = 0\n\011\011\011local max_width = self.width_ - 8\n\011\011\011local line_empty = true\n\011\011\011local red, green, blue = 255, 255, 255\n\011\011\011local initial_block\n\011\011\011local function insert_block(block)\n\011\011\011\011if initial_block then\n\011\011\011\011\011table.insert(line, initial_block)\n\011\011\011\011\011initial_block = nil\n\011\011\011\011end\n\011\011\011\011table.insert(line, block)\n\011\011\011end\n\011\011\011local function flush_line()\n\011\011\011\011if not line_empty then\n\011\011\011\011\011table.insert(wrapped, table.concat(line))\n\011\011\011\011\011line = {}\n\011\011\011\011\011initial_block = colours.escape({ red, green, blue })\n\011\011\011\011\011line_width = wrap_padding\n\011\011\011\011\011line_empty = true\n\011\011\011\011end\n\011\011\011end\n\011\011\011local function flush_word()\n\011\011\011\011if #word > 0 then\n\011\011\011\011\011for i = 1, #word do\n\011\011\011\011\011\011insert_block(word[i])\n\011\011\011\011\011end\n\011\011\011\011\011line_empty = false\n\011\011\011\011\011line_width = line_width + word_width\n\011\011\011\011\011word = {}\n\011\011\011\011\011word_width = 0\n\011\011\011\011end\n\011\011\011end\n\011\011\011while i < #collect do\n\011\011\011\011i = i + 1\n\011\011\011\011if collect[i] == \"\\15\" and i + 3 <= #collect then\n\011\011\011\011\011local rgb = utf8.code_points(table.concat(collect, nil, i + 1, i + 3))\n\011\011\011\011\011if rgb then\n\011\011\011\011\011\011for j = i, i + 3 do\n\011\011\011\011\011\011\011table.insert(word, collect[j])\n\011\011\011\011\011\011end\n\011\011\011\011\011\011red, green, blue = rgb[1].cp, rgb[2].cp, rgb[3].cp\n\011\011\011\011\011end\n\011\011\011\011\011i = i + 3\n\011\011\011\011else\n\011\011\011\011\011local i_width = gfx.textSize(collect[i])\n\011\011\011\011\011if collect[i]:find(config.whitespace_pattern) then\n\011\011\011\011\011\011flush_word()\n\011\011\011\011\011\011if line_width + i_width > max_width then\n\011\011\011\011\011\011\011flush_line()\n\011\011\011\011\011\011end\n\011\011\011\011\011\011if not line_empty then\n\011\011\011\011\011\011\011insert_block(collect[i])\n\011\011\011\011\011\011\011line_width = line_width + i_width\n\011\011\011\011\011\011end\n\011\011\011\011\011\011line_empty = false\n\011\011\011\011\011else\n\011\011\011\011\011\011if line_width + word_width + i_width > max_width then\n\011\011\011\011\011\011\011flush_line()\n\011\011\011\011\011\011\011if line_width + word_width + i_width > max_width then\n\011\011\011\011\011\011\011\011flush_word()\n\011\011\011\011\011\011\011\011if line_width + word_width + i_width > max_width then\n\011\011\011\011\011\011\011\011\011flush_line()\n\011\011\011\011\011\011\011\011end\n\011\011\011\011\011\011\011end\n\011\011\011\011\011\011end\n\011\011\011\011\011\011table.insert(word, collect[i])\n\011\011\011\011\011\011word_width = word_width + i_width\n\011\011\011\011\011end\n\011\011\011\011end\n\011\011\011end\n\011\011\011flush_word()\n\011\011\011flush_line()\n\011\011\011if #wrapped > 1 and wrapped[#wrapped] == \"\" then\n\011\011\011\011wrapped[#wrapped] = nil\n\011\011\011end\n\011\011\011msg.wrapped_to = self.width_\n\011\011\011msg.wrapped = wrapped\n\011\011\011self.backlog_last_wrapped_ = math.max(self.backlog_last_wrapped_, msg.unique)\n\011\011end\n\011end\n\011\n\011function window_i:backlog_update_()\n\011\011local max_lines = math.floor((self.height_ - 35) / 12)\n\011\011local lines_reverse = {}\n\011\011self:backlog_wrap_(self.backlog_last_visible_msg_)\n\011\011if self.backlog_auto_scroll_ then\n\011\011\011while self.backlog_last_visible_msg_.next ~= self.backlog_last_ do\n\011\011\011\011self.backlog_last_visible_msg_ = self.backlog_last_visible_msg_.next\n\011\011\011end\n\011\011\011self:backlog_wrap_(self.backlog_last_visible_msg_)\n\011\011\011self.backlog_last_visible_line_ = #self.backlog_last_visible_msg_.wrapped\n\011\011end\n\011\011self:backlog_wrap_(self.backlog_last_visible_msg_)\n\011\011self.backlog_last_visible_line_ = math.min(#self.backlog_last_visible_msg_.wrapped, self.backlog_last_visible_line_)\n\011\011local source_msg = self.backlog_last_visible_msg_\n\011\011local source_line = self.backlog_last_visible_line_\n\011\011while #lines_reverse < max_lines do\n\011\011\011if source_msg == self.backlog_first_ then\n\011\011\011\011break\n\011\011\011end\n\011\011\011self:insert_wrapped_line_(lines_reverse, source_msg, source_line)\n\011\011\011source_line = source_line - 1\n\011\011\011if source_line == 0 then\n\011\011\011\011source_msg = source_msg.prev\n\011\011\011\011self:backlog_wrap_(source_msg)\n\011\011\011\011source_line = #source_msg.wrapped\n\011\011\011end\n\011\011end\n\011\011if source_msg ~= self.backlog_first_ and source_msg.unique - 1 <= self.backlog_unique_ - config.backlog_size then\n\011\011\011source_msg.prev = self.backlog_first_\n\011\011\011self.backlog_first_.next = source_msg\n\011\011end\n\011\011local lines = {}\n\011\011for i = #lines_reverse, 1, -1 do\n\011\011\011table.insert(lines, lines_reverse[i])\n\011\011end\n\011\011while #lines < max_lines do\n\011\011\011if self.backlog_last_visible_line_ == #self.backlog_last_visible_msg_.wrapped then\n\011\011\011\011if self.backlog_last_visible_msg_.next == self.backlog_last_ then\n\011\011\011\011\011break\n\011\011\011\011end\n\011\011\011\011self.backlog_last_visible_msg_ = self.backlog_last_visible_msg_.next\n\011\011\011\011self:backlog_wrap_(self.backlog_last_visible_msg_)\n\011\011\011\011self.backlog_last_visible_line_ = 1\n\011\011\011else\n\011\011\011\011self.backlog_last_visible_line_ = self.backlog_last_visible_line_ + 1\n\011\011\011end\n\011\011\011self:insert_wrapped_line_(lines, self.backlog_last_visible_msg_, self.backlog_last_visible_line_)\n\011\011end\n\011\011self.backlog_text_ = {}\n\011\011local marker_after\n\011\011for i = 1, #lines do\n\011\011\011local text_width = gfx.textSize(lines[i].wrapped)\n\011\011\011local padding = lines[i].needs_padding and wrap_padding or 0\n\011\011\011local box_width = lines[i].extend_box and self.width_ or (padding + text_width + 10)\n\011\011\011table.insert(self.backlog_text_, {\n\011\011\011\011padding = padding,\n\011\011\011\011pushed_at = lines[i].msg.pushed_at,\n\011\011\011\011text = lines[i].wrapped,\n\011\011\011\011box_width = box_width,\n\011\011\011})\n\011\011\011if lines[i].marker then\n\011\011\011\011marker_after = i\n\011\011\011end\n\011\011end\n\011\011self.backlog_lines_ = lines\n\011\011self.backlog_text_y_ = self.height_ - #lines * 12 - 15\n\011\011self.backlog_marker_y_ = self.backlog_enable_marker_ and marker_after and marker_after ~= #lines and (self.backlog_text_y_ + marker_after * 12 - 2)\n\011end\n\011\n\011function window_i:backlog_push_(collect, important)\n\011\011self.backlog_unique_ = self.backlog_unique_ + 1\n\011\011local msg = {\n\011\011\011unique = self.backlog_unique_,\n\011\011\011collect = collect,\n\011\011\011prev = self.backlog_last_.prev,\n\011\011\011next = self.backlog_last_,\n\011\011\011important = important,\n\011\011\011pushed_at = socket.gettime(),\n\011\011}\n\011\011self.backlog_last_.prev.next = msg\n\011\011self.backlog_last_.prev = msg\n\011\011if important then\n\011\011\011self.backlog_unique_important_ = self.backlog_unique_\n\011\011end\n\011\011self:backlog_update_()\n\011end\n\011\n\011function window_i:backlog_push_str(str, important)\n\011\011local collect = {}\n\011\011local cps = utf8.code_points(str)\n\011\011if cps then\n\011\011\011for i = 1, #cps do\n\011\011\011\011table.insert(collect, str:sub(cps[i].pos, cps[i].pos + cps[i].size - 1))\n\011\011\011end\n\011\011\011self:backlog_push_(collect, important)\n\011\011end\n\011end\n\011\n\011function window_i:backlog_bump_marker()\n\011\011self.backlog_enable_marker_ = false\n\011\011if self.backlog_last_seen_ < self.backlog_unique_ then\n\011\011\011self.backlog_enable_marker_ = true\n\011\011\011self.backlog_marker_at_ = self.backlog_last_seen_\n\011\011end\n\011\011self:backlog_update_()\n\011end\n\011\n\011function window_i:backlog_notif_reset()\n\011\011self.backlog_last_seen_ = self.backlog_unique_\n\011\011self:backlog_bump_marker()\n\011end\n\011\n\011function window_i:backlog_notif_count()\n\011\011return self.backlog_unique_ - self.backlog_last_seen_\n\011end\n\011\n\011function window_i:backlog_notif_important()\n\011\011return self.backlog_unique_important_ - self.backlog_last_seen_ > 0\n\011end\n\011\n\011function window_i:backlog_reset()\n\011\011self.backlog_unique_ = 0\n\011\011self.backlog_unique_important_ = 0\n\011\011self.backlog_last_wrapped_ = 0\n\011\011self.backlog_last_seen_ = 0\n\011\011self.backlog_marker_at_ = 0\n\011\011self.backlog_last_ = { wrapped = {}, unique = 0 }\n\011\011self.backlog_first_ = { wrapped = {} }\n\011\011self.backlog_last_.prev = self.backlog_first_\n\011\011self.backlog_first_.next = self.backlog_last_\n\011\011self.backlog_last_visible_msg_ = self.backlog_first_\n\011\011self.backlog_last_visible_line_ = 0\n\011\011self.backlog_auto_scroll_ = true\n\011\011self.backlog_enable_marker_ = false\n\011\011self:backlog_update_()\n\011end\n\011\n\011local close_button_off_x = -12\n\011local close_button_off_y = 3\n\011if tpt.version.jacob1s_mod then\n\011\011close_button_off_x = -11\n\011\011close_button_off_y = 4\n\011end\n\011function window_i:tick_close_()\n\011\011local border_colour = colours.appearance.inactive.border\n\011\011local close_fg = colours.appearance.inactive.text\n\011\011local close_bg\n\011\011local inside_close = util.inside_rect(self.pos_x_ + self.width_ - 15, self.pos_y_, 15, 15, util.mouse_pos())\n\011\011if self.close_active_ then\n\011\011\011close_fg = colours.appearance.active.text\n\011\011\011close_bg = colours.appearance.active.background\n\011\011elseif inside_close then\n\011\011\011close_fg = colours.appearance.hover.text\n\011\011\011close_bg = colours.appearance.hover.background\n\011\011end\n\011\011if close_bg then\n\011\011\011gfx.fillRect(self.pos_x_ + self.width_ - 14, self.pos_y_ + 1, 13, 13, unpack(close_bg))\n\011\011end\n\011\011gfx.drawLine(self.pos_x_ + self.width_ - 15, self.pos_y_ + 1, self.pos_x_ + self.width_ - 15, self.pos_y_ + 13, unpack(border_colour))\n\011\011gfx.drawText(self.pos_x_ + self.width_ + close_button_off_x, self.pos_y_ + close_button_off_y, utf8.encode_multiple(0xE02A), unpack(close_fg))\n\011\011if self.close_active_ and not inside_close then\n\011\011\011self.close_active_ = false\n\011\011end\n\011end\n\011\n\011function window_i:handle_tick()\n\011\011if self.backlog_auto_scroll_ then\n\011\011\011self.backlog_last_seen_ = self.backlog_last_wrapped_\n\011\011else\n\011\011\011if self.backlog_last_seen_ < self.backlog_unique_ and not self.backlog_enable_marker_ then\n\011\011\011\011self:backlog_bump_marker()\n\011\011\011end\n\011\011end\n\011\n\011\011if self.resizer_active_ then\n\011\011\011local resizer_x, resizer_y = util.mouse_pos()\n\011\011\011local prev_x, prev_y = self.pos_x_, self.pos_y_\n\011\011\011self.pos_x_ = math.min(math.max(1, self.pos_x_ + resizer_x - self.resizer_last_x_), self.pos_x_ + self.width_ - config.min_width)\n\011\011\011self.pos_y_ = math.min(math.max(1, self.pos_y_ + resizer_y - self.resizer_last_y_), self.pos_y_ + self.height_ - config.min_height)\n\011\011\011local diff_x, diff_y = self.pos_x_ - prev_x, self.pos_y_ - prev_y\n\011\011\011self.resizer_last_x_ = self.resizer_last_x_ + diff_x\n\011\011\011self.resizer_last_y_ = self.resizer_last_y_ + diff_y\n\011\011\011self.width_ = self.width_ - diff_x\n\011\011\011self.height_ = self.height_ - diff_y\n\011\011\011self:input_update_()\n\011\011\011self:backlog_update_()\n\011\011\011self:subtitle_update_()\n\011\011\011self:save_window_rect_()\n\011\011end\n\011\011if self.dragger_active_ then\n\011\011\011local dragger_x, dragger_y = util.mouse_pos()\n\011\011\011local prev_x, prev_y = self.pos_x_, self.pos_y_\n\011\011\011self.pos_x_ = math.min(math.max(1, self.pos_x_ + dragger_x - self.dragger_last_x_), sim.XRES - self.width_)\n\011\011\011self.pos_y_ = math.min(math.max(1, self.pos_y_ + dragger_y - self.dragger_last_y_), sim.YRES - self.height_)\n\011\011\011local diff_x, diff_y = self.pos_x_ - prev_x, self.pos_y_ - prev_y\n\011\011\011self.dragger_last_x_ = self.dragger_last_x_ + diff_x\n\011\011\011self.dragger_last_y_ = self.dragger_last_y_ + diff_y\n\011\011\011self:save_window_rect_()\n\011\011end\n\011\n\011\011local floating = self.window_status_func_() == \"floating\"\n\011\011local now = socket.gettime()\n\011\n\011\011local border_colour = colours.appearance[self.in_focus and \"active\" or \"inactive\"].border\n\011\011local background_colour = colours.appearance.inactive.background\n\011\011if not floating then\n\011\011\011gfx.fillRect(self.pos_x_ + 1, self.pos_y_ + 1, self.width_ - 2, self.height_ - 2, background_colour[1], background_colour[2], background_colour[3], self.alpha_)\n\011\011\011gfx.drawRect(self.pos_x_, self.pos_y_, self.width_, self.height_, unpack(border_colour))\n\011\n\011\011\011self:tick_close_()\n\011\n\011\011\011local subtitle_blue = 255\n\011\011\011if #self.input_collect_ > 0 and self.input_last_say_ + config.message_interval >= now then\n\011\011\011\011subtitle_blue = 0\n\011\011\011end\n\011\011\011gfx.drawText(self.pos_x_ + 18, self.pos_y_ + 4, self.subtitle_text_, 255, 255, subtitle_blue)\n\011\n\011\011\011gfx.drawText(self.pos_x_ + self.width_ - self.title_width_ - 17, self.pos_y_ + 4, self.title_)\n\011\011\011for i = 1, 3 do\n\011\011\011\011gfx.drawLine(self.pos_x_ + i * 3 + 1, self.pos_y_ + 3, self.pos_x_ + 3, self.pos_y_ + i * 3 + 1, unpack(border_colour))\n\011\011\011end\n\011\011\011gfx.drawLine(self.pos_x_ + 1, self.pos_y_ + 14, self.pos_x_ + self.width_ - 2, self.pos_y_ + 14, unpack(border_colour))\n\011\011\011gfx.drawLine(self.pos_x_ + 14, self.pos_y_ + 1, self.pos_x_ + 14, self.pos_y_ + 13, unpack(border_colour))\n\011\011end\n\011\n\011\011for i = 1, #self.backlog_text_ do\n\011\011\011local fades_at = self.backlog_text_[i].pushed_at + config.floating_linger_time + config.floating_fade_time\n\011\011\011if floating and fades_at > now then\n\011\011\011\011local alpha = math.min(1, (fades_at - now) / config.floating_fade_time)\n\011\011\011\011gfx.fillRect(self.pos_x_ - 1, self.pos_y_ + self.backlog_text_y_ + i * 12 - 15, self.backlog_text_[i].box_width, self.backlog_text_[i + 1] and 12 or 14, 0, 0, 0, alpha * self.alpha_)\n\011\011\011\011if self.backlog_text_[i + 1] and self.backlog_text_[i + 1].box_width < self.backlog_text_[i].box_width then\n\011\011\011\011\011gfx.fillRect(self.pos_x_ - 1 + self.backlog_text_[i + 1].box_width, self.pos_y_ + self.backlog_text_y_ + i * 12 - 3, self.backlog_text_[i].box_width - self.backlog_text_[i + 1].box_width, 2, 0, 0, 0, alpha * self.alpha_)\n\011\011\011\011end\n\011\011\011end\n\011\011end\n\011\011for i = 1, #self.backlog_text_ do\n\011\011\011local fades_at = self.backlog_text_[i].pushed_at + config.floating_linger_time + config.floating_fade_time\n\011\011\011if not floating or fades_at > now then\n\011\011\011\011local alpha = 1\n\011\011\011\011if floating then\n\011\011\011\011\011alpha = math.min(1, (fades_at - now) / config.floating_fade_time)\n\011\011\011\011end\n\011\011\011\011gfx.drawText(self.pos_x_ + 4 + self.backlog_text_[i].padding, self.pos_y_ + self.backlog_text_y_ + i * 12 - 12, self.backlog_text_[i].text, 255, 255, 255, alpha * 255)\n\011\011\011end\n\011\011end\n\011\n\011\011if not floating then\n\011\011\011if self.backlog_marker_y_ then\n\011\011\011\011gfx.drawLine(self.pos_x_ + 1, self.pos_y_ + self.backlog_marker_y_, self.pos_x_ + self.width_ - 2, self.pos_y_ + self.backlog_marker_y_, 255, 50, 50)\n\011\011\011end\n\011\n\011\011\011gfx.drawLine(self.pos_x_ + 1, self.pos_y_ + self.height_ - 15, self.pos_x_ + self.width_ - 2, self.pos_y_ + self.height_ - 15, unpack(border_colour))\n\011\011\011if self.input_has_selection_ then\n\011\011\011\011gfx.fillRect(self.pos_x_ + self.input_sel_low_x_ + self.input_scroll_x_, self.pos_y_ + self.height_ - 13, self.input_sel_high_x_ - self.input_sel_low_x_, 11)\n\011\011\011end\n\011\011\011gfx.drawText(self.pos_x_ + 4 + self.input_text_1x_, self.pos_y_ + self.height_ - 11, self.input_text_1_)\n\011\011\011gfx.drawText(self.pos_x_ + 4 + self.input_text_2x_, self.pos_y_ + self.height_ - 11, self.input_text_2_, 0, 0, 0)\n\011\011\011gfx.drawText(self.pos_x_ + 4 + self.input_text_3x_, self.pos_y_ + self.height_ - 11, self.input_text_3_)\n\011\011\011if self.in_focus and now % 1 < 0.5 then\n\011\011\011\011gfx.drawLine(self.pos_x_ + self.input_cursor_x_ + self.input_scroll_x_, self.pos_y_ + self.height_ - 13, self.pos_x_ + self.input_cursor_x_ + self.input_scroll_x_, self.pos_y_ + self.height_ - 3)\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function window_i:handle_mousedown(px, py, button)\n\011\011if self.should_ignore_mouse_func_() then\n\011\011\011return\n\011\011end\n\011\011-- * TODO[opt]: mouse selection\n\011\011if button == sdl.SDL_BUTTON_LEFT then\n\011\011\011if util.inside_rect(self.pos_x_, self.pos_y_, self.width_, self.height_, util.mouse_pos()) then\n\011\011\011\011self.in_focus = true\n\011\011\011end\n\011\011\011if util.inside_rect(self.pos_x_, self.pos_y_, 15, 15, util.mouse_pos()) then\n\011\011\011\011self.resizer_active_ = true\n\011\011\011\011self.resizer_last_x_, self.resizer_last_y_ = util.mouse_pos()\n\011\011\011\011return true\n\011\011\011end\n\011\011\011if util.inside_rect(self.pos_x_ + 15, self.pos_y_, self.width_ - 30, 15, util.mouse_pos()) then\n\011\011\011\011self.dragger_active_ = true\n\011\011\011\011self.dragger_last_x_, self.dragger_last_y_ = util.mouse_pos()\n\011\011\011\011return true\n\011\011\011end\n\011\011\011if util.inside_rect(self.pos_x_ + self.width_ - 15, self.pos_y_, 15, 15, util.mouse_pos()) then\n\011\011\011\011self.close_active_ = true\n\011\011\011\011return true\n\011\011\011end\n\011\011elseif button == sdl.SDL_BUTTON_RIGHT then\n\011\011\011if util.inside_rect(self.pos_x_ + 1, self.pos_y_ + 15, self.width_ - 2, self.height_ - 30, util.mouse_pos()) then\n\011\011\011\011local _, y = util.mouse_pos()\n\011\011\011\011local line = 1 + math.floor((y - self.backlog_text_y_ - self.pos_y_) / 12)\n\011\011\011\011if self.backlog_lines_[line] then\n\011\011\011\011\011local collect = self.backlog_lines_[line].msg.collect\n\011\011\011\011\011local collect_sane = {}\n\011\011\011\011\011local i = 0\n\011\011\011\011\011while i < #collect do\n\011\011\011\011\011\011i = i + 1\n\011\011\011\011\011\011if collect[i] == \"\\15\" then\n\011\011\011\011\011\011\011i = i + 3\n\011\011\011\011\011\011elseif collect[i]:byte() >= 32 then\n\011\011\011\011\011\011\011table.insert(collect_sane, collect[i])\n\011\011\011\011\011\011end\n\011\011\011\011\011end\n\011\011\011\011\011plat.clipboardPaste(table.concat(collect_sane))\n\011\011\011\011\011self.log_event_func_(\"Message copied to clipboard\")\n\011\011\011\011end\n\011\011\011\011return true\n\011\011\011end\n\011\011end\n\011\011if util.inside_rect(self.pos_x_, self.pos_y_, self.width_, self.height_, util.mouse_pos()) then\n\011\011\011return true\n\011\011elseif self.in_focus then\n\011\011\011self.in_focus = false\n\011\011end\n\011end\n\011\n\011function window_i:handle_mouseup(px, py, button)\n\011\011if button == sdl.SDL_BUTTON_LEFT then\n\011\011\011if self.close_active_ then\n\011\011\011\011self.hide_window_func_()\n\011\011\011end\n\011\011\011self.resizer_active_ = false\n\011\011\011self.dragger_active_ = false\n\011\011\011self.close_active_ = false\n\011\011end\n\011end\n\011\n\011function window_i:handle_mousewheel(px, py, dir)\n\011\011if util.inside_rect(self.pos_x_, self.pos_y_ + 15, self.width_, self.height_ - 30, util.mouse_pos()) then\n\011\011\011self:backlog_wrap_(self.backlog_last_visible_msg_)\n\011\011\011if dir > 0 then\n\011\011\011\011if self.backlog_last_visible_line_ > 1 then\n\011\011\011\011\011self.backlog_last_visible_line_ = self.backlog_last_visible_line_ - 1\n\011\011\011\011\011self.backlog_auto_scroll_ = false\n\011\011\011\011elseif self.backlog_last_visible_msg_ ~= self.backlog_first_ then\n\011\011\011\011\011self.backlog_last_visible_msg_ = self.backlog_last_visible_msg_.prev\n\011\011\011\011\011self:backlog_wrap_(self.backlog_last_visible_msg_)\n\011\011\011\011\011self.backlog_last_visible_line_ = #self.backlog_last_visible_msg_.wrapped\n\011\011\011\011\011self.backlog_auto_scroll_ = false\n\011\011\011\011end\n\011\011\011else\n\011\011\011\011if self.backlog_last_visible_line_ < #self.backlog_last_visible_msg_.wrapped then\n\011\011\011\011\011self.backlog_last_visible_line_ = self.backlog_last_visible_line_ + 1\n\011\011\011\011elseif self.backlog_last_visible_msg_.next ~= self.backlog_last_ then\n\011\011\011\011\011self.backlog_last_visible_msg_ = self.backlog_last_visible_msg_.next\n\011\011\011\011\011self.backlog_last_visible_line_ = 1\n\011\011\011\011end\n\011\011\011\011self:backlog_wrap_(self.backlog_last_visible_msg_)\n\011\011\011\011if self.backlog_last_visible_msg_.next == self.backlog_last_ and self.backlog_last_visible_line_ == #self.backlog_last_visible_msg_.wrapped then\n\011\011\011\011\011self.backlog_auto_scroll_ = true\n\011\011\011\011end\n\011\011\011end\n\011\011\011self:backlog_update_()\n\011\011\011return true\n\011\011end\n\011\011if util.inside_rect(self.pos_x_, self.pos_y_, self.width_, self.height_, util.mouse_pos()) then\n\011\011\011return true\n\011\011end\n\011end\n\011\n\011local modkey_scan = {\n\011\011[ sdl.SDL_SCANCODE_LCTRL  ] = true,\n\011\011[ sdl.SDL_SCANCODE_LSHIFT ] = true,\n\011\011[ sdl.SDL_SCANCODE_LALT   ] = true,\n\011\011[ sdl.SDL_SCANCODE_RCTRL  ] = true,\n\011\011[ sdl.SDL_SCANCODE_RSHIFT ] = true,\n\011\011[ sdl.SDL_SCANCODE_RALT   ] = true,\n\011}\n\011function window_i:handle_keypress(key, scan, rep, shift, ctrl, alt)\n\011\011if not self.in_focus and self.window_status_func_() == \"shown\" and scan == sdl.SDL_SCANCODE_RETURN then\n\011\011\011self.in_focus = true\n\011\011\011return true\n\011\011end\n\011\011if self.in_focus then\n\011\011\011if not ctrl and not alt and scan == sdl.SDL_SCANCODE_ESCAPE then\n\011\011\011\011if self.in_focus then\n\011\011\011\011\011self.in_focus = false\n\011\011\011\011\011self.input_autocomplete_ = nil\n\011\011\011\011\011local force_hide = false\n\011\011\011\011\011if self.hide_when_chat_done then\n\011\011\011\011\011\011self.hide_when_chat_done = false\n\011\011\011\011\011\011force_hide = true\n\011\011\011\011\011\011self:input_reset_()\n\011\011\011\011\011end\n\011\011\011\011\011if shift or force_hide then\n\011\011\011\011\011\011self.hide_window_func_()\n\011\011\011\011\011end\n\011\011\011\011else\n\011\011\011\011\011self.in_focus = true\n\011\011\011\011end\n\011\011\011elseif not ctrl and not shift and not alt and scan == sdl.SDL_SCANCODE_TAB then\n\011\011\011\011local left_word_first, left_word\n\011\011\011\011local cursor = self.input_cursor_\n\011\011\011\011local check_offset = 0\n\011\011\011\011while self.input_collect_[cursor + check_offset] and not self.input_collect_[cursor + check_offset]:find(config.whitespace_pattern) do\n\011\011\011\011\011check_offset = check_offset - 1\n\011\011\011\011end\n\011\011\011\011if check_offset < 0 then\n\011\011\011\011\011left_word_first = cursor + check_offset + 1\n\011\011\011\011\011left_word = table.concat(self.input_collect_, \"\", left_word_first, cursor)\n\011\011\011\011end\n\011\011\011\011local cli = self.client_func_()\n\011\011\011\011if left_word and cli then\n\011\011\011\011\011left_word = left_word:lower()\n\011\011\011\011\011if self.input_autocomplete_ and not left_word:find(\"^\" .. util.escape_regex(self.input_autocomplete_)) then\n\011\011\011\011\011\011self.input_autocomplete_ = nil\n\011\011\011\011\011end\n\011\011\011\011\011if not self.input_autocomplete_ then\n\011\011\011\011\011\011self.input_autocomplete_ = left_word\n\011\011\011\011\011end\n\011\011\011\011\011local nicks = {}\n\011\011\011\011\011local function try_complete(nick)\n\011\011\011\011\011\011if nick:lower():find(\"^\" .. util.escape_regex(self.input_autocomplete_)) then\n\011\011\011\011\011\011\011table.insert(nicks, nick)\n\011\011\011\011\011\011end\n\011\011\011\011\011end\n\011\011\011\011\011try_complete(cli:nick())\n\011\011\011\011\011for _, member in pairs(cli.id_to_member) do\n\011\011\011\011\011\011try_complete(member.nick)\n\011\011\011\011\011end\n\011\011\011\011\011if next(nicks) then\n\011\011\011\011\011\011table.sort(nicks)\n\011\011\011\011\011\011local index = 1\n\011\011\011\011\011\011for i = 1, #nicks do\n\011\011\011\011\011\011\011if nicks[i] == left_word and nicks[i + 1] then\n\011\011\011\011\011\011\011\011index = i + 1\n\011\011\011\011\011\011\011end\n\011\011\011\011\011\011end\n\011\011\011\011\011\011self.input_sel_first_ = left_word_first - 1\n\011\011\011\011\011\011self.input_sel_second_ = cursor\n\011\011\011\011\011\011self:input_update_()\n\011\011\011\011\011\011self:input_insert_(nicks[index])\n\011\011\011\011\011end\n\011\011\011\011else\n\011\011\011\011\011self.input_autocomplete_ = nil\n\011\011\011\011end\n\011\011\011elseif not shift and not alt and (scan == sdl.SDL_SCANCODE_BACKSPACE or scan == sdl.SDL_SCANCODE_DELETE) then\n\011\011\011\011local start, length\n\011\011\011\011if self.input_has_selection_ then\n\011\011\011\011\011start = self.input_sel_low_\n\011\011\011\011\011length = self.input_sel_high_ - self.input_sel_low_\n\011\011\011\011\011self.input_cursor_ = self.input_sel_low_\n\011\011\011\011elseif (scan == sdl.SDL_SCANCODE_BACKSPACE and self.input_cursor_ > 0) or (scan == sdl.SDL_SCANCODE_DELETE and self.input_cursor_ < #self.input_collect_) then\n\011\011\011\011\011if ctrl then\n\011\011\011\011\011\011local cursor_step = scan == sdl.SDL_SCANCODE_DELETE and 1 or -1\n\011\011\011\011\011\011local check_offset = scan == sdl.SDL_SCANCODE_DELETE and 1 or  0\n\011\011\011\011\011\011local cursor = self.input_cursor_\n\011\011\011\011\011\011while self.input_collect_[cursor + check_offset] and self.input_collect_[cursor + check_offset]:find(config.whitespace_pattern) do\n\011\011\011\011\011\011\011cursor = cursor + cursor_step\n\011\011\011\011\011\011end\n\011\011\011\011\011\011while self.input_collect_[cursor + check_offset] and self.input_collect_[cursor + check_offset]:find(config.word_pattern) do\n\011\011\011\011\011\011\011cursor = cursor + cursor_step\n\011\011\011\011\011\011end\n\011\011\011\011\011\011if cursor == self.input_cursor_ then\n\011\011\011\011\011\011\011cursor = cursor + cursor_step\n\011\011\011\011\011\011end\n\011\011\011\011\011\011start = self.input_cursor_\n\011\011\011\011\011\011length = cursor - self.input_cursor_\n\011\011\011\011\011\011if length < 0 then\n\011\011\011\011\011\011\011start = start + length\n\011\011\011\011\011\011\011length = -length\n\011\011\011\011\011\011end\n\011\011\011\011\011\011self.input_cursor_ = start\n\011\011\011\011\011else\n\011\011\011\011\011\011if scan == sdl.SDL_SCANCODE_BACKSPACE then\n\011\011\011\011\011\011\011self.input_cursor_ = self.input_cursor_ - 1\n\011\011\011\011\011\011end\n\011\011\011\011\011\011start = self.input_cursor_\n\011\011\011\011\011\011length = 1\n\011\011\011\011\011end\n\011\011\011\011end\n\011\011\011\011if start then\n\011\011\011\011\011self:input_remove_(start, length)\n\011\011\011\011\011self:input_update_()\n\011\011\011\011end\n\011\011\011\011self.input_autocomplete_ = nil\n\011\011\011elseif not ctrl and not shift and not alt and scan == sdl.SDL_SCANCODE_RETURN then\n\011\011\011\011if #self.input_collect_ > 0 then\n\011\011\011\011\011local str = self:input_text_to_send_()\n\011\011\011\011\011local sent = str ~= \"\" and not self.message_overlong_\n\011\011\011\011\011if sent then\n\011\011\011\011\011\011local cli = self.client_func_()\n\011\011\011\011\011\011if self.localcmd and self.localcmd:parse(str) then\n\011\011\011\011\011\011\011-- * Nothing.\n\011\011\011\011\011\011elseif cli then\n\011\011\011\011\011\011\011local cps = utf8.code_points(str)\n\011\011\011\011\011\011\011local last = 0\n\011\011\011\011\011\011\011for i = 1, #cps do\n\011\011\011\011\011\011\011\011local new_last = cps[i].pos + cps[i].size - 1\n\011\011\011\011\011\011\011\011if new_last > config.message_size then\n\011\011\011\011\011\011\011\011\011break\n\011\011\011\011\011\011\011\011end\n\011\011\011\011\011\011\011\011last = new_last\n\011\011\011\011\011\011\011end\n\011\011\011\011\011\011\011local now = socket.gettime()\n\011\011\011\011\011\011\011if self.input_last_say_ + config.message_interval >= now then\n\011\011\011\011\011\011\011\011sent = false\n\011\011\011\011\011\011\011else\n\011\011\011\011\011\011\011\011self.input_last_say_  = now\n\011\011\011\011\011\011\011\011local limited_str = str:sub(1, last)\n\011\011\011\011\011\011\011\011self:backlog_push_say(cli:formatted_nick(), limited_str:gsub(\"^//\", \"/\"))\n\011\011\011\011\011\011\011\011cli:send_say(limited_str)\n\011\011\011\011\011\011\011end\n\011\011\011\011\011\011else\n\011\011\011\011\011\011\011self:backlog_push_error(\"Not connected, message not sent\")\n\011\011\011\011\011\011end\n\011\011\011\011\011end\n\011\011\011\011\011if sent then\n\011\011\011\011\011\011self.input_history_[self.input_history_next_] = self.input_editing_[self.input_history_select_]\n\011\011\011\011\011\011self.input_history_next_ = self.input_history_next_ + 1\n\011\011\011\011\011\011self.input_history_[self.input_history_next_] = {}\n\011\011\011\011\011\011self.input_history_[self.input_history_next_ - config.history_size] = nil\n\011\011\011\011\011\011self:input_reset_()\n\011\011\011\011\011\011if self.hide_when_chat_done then\n\011\011\011\011\011\011\011self.hide_when_chat_done = false\n\011\011\011\011\011\011\011self.in_focus = false\n\011\011\011\011\011\011\011self.hide_window_func_()\n\011\011\011\011\011\011end\n\011\011\011\011\011end\n\011\011\011\011else\n\011\011\011\011\011self.in_focus = false\n\011\011\011\011end\n\011\011\011\011self.input_autocomplete_ = nil\n\011\011\011elseif not ctrl and not shift and not alt and scan == sdl.SDL_SCANCODE_UP then\n\011\011\011\011local to_select = self.input_history_select_ - 1\n\011\011\011\011if self.input_history_[to_select] then\n\011\011\011\011\011self:input_select_(to_select)\n\011\011\011\011end\n\011\011\011\011self.input_autocomplete_ = nil\n\011\011\011elseif not ctrl and not shift and not alt and scan == sdl.SDL_SCANCODE_DOWN then\n\011\011\011\011local to_select = self.input_history_select_ + 1\n\011\011\011\011if self.input_history_[to_select] then\n\011\011\011\011\011self:input_select_(to_select)\n\011\011\011\011end\n\011\011\011\011self.input_autocomplete_ = nil\n\011\011\011elseif not alt and (scan == sdl.SDL_SCANCODE_HOME or scan == sdl.SDL_SCANCODE_END or scan == sdl.SDL_SCANCODE_RIGHT or scan == sdl.SDL_SCANCODE_LEFT) then\n\011\011\011\011self.input_cursor_prev_ = self.input_cursor_\n\011\011\011\011if scan == sdl.SDL_SCANCODE_HOME then\n\011\011\011\011\011self.input_cursor_ = 0\n\011\011\011\011elseif scan == sdl.SDL_SCANCODE_END then\n\011\011\011\011\011self.input_cursor_ = #self.input_collect_\n\011\011\011\011else\n\011\011\011\011\011if (scan == sdl.SDL_SCANCODE_RIGHT and self.input_cursor_ < #self.input_collect_) or (scan == sdl.SDL_SCANCODE_LEFT and self.input_cursor_ > 0) then\n\011\011\011\011\011\011local cursor_step = scan == sdl.SDL_SCANCODE_RIGHT and 1 or -1\n\011\011\011\011\011\011local check_offset = scan == sdl.SDL_SCANCODE_RIGHT and 1 or  0\n\011\011\011\011\011\011if ctrl then\n\011\011\011\011\011\011\011local cursor = self.input_cursor_\n\011\011\011\011\011\011\011while self.input_collect_[cursor + check_offset] and self.input_collect_[cursor + check_offset]:find(config.whitespace_pattern) do\n\011\011\011\011\011\011\011\011cursor = cursor + cursor_step\n\011\011\011\011\011\011\011end\n\011\011\011\011\011\011\011while self.input_collect_[cursor + check_offset] and self.input_collect_[cursor + check_offset]:find(config.word_pattern) do\n\011\011\011\011\011\011\011\011cursor = cursor + cursor_step\n\011\011\011\011\011\011\011end\n\011\011\011\011\011\011\011if cursor == self.input_cursor_ then\n\011\011\011\011\011\011\011\011cursor = cursor + cursor_step\n\011\011\011\011\011\011\011end\n\011\011\011\011\011\011\011self.input_cursor_ = cursor\n\011\011\011\011\011\011else\n\011\011\011\011\011\011\011self.input_cursor_ = self.input_cursor_ + cursor_step\n\011\011\011\011\011\011end\n\011\011\011\011\011end\n\011\011\011\011end\n\011\011\011\011if shift then\n\011\011\011\011\011if self.input_sel_first_ == self.input_sel_second_ then\n\011\011\011\011\011\011self.input_sel_first_ = self.input_cursor_prev_\n\011\011\011\011\011end\n\011\011\011\011else\n\011\011\011\011\011self.input_sel_first_ = self.input_cursor_\n\011\011\011\011end\n\011\011\011\011self.input_sel_second_ = self.input_cursor_\n\011\011\011\011self:input_update_()\n\011\011\011\011self.input_autocomplete_ = nil\n\011\011\011elseif ctrl and not shift and not alt and scan == sdl.SDL_SCANCODE_A then\n\011\011\011\011self.input_cursor_ = #self.input_collect_\n\011\011\011\011self.input_sel_first_ = 0\n\011\011\011\011self.input_sel_second_ = self.input_cursor_\n\011\011\011\011self:input_update_()\n\011\011\011\011self.input_autocomplete_ = nil\n\011\011\011elseif ctrl and not shift and not alt and scan == sdl.SDL_SCANCODE_C then\n\011\011\011\011if self.input_has_selection_ then\n\011\011\011\011\011plat.clipboardPaste(self:input_collect_range_(self.input_sel_low_ + 1, self.input_sel_high_))\n\011\011\011\011end\n\011\011\011\011self.input_autocomplete_ = nil\n\011\011\011elseif ctrl and not shift and not alt and scan == sdl.SDL_SCANCODE_V then\n\011\011\011\011local text = plat.clipboardCopy()\n\011\011\011\011if text then\n\011\011\011\011\011self:input_insert_(text)\n\011\011\011\011end\n\011\011\011\011self.input_autocomplete_ = nil\n\011\011\011elseif ctrl and not shift and not alt and scan == sdl.SDL_SCANCODE_X then\n\011\011\011\011if self.input_has_selection_ then\n\011\011\011\011\011local start = self.input_sel_low_\n\011\011\011\011\011local length = self.input_sel_high_ - self.input_sel_low_\n\011\011\011\011\011self.input_cursor_ = self.input_sel_low_\n\011\011\011\011\011plat.clipboardPaste(self:input_collect_range_(self.input_sel_low_ + 1, self.input_sel_high_))\n\011\011\011\011\011self:input_remove_(start, length)\n\011\011\011\011\011self:input_update_()\n\011\011\011\011end\n\011\011\011\011self.input_autocomplete_ = nil\n\011\011\011end\n\011\011\011return not modkey_scan[scan]\n\011\011else\n\011\011\011if not ctrl and not alt and scan == sdl.SDL_SCANCODE_ESCAPE then\n\011\011\011\011self.hide_window_func_()\n\011\011\011\011return true\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function window_i:handle_keyrelease(key, scan, rep, shift, ctrl, alt)\n\011\011if self.in_focus then\n\011\011\011return not modkey_scan[scan]\n\011\011end\n\011end\n\011\n\011function window_i:handle_textinput(text)\n\011\011if self.in_focus then\n\011\011\011self:input_insert_(text)\n\011\011\011self.input_autocomplete_ = nil\n\011\011\011return true\n\011\011end\n\011end\n\011\n\011function window_i:handle_textediting(text)\n\011\011if self.in_focus then\n\011\011\011return true\n\011\011end\n\011end\n\011\n\011function window_i:handle_blur()\n\011end\n\011\n\011function window_i:save_window_rect_()\n\011\011manager.set(\"windowLeft\", tostring(self.pos_x_))\n\011\011manager.set(\"windowTop\", tostring(self.pos_y_))\n\011\011manager.set(\"windowWidth\", tostring(self.width_))\n\011\011manager.set(\"windowHeight\", tostring(self.height_))\n\011\011manager.set(\"windowAlpha\", tostring(self.alpha_))\n\011end\n\011\n\011function window_i:insert_wrapped_line_(tbl, msg, line)\n\011\011table.insert(tbl, {\n\011\011\011wrapped = msg.wrapped[line],\n\011\011\011needs_padding = line > 1,\n\011\011\011extend_box = line < #msg.wrapped,\n\011\011\011msg = msg,\n\011\011\011marker = self.backlog_marker_at_ == msg.unique and #msg.wrapped == line,\n\011\011})\n\011end\n\011\n\011function window_i:set_size(new_width, new_height)\n\011\011self.width_ = math.min(math.max(new_width, config.min_width), sim.XRES - 1)\n\011\011self.height_ = math.min(math.max(new_height, config.min_height), sim.YRES - 1)\n\011\011self.pos_x_ = math.min(math.max(1, self.pos_x_), sim.XRES - self.width_)\n\011\011self.pos_y_ = math.min(math.max(1, self.pos_y_), sim.YRES - self.height_)\n\011\011self:input_update_()\n\011\011self:backlog_update_()\n\011\011self:subtitle_update_()\n\011\011self:save_window_rect_()\n\011end\n\011\n\011function window_i:subtitle_update_()\n\011\011self.subtitle_text_ = self.subtitle_secondary_ or self.subtitle_\n\011\011local max_width = self.width_ - self.title_width_ - 43\n\011\011if gfx.textSize(self.subtitle_text_) > max_width then\n\011\011\011self.subtitle_text_ = self.subtitle_text_:sub(1, util.binary_search_implicit(1, #self.subtitle_text_, function(idx)\n\011\011\011\011local str = self.subtitle_text_:sub(1, idx)\n\011\011\011\011str = str:gsub(\"\\15[\\194\\195].\", \"\\15\"):gsub(\"\\15[^\\128-\\255]\", \"\\15\")\n\011\011\011\011str = str:gsub(\"\\15[\\194\\195].\", \"\\15\"):gsub(\"\\15[^\\128-\\255]\", \"\\15\")\n\011\011\011\011str = str:gsub(\"\\15[\\194\\195].\", \"\\15\"):gsub(\"\\15[^\\128-\\255]\", \"\\15\")\n\011\011\011\011str = str:gsub(\"\\15\", \"\")\n\011\011\011\011return gfx.textSize(str .. \"...\") > max_width\n\011\011\011end) - 1) .. \"...\"\n\011\011end\n\011end\n\011\n\011function window_i:input_select_(history_index)\n\011\011self.input_history_select_ = history_index\n\011\011local editing = self.input_editing_[history_index]\n\011\011if not editing then\n\011\011\011editing = {}\n\011\011\011local original = self.input_history_[history_index]\n\011\011\011for i = 1, #original do\n\011\011\011\011editing[i] = original[i]\n\011\011\011end\n\011\011\011self.input_editing_[history_index] = editing\n\011\011end\n\011\011self.input_collect_ = editing\n\011\011self.input_cursor_ = #self.input_collect_\n\011\011self.input_sel_first_ = self.input_cursor_\n\011\011self.input_sel_second_ = self.input_cursor_\n\011\011self:input_update_()\n\011end\n\011\n\011function window_i:input_reset_()\n\011\011self.input_editing_ = {}\n\011\011self:input_select_(self.input_history_next_)\n\011end\n\011\n\011function window_i:input_remove_(start, length)\n\011\011for i = start + 1, #self.input_collect_ - length do\n\011\011\011self.input_collect_[i] = self.input_collect_[i + length]\n\011\011end\n\011\011for i = #self.input_collect_, #self.input_collect_ - length + 1, -1 do\n\011\011\011self.input_collect_[i] = nil\n\011\011end\n\011\011self.input_sel_first_ = self.input_cursor_\n\011\011self.input_sel_second_ = self.input_cursor_\n\011end\n\011\n\011function window_i:input_insert_(text)\n\011\011local cps = {}\n\011\011local unfiltered_cps = utf8.code_points(text)\n\011\011if unfiltered_cps then\n\011\011\011for i = 1, #unfiltered_cps do\n\011\011\011\011if unfiltered_cps[i].cp >= 32 then\n\011\011\011\011\011table.insert(cps, unfiltered_cps[i])\n\011\011\011\011end\n\011\011\011end\n\011\011end\n\011\011if #cps > 0 then\n\011\011\011if self.input_has_selection_ then\n\011\011\011\011local start = self.input_sel_low_\n\011\011\011\011local length = self.input_sel_high_ - self.input_sel_low_\n\011\011\011\011self.input_cursor_ = self.input_sel_low_\n\011\011\011\011self:input_remove_(start, length)\n\011\011\011end\n\011\011\011for i = #self.input_collect_, self.input_cursor_ + 1, -1 do\n\011\011\011\011self.input_collect_[i + #cps] = self.input_collect_[i]\n\011\011\011end\n\011\011\011for i = 1, #cps do\n\011\011\011\011self.input_collect_[self.input_cursor_ + i] = text:sub(cps[i].pos, cps[i].pos + cps[i].size - 1)\n\011\011\011end\n\011\011\011self.input_cursor_ = self.input_cursor_ + #cps\n\011\011\011self:input_update_()\n\011\011end\n\011end\n\011\n\011function window_i:input_clamp_text_(start, first, last)\n\011\011local shave_off_left = -start\n\011\011local shave_off_right = gfx.textSize(self:input_collect_range_(first, last)) + start - self.width_ + 10\n\011\011local new_first = util.binary_search_implicit(first, last, function(pos)\n\011\011\011return gfx.textSize(self:input_collect_range_(first, pos - 1)) >= shave_off_left\n\011\011end)\n\011\011local new_last = util.binary_search_implicit(first, last, function(pos)\n\011\011\011return gfx.textSize(self:input_collect_range_(pos, last)) < shave_off_right\n\011\011end) - 1\n\011\011local new_start = start + gfx.textSize(self:input_collect_range_(first, new_first - 1))\n\011\011return new_start, self:input_collect_range_(new_first, new_last)\n\011end\n\011\n\011function window_i:input_update_()\n\011\011self.input_sel_low_ = math.min(self.input_sel_first_, self.input_sel_second_)\n\011\011self.input_sel_high_ = math.max(self.input_sel_first_, self.input_sel_second_)\n\011\011self.input_text_1_ = self:input_collect_range_(1, self.input_sel_low_)\n\011\011self.input_text_1w_ = gfx.textSize(self.input_text_1_)\n\011\011self.input_text_2_ = self:input_collect_range_(self.input_sel_low_ + 1, self.input_sel_high_)\n\011\011self.input_text_2w_ = gfx.textSize(self.input_text_2_)\n\011\011self.input_text_3_ = self:input_collect_range_(self.input_sel_high_ + 1, #self.input_collect_)\n\011\011self.input_text_3w_ = gfx.textSize(self.input_text_3_)\n\011\011self.input_cursor_x_ = 4 + gfx.textSize(self:input_collect_range_(1, self.input_cursor_))\n\011\011self.input_sel_low_x_ = 3 + self.input_text_1w_\n\011\011self.input_sel_high_x_ = self.input_sel_low_x_ + 1 + self.input_text_2w_\n\011\011self.input_has_selection_ = self.input_sel_first_ ~= self.input_sel_second_\n\011\011local min_cursor_x = 4\n\011\011local max_cursor_x = self.width_ - 5\n\011\011if self.input_cursor_x_ + self.input_scroll_x_ < min_cursor_x then\n\011\011\011self.input_scroll_x_ = min_cursor_x - self.input_cursor_x_\n\011\011end\n\011\011if self.input_cursor_x_ + self.input_scroll_x_ > max_cursor_x then\n\011\011\011self.input_scroll_x_ = max_cursor_x - self.input_cursor_x_\n\011\011end\n\011\011local min_if_active = self.width_ - self.input_text_1w_ - self.input_text_2w_ - self.input_text_3w_ - 9\n\011\011if self.input_scroll_x_ < 0 and self.input_scroll_x_ < min_if_active then\n\011\011\011self.input_scroll_x_ = min_if_active\n\011\011end\n\011\011if min_if_active > 0 then\n\011\011\011self.input_scroll_x_ = 0\n\011\011end\n\011\011if self.input_sel_low_x_ < 1 - self.input_scroll_x_ then\n\011\011\011self.input_sel_low_x_ = 1 - self.input_scroll_x_\n\011\011end\n\011\011if self.input_sel_high_x_ > self.width_ - self.input_scroll_x_ - 1 then\n\011\011\011self.input_sel_high_x_ = self.width_ - self.input_scroll_x_ - 1\n\011\011end\n\011\011self.input_text_1x_ = self.input_scroll_x_\n\011\011self.input_text_2x_ = self.input_text_1x_ + self.input_text_1w_\n\011\011self.input_text_3x_ = self.input_text_2x_ + self.input_text_2w_\n\011\011self.input_text_1x_, self.input_text_1_ = self:input_clamp_text_(self.input_text_1x_, 1, self.input_sel_low_)\n\011\011self.input_text_2x_, self.input_text_2_ = self:input_clamp_text_(self.input_text_2x_, self.input_sel_low_ + 1, self.input_sel_high_)\n\011\011self.input_text_3x_, self.input_text_3_ = self:input_clamp_text_(self.input_text_3x_, self.input_sel_high_ + 1, #self.input_collect_)\n\011\011self:set_subtitle_secondary(self:input_status_())\n\011end\n\011\n\011function window_i:input_text_to_send_()\n\011\011return self:input_collect_range_():gsub(\"[\\1-\\31]\", \"\"):gsub(\"^ *(.-) *$\", \"%1\")\n\011end\n\011\n\011function window_i:input_status_()\n\011\011if #self.input_collect_ == 0 then\n\011\011\011return\n\011\011end\n\011\011local str = self:input_text_to_send_()\n\011\011local max_size = config.message_size\n\011\011if str:find(\"^/\") and not str:find(\"^//\") then\n\011\011\011max_size = 255\n\011\011end\n\011\011local byte_length = #str\n\011\011local bytes_left = max_size - byte_length\n\011\011if bytes_left < 0 then\n\011\011\011self.message_overlong_ = true\n\011\011\011return colours.commonstr.error .. tostring(bytes_left)\n\011\011else\n\011\011\011self.message_overlong_ = nil\n\011\011\011return tostring(bytes_left)\n\011\011end\n\011end\n\011\n\011function window_i:input_collect_range_(first, last)\n\011\011return table.concat(self.input_collect_, nil, first, last)\n\011end\n\011\n\011function window_i:set_subtitle(template, text)\n\011\011if template == \"status\" then\n\011\011\011self.subtitle_ = colours.commonstr.status .. text\n\011\011elseif template == \"room\" then\n\011\011\011self.subtitle_ = \"In \" .. format.troom(text)\n\011\011end\n\011\011self:subtitle_update_()\n\011end\n\011\n\011function window_i:set_subtitle_secondary(formatted_text)\n\011\011self.subtitle_secondary_ = formatted_text\n\011\011self:subtitle_update_()\n\011end\n\011\n\011local function new(params)\n\011\011local pos_x = tonumber(manager.get(\"windowLeft\", \"\")) or config.default_x\n\011\011local pos_y = tonumber(manager.get(\"windowTop\", \"\")) or config.default_y\n\011\011local width = tonumber(manager.get(\"windowWidth\", \"\")) or config.default_width\n\011\011local height = tonumber(manager.get(\"windowHeight\", \"\")) or config.default_height\n\011\011local alpha = tonumber(manager.get(\"windowAlpha\", \"\")) or config.default_alpha\n\011\011local title = \"TPT Multiplayer \" .. config.versionstr\n\011\011local title_width = gfx.textSize(title)\n\011\011local win = setmetatable({\n\011\011\011in_focus = false,\n\011\011\011pos_x_ = pos_x,\n\011\011\011pos_y_ = pos_y,\n\011\011\011width_ = width,\n\011\011\011height_ = height,\n\011\011\011alpha_ = alpha,\n\011\011\011title_ = title,\n\011\011\011title_width_ = title_width,\n\011\011\011input_scroll_x_ = 0,\n\011\011\011resizer_active_ = false,\n\011\011\011dragger_active_ = false,\n\011\011\011close_active_ = false,\n\011\011\011window_status_func_ = params.window_status_func,\n\011\011\011log_event_func_ = params.log_event_func,\n\011\011\011client_func_ = params.client_func,\n\011\011\011hide_window_func_ = params.hide_window_func,\n\011\011\011should_ignore_mouse_func_ = params.should_ignore_mouse_func,\n\011\011\011input_history_ = { {} },\n\011\011\011input_history_next_ = 1,\n\011\011\011input_editing_ = {},\n\011\011\011input_last_say_ = 0,\n\011\011\011nick_colour_seed_ = 0,\n\011\011\011hide_when_chat_done = false,\n\011\011}, window_m)\n\011\011win:input_reset_()\n\011\011win:backlog_reset()\n\011\011return win\n\011end\n\011\n\011return {\n\011\011new = new,\n\011}\n\011\nend\n\nrequire_preload__[\"tptmp.common.buffer_list\"] = function()\n\n\011local buffer_list_i = {}\n\011local buffer_list_m = { __index = buffer_list_i }\n\011\n\011function buffer_list_i:push(data)\n\011\011local count = #data\n\011\011local want = count\n\011\011if self.limit then\n\011\011\011want = math.min(want, self.limit - self:pending())\n\011\011end\n\011\011if want > 0 then\n\011\011\011local buf = {\n\011\011\011\011data = data,\n\011\011\011\011curr = 0,\n\011\011\011\011last = want,\n\011\011\011\011prev = self.last_.prev,\n\011\011\011\011next = self.last_,\n\011\011\011}\n\011\011\011self.last_.prev.next = buf\n\011\011\011self.last_.prev = buf\n\011\011\011self.pushed_ = self.pushed_ + want\n\011\011end\n\011\011return want, count\n\011end\n\011\n\011function buffer_list_i:next()\n\011\011local buf = self.first_.next\n\011\011if buf == self.last_ then\n\011\011\011return\n\011\011end\n\011\011return buf.data, buf.curr + 1, buf.last\n\011end\n\011\n\011function buffer_list_i:pop(count)\n\011\011local buf = self.first_.next\n\011\011assert(buf ~= self.last_)\n\011\011assert(buf.last - buf.curr >= count)\n\011\011buf.curr = buf.curr + count\n\011\011if buf.curr == buf.last then\n\011\011\011buf.prev.next = buf.next\n\011\011\011buf.next.prev = buf.prev\n\011\011end\n\011\011self.popped_ = self.popped_ + count\n\011end\n\011\n\011function buffer_list_i:pushed()\n\011\011return self.pushed_\n\011end\n\011\n\011function buffer_list_i:popped()\n\011\011return self.popped_\n\011end\n\011\n\011function buffer_list_i:pending()\n\011\011return self.pushed_ - self.popped_\n\011end\n\011\n\011function buffer_list_i:get(count)\n\011\011assert(count <= self.pushed_ - self.popped_)\n\011\011local collect = {}\n\011\011while count > 0 do\n\011\011\011local data, first, last = self:next()\n\011\011\011local want = math.min(count, last - first + 1)\n\011\011\011local want_last = first - 1 + want\n\011\011\011table.insert(collect, first == 1 and want_last == #data and data or data:sub(first, want_last))\n\011\011\011self:pop(want)\n\011\011\011count = count - want\n\011\011end\n\011\011return table.concat(collect)\n\011end\n\011\n\011local function new(params)\n\011\011local bl = setmetatable({\n\011\011\011first_ = {},\n\011\011\011last_ = {},\n\011\011\011limit = params.limit,\n\011\011\011pushed_ = 0,\n\011\011\011popped_ = 0,\n\011\011}, buffer_list_m)\n\011\011bl.first_.next = bl.last_\n\011\011bl.last_.prev = bl.first_\n\011\011return bl\n\011end\n\011\n\011return {\n\011\011new = new,\n\011}\n\011\nend\n\nrequire_preload__[\"tptmp.common.command_parser\"] = function()\n\n\011local command_parser_i = {}\n\011local command_parser_m = { __index = command_parser_i }\n\011\n\011function command_parser_i:parse(ctx, message)\n\011\011local words = {}\n\011\011local offsets = {}\n\011\011for offset, word in message:gmatch(\"()(%S+)\") do\n\011\011\011table.insert(offsets, offset)\n\011\011\011table.insert(words, word)\n\011\011end\n\011\011if not words[1] then\n\011\011\011self:list_(ctx)\n\011\011\011return\n\011\011end\n\011\011local initial_cmd = words[1]\n\011\011words[1] = words[1]:lower()\n\011\011while true do\n\011\011\011local cmd = self.commands_[self.aliases_[words[1]] or words[1]]\n\011\011\011if not cmd then\n\011\011\011\011if self.cmd_fallback_ then\n\011\011\011\011\011if self.cmd_fallback_(ctx, message) then\n\011\011\011\011\011\011return\n\011\011\011\011\011end\n\011\011\011\011end\n\011\011\011\011self.respond_(ctx, self.unknown_format_)\n\011\011\011\011return\n\011\011\011end\n\011\011\011if cmd.macro then\n\011\011\011\011words = cmd.macro(ctx, message, words, offsets)\n\011\011\011\011if not words then\n\011\011\011\011\011self:help_(ctx, initial_cmd)\n\011\011\011\011\011return\n\011\011\011\011end\n\011\011\011\011if #words == 0 then\n\011\011\011\011\011return\n\011\011\011\011end\n\011\011\011\011words[1] = words[1]:lower()\n\011\011\011\011offsets = {}\n\011\011\011\011local offset = 0\n\011\011\011\011for i = 1, #words do\n\011\011\011\011\011offsets[i] = offset + 1\n\011\011\011\011\011offset = offset + #words[i] + 1\n\011\011\011\011end\n\011\011\011\011message = table.concat(words, \" \")\n\011\011\011else\n\011\011\011\011local ok = cmd.func(ctx, message, words, offsets)\n\011\011\011\011if not ok then\n\011\011\011\011\011self:help_(ctx, initial_cmd)\n\011\011\011\011end\n\011\011\011\011return\n\011\011\011end\n\011\011end\n\011end\n\011\n\011function command_parser_i:list_(ctx)\n\011\011self.respond_(ctx, self.list_format_:format(self.list_str_))\n\011\011if self.list_extra_ then\n\011\011\011self.list_extra_(ctx)\n\011\011end\n\011\011return true\n\011end\n\011\n\011function command_parser_i:help_(ctx, from)\n\011\011from = from or self.help_name_\n\011\011local initial_from = from\n\011\011from = from:lower()\n\011\011local to = self.aliases_[from]\n\011\011if to then\n\011\011\011self.respond_(ctx, self.alias_format_:format(from, to))\n\011\011\011from = to\n\011\011end\n\011\011local cmd = self.commands_[from]\n\011\011if cmd then\n\011\011\011self.respond_(ctx, self.help_format_:format(cmd.help))\n\011\011\011return true\n\011\011end\n\011\011if self.help_fallback_ then\n\011\011\011if self.help_fallback_(ctx, initial_from) then\n\011\011\011\011return true\n\011\011\011end\n\011\011end\n\011\011self.respond_(ctx, self.unknown_format_)\n\011\011return true\n\011end\n\011\n\011local function new(params)\n\011\011local cmd = setmetatable({\n\011\011\011respond_ = params.respond,\n\011\011\011help_fallback_ = params.help_fallback,\n\011\011\011list_extra_ = params.list_extra,\n\011\011\011help_format_ = params.help_format,\n\011\011\011alias_format_ = params.alias_format,\n\011\011\011list_format_ = params.list_format,\n\011\011\011unknown_format_ = params.unknown_format,\n\011\011\011cmd_fallback_ = params.cmd_fallback,\n\011\011\011commands_ = {},\n\011\011\011aliases_ = {},\n\011\011}, command_parser_m)\n\011\011local collect = {}\n\011\011for name, info in pairs(params.commands) do\n\011\011\011if not info.hidden then\n\011\011\011\011table.insert(collect, \"/\" .. name)\n\011\011\011end\n\011\011\011name = name:lower()\n\011\011\011if info.role == \"help\" then\n\011\011\011\011cmd.help_name_ = name\n\011\011\011\011cmd.commands_[name] = {\n\011\011\011\011\011func = function(ctx, _, words)\n\011\011\011\011\011\011cmd:help_(ctx, words[2])\n\011\011\011\011\011\011return true\n\011\011\011\011\011end,\n\011\011\011\011\011help = info.help,\n\011\011\011\011}\n\011\011\011elseif info.role == \"list\" then\n\011\011\011\011cmd.commands_[name] = {\n\011\011\011\011\011func = function(ctx)\n\011\011\011\011\011\011cmd:list_(ctx)\n\011\011\011\011\011\011return true\n\011\011\011\011\011end,\n\011\011\011\011\011help = info.help,\n\011\011\011\011}\n\011\011\011elseif info.alias then\n\011\011\011\011cmd.aliases_[name] = info.alias\n\011\011\011elseif info.macro then\n\011\011\011\011cmd.commands_[name] = {\n\011\011\011\011\011macro = info.macro,\n\011\011\011\011\011help = info.help,\n\011\011\011\011}\n\011\011\011else\n\011\011\011\011cmd.commands_[name] = {\n\011\011\011\011\011func = info.func,\n\011\011\011\011\011help = info.help,\n\011\011\011\011}\n\011\011\011end\n\011\011end\n\011\011table.sort(collect)\n\011\011cmd.list_str_ = table.concat(collect, \" \")\n\011\011return cmd\n\011end\n\011\n\011return {\n\011\011new = new,\n\011}\n\011\nend\n\nrequire_preload__[\"tptmp.common.config\"] = function()\n\n\011return {\n\011\011-- ***********************************************************************\n\011\011-- *** The following options apply to both the server and the clients. ***\n\011\011-- *** Handle with care; changing options here means having to update  ***\n\011\011-- *** the client you ship.                                            ***\n\011\011-- ***********************************************************************\n\011\n\011\011-- * Protocol version, between 0 and 254. 255 is reserved for future use.\n\011\011version = 24,\n\011\n\011\011-- * Client-to-server message size limit, between 0 and 255, the latter\n\011\011--   limit being imposted by the protocol.\n\011\011message_size = 200, -- * Upper limit is 255.\n\011\n\011\011-- * Client-to-server message rate limit. Specifies the amount of time in\n\011\011--   seconds that must have elapsed since the previous message in order\n\011\011--   for the current message to be processed.\n\011\011message_interval = 1,\n\011\n\011\011-- * Authentication backend URL.\n\011\011auth_backend = \"https://powdertoy.co.uk/ExternalAuth.api\",\n\011\n\011\011-- * Authentication backend timeout in seconds.\n\011\011auth_backend_timeout = 3,\n\011\n\011\011-- * Username to UID backend URL.\n\011\011uid_backend = \"https://powdertoy.co.uk/User.json\",\n\011\n\011\011-- * Username to UID backend timeout in seconds.\n\011\011uid_backend_timeout = 3,\n\011\n\011\011-- * Host to connect to by default.\n\011\011host = \"tptmp.starcatcher.us\",\n\011\n\011\011-- * Port to connect to by default.\n\011\011port = 34403,\n\011\n\011\011-- * Encrypt traffic between player clients and the server.\n\011\011secure = true,\n\011}\n\011\nend\n\nrequire_preload__[\"tptmp.common.util\"] = function()\n\n\011local function version_less(lhs, rhs)\n\011\011for i = 1, math.max(#lhs, #rhs) do\n\011\011\011local left = lhs[i] or 0\n\011\011\011local right = rhs[i] or 0\n\011\011\011if left < right then\n\011\011\011\011return true\n\011\011\011end\n\011\011\011if left > right then\n\011\011\011\011return false\n\011\011\011end\n\011\011end\n\011\011return false\n\011end\n\011\n\011local function version_equal(lhs, rhs)\n\011\011for i = 1, math.max(#lhs, #rhs) do\n\011\011\011local left = lhs[i] or 0\n\011\011\011local right = rhs[i] or 0\n\011\011\011if left ~= right then\n\011\011\011\011return false\n\011\011\011end\n\011\011end\n\011\011return true\n\011end\n\011\n\011return {\n\011\011version_less = version_less,\n\011\011version_equal = version_equal,\n\011}\n\011\nend\n\nrequire(\"tptmp.client\").run()\n";
	luaL_loadbuffer(l, multiplayer_luac, multiplayer_luac_sz, "@multiplayer.lua");
	lua_pcall(l, 0, 0, 0);
#else
	unsigned int size = 0;
	const char* data = NULL;
	Platform::LoadFileInResource(IDI_TPTMP, LUASCRIPT, size, data);
	char *buffer = new char[size+1];
	::memcpy(buffer, data, size);
	buffer[size] = 0;
	luaL_loadbuffer(l, buffer, size, "@multiplayer.lua");
	lua_pcall(l, 0, 0, 0);
	delete[] buffer;
#endif
}
#endif
